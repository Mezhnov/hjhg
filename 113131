def handle_client(conn, addr):
    """
    Обрабатывает подключения клиентов в отдельных потоках.
    """
    logging.info(f"Подключен клиент: {addr}")
    
    try:
        while True:
            data = b""
            while b"\n\n" not in data:
                part = conn.recv(BUFFER_SIZE)
                if not part:
                    raise ConnectionResetError("Клиент закрыл соединение")
                data += part

            header_data, _, body = data.partition(b"\n\n")
            headers = {}
            for line in header_data.decode().split('\n'):
                if ': ' in line:
                    key, value = line.split(': ', 1)
                    headers[key.strip().upper()] = value.strip()

            action = headers.get('ACTION')
            resource = headers.get('RESOURCE')
            logging.info(f"Получен запрос ACTION={action}, RESOURCE={resource}")

            if action == 'GET' and resource:
                parsed_resource = urlparse(resource)
                domain = parsed_resource.hostname
                path = parsed_resource.path.lstrip('/')  # Удаление ведущего '/'
                query = parsed_resource.query

                if domain not in allowed_domains:
                    message = "Domain not allowed"
                    response = (
                        f"SMP 1.0\n"
                        f"STATUS: ERROR\n"
                        f"MESSAGE: {message}\n"
                        f"CONTENT-TYPE: text/plain\n"
                        f"CONTENT-LENGTH: {len(message)}\n\n"
                        f"{message}"
                    )
                    conn.sendall(response.encode())
                    logging.warning(f"Запрошен запрещенный домен: {domain}")
                    continue

                domain_root = allowed_domains[domain]

                if domain == 'search.com':
                    if path == '' or path == '/':
                        # Отправить поисковую форму
                        headers_resp, body_resp = handle_search_form()
                        response = f"SMP 1.0\nSTATUS: OK\n" + "\n".join([f"{k}: {v}" for k, v in headers_resp.items()]) + "\n\n"
                        conn.sendall(response.encode() + body_resp)
                        logging.info(f"Отправлена поисковая форма клиенту {addr}")
                    elif path == 'search':
                        # Обработка поискового запроса
                        headers_resp, body_resp = handle_search_request(resource)
                        response = f"SMP 1.0\nSTATUS: {headers_resp.get('STATUS', 'OK')}\n" + "\n".join([f"{k}: {v}" for k, v in headers_resp.items() if k not in ['STATUS', 'MESSAGE']]) + "\n\n"
                        conn.sendall(response.encode() + body_resp)
                        logging.info(f"Отправлены результаты поиска клиенту {addr}")
                    else:
                        # Обслуживание других ресурсов в search.com, например, статических
                        if path.startswith('static/'):
                            static_path = path[len('static/'):]
                            headers_resp, body_resp = serve_static_file(static_path)
                            if headers_resp.get('STATUS') == 'ERROR':
                                response = f"SMP 1.0\nSTATUS: ERROR\nMESSAGE: {headers_resp.get('MESSAGE')}\nCONTENT-TYPE: text/plain\nCONTENT-LENGTH: {headers_resp.get('CONTENT-LENGTH')}\n\n{headers_resp.get('MESSAGE')}"
                                conn.sendall(response.encode())
                            else:
                                response = f"SMP 1.0\nSTATUS: OK\n" + "\n".join([f"{k}: {v}" for k, v in headers_resp.items()]) + "\n\n"
                                conn.sendall(response.encode() + body_resp)
                        else:
                            # Если путь не найден
                            message = "Resource not found"
                            response = (
                                f"SMP 1.0\n"
                                f"STATUS: ERROR\n"
                                f"MESSAGE: {message}\n"
                                f"CONTENT-TYPE: text/plain\n"
                                f"CONTENT-LENGTH: {len(message)}\n\n"
                                f"{message}"
                            )
                            conn.sendall(response.encode())
                            logging.warning(f"Ресурс не найден в search.com: {path}")
                else:
                    # Обслуживание других доменов
                    if path.startswith('static/'):
                        static_path = path[len('static/'):]
                        headers_resp, body_resp = serve_static_file(static_path)
                        if headers_resp.get('STATUS') == 'ERROR':
                            response = f"SMP 1.0\nSTATUS: ERROR\nMESSAGE: {headers_resp.get('MESSAGE')}\nCONTENT-TYPE: text/plain\nCONTENT-LENGTH: {headers_resp.get('CONTENT-LENGTH')}\n\n{headers_resp.get('MESSAGE')}"
                            conn.sendall(response.encode())
                        else:
                            response = f"SMP 1.0\nSTATUS: OK\n" + "\n".join([f"{k}: {v}" for k, v in headers_resp.items()]) + "\n\n"
                            conn.sendall(response.encode() + body_resp)
                    else:
                        # Обслуживание статических HTML-файлов
                        file_path = os.path.join(domain_root, path)
                        if os.path.isdir(file_path):
                            file_path = os.path.join(file_path, 'index.html')
                        if os.path.exists(file_path):
                            with open(file_path, 'rb') as f:
                                content = f.read()
                            # Определение типа контента
                            _, ext = os.path.splitext(file_path)
                            ext = ext.lower()
                            if ext in ['.html', '.htm']:
                                content_type = 'text/html'
                            elif ext == '.css':
                                content_type = 'text/css'
                            elif ext == '.png':
                                content_type = 'image/png'
                            elif ext in ['.jpg', '.jpeg']:
                                content_type = 'image/jpeg'
                            elif ext == '.gif':
                                content_type = 'image/gif'
                            elif ext == '.js':
                                content_type = 'application/javascript'
                            else:
                                content_type = 'application/octet-stream'
                            
                            headers_resp = {'CONTENT-TYPE': content_type, 'CONTENT-LENGTH': str(len(content))}
                            response = f"SMP 1.0\nSTATUS: OK\n" + "\n".join([f"{k}: {v}" for k, v in headers_resp.items()]) + "\n\n"
                            conn.sendall(response.encode() + content)
                            logging.info(f"Отправлен файл {file_path} клиенту {addr}")
                        else:
                            # Ресурс не найден
                            message = "Resource not found"
                            response = (
                                f"SMP 1.0\n"
                                f"STATUS: ERROR\n"
                                f"MESSAGE: {message}\n"
                                f"CONTENT-TYPE: text/plain\n"
                                f"CONTENT-LENGTH: {len(message)}\n\n"
                                f"{message}"
                            )
                            conn.sendall(response.encode())
                            logging.warning(f"Ресурс не найден: {file_path}")
            else:
                # Неподдерживаемый метод или отсутствующие параметры
                message = "Invalid ACTION or missing RESOURCE"
                response = (
                    f"SMP 1.0\n"
                    f"STATUS: ERROR\n"
                    f"MESSAGE: {message}\n"
                    f"CONTENT-TYPE: text/plain\n"
                    f"CONTENT-LENGTH: {len(message)}\n\n"
                    f"{message}"
                )
                conn.sendall(response.encode())
                logging.warning(f"Некорректный запрос: ACTION={action}, RESOURCE={resource}")

    except ConnectionResetError as cre:
        logging.warning(f"Соединение с клиентом {addr} было сброшено: {cre}")
    except Exception as e:
        logging.error(f"Произошла ошибка при обработке клиента {addr}: {e}")
    finally:
        conn.close()
        logging.info(f"Соединение с клиентом {addr} закрыто")
