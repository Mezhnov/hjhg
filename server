# server.py
import socket
import threading
import logging
import os

# Server Settings
HOST = '0.0.0.0'  # Bind to all interfaces
PORT = 8080
BUFFER_SIZE = 4096  # Buffer size for data transmission

# Logging Configuration
logging.basicConfig(
    filename='smp_server.log',
    level=logging.INFO,
    format='%(asctime)s:%(levelname)s:%(message)s'
)

# Resource Mapping
# Maps domains to their respective resources
domain_mapping = {
    'example.com': {
        'html_file': 'example/index.html',
        'css_file': 'example/css/styles.css',
        'image_file': 'example/images/img.png'
    },
    'test.com': {
        'html_file': 'test/index.html',
        'css_file': 'test/css/style_test.css',
        'image_file': 'test/images/image_test.jpg'
    }
}

def send_large_file(conn, filepath):
    """
    Sends large files in chunks to the client.
    """
    if not os.path.exists(filepath):
        logging.error(f"File not found: {filepath}")
        response = "SMP 1.0\nSTATUS: ERROR\nMESSAGE: File not found\n\n"
        conn.send(response.encode())
        return

    try:
        file_size = os.path.getsize(filepath)
        # Determine content type based on file extension
        _, ext = os.path.splitext(filepath)
        ext = ext.lower()
        if ext in ['.html', '.htm']:
            content_type = 'text/html'
        elif ext == '.css':
            content_type = 'text/css'
        elif ext == '.png':
            content_type = 'image/png'
        elif ext in ['.jpg', '.jpeg']:
            content_type = 'image/jpeg'
        else:
            content_type = 'application/octet-stream'

        # Send headers
        response_headers = (
            "SMP 1.0\n"
            "STATUS: OK\n"
            f"CONTENT-TYPE: {content_type}\n"
            f"CONTENT-LENGTH: {file_size}\n\n"
        )
        conn.send(response_headers.encode())
        logging.info(f"Starting file transfer: {filepath}")

        # Send file in chunks
        with open(filepath, 'rb') as f:
            while True:
                chunk = f.read(BUFFER_SIZE)
                if not chunk:
                    break
                conn.sendall(chunk)
        logging.info(f"File transfer completed: {filepath}")
    except Exception as e:
        logging.error(f"Error sending file {filepath}: {e}")
        response = f"SMP 1.0\nSTATUS: ERROR\nMESSAGE: Error while sending file: {e}\n\n"
        conn.send(response.encode())

def handle_client(conn, addr):
    """
    Handles client requests in a separate thread.
    """
    logging.info(f"Connected: {addr}")
    initial_message = "SMP 1.0\nSTATUS: OK\nMESSAGE: Connected successfully\n\n"
    conn.send(initial_message.encode())
    logging.info(f"Sent to {addr}:\n{initial_message}")

    while True:
        try:
            data = b""
            while b"\n\n" not in data:
                part = conn.recv(BUFFER_SIZE)
                if not part:
                    raise ConnectionResetError("Connection closed by client")
                data += part

            header_data, _, body = data.partition(b"\n\n")
            headers = {}
            for line in header_data.decode().split('\n'):
                if ': ' in line:
                    key, value = line.split(': ', 1)
                    headers[key.strip()] = value.strip()

            action = headers.get('ACTION')
            resource = headers.get('RESOURCE')

            if action == 'GET' and resource:
                # Parse the resource to extract domain and path
                domain, _, path = resource.partition('/')
                domain_info = domain_mapping.get(domain)

                if not domain_info:
                    response = "SMP 1.0\nSTATUS: ERROR\nMESSAGE: Domain not found\n\n"
                    conn.send(response.encode())
                    logging.error(f"Domain not found: {domain}")
                    continue

                # Determine the file to send based on the path
                if path.startswith('css/'):
                    css_filename = path
                    css_file = os.path.join(domain, css_filename)
                    if css_file and os.path.exists(css_file):
                        send_large_file(conn, css_file)
                    else:
                        response = "SMP 1.0\nSTATUS: ERROR\nMESSAGE: CSS file not found\n\n"
                        conn.send(response.encode())
                        logging.error(f"CSS file not found: {css_file}")
                elif path.startswith('images/'):
                    image_filename = path
                    image_file = os.path.join(domain, image_filename)
                    if image_file and os.path.exists(image_file):
                        send_large_file(conn, image_file)
                    else:
                        response = "SMP 1.0\nSTATUS: ERROR\nMESSAGE: Image file not found\n\n"
                        conn.send(response.encode())
                        logging.error(f"Image file not found: {image_file}")
                elif path == '':
                    # If no path is specified, send the main HTML file
                    html_file = domain_info.get('html_file')
                    if html_file and os.path.exists(html_file):
                        send_large_file(conn, html_file)
                    else:
                        response = "SMP 1.0\nSTATUS: ERROR\nMESSAGE: HTML file not found\n\n"
                        conn.send(response.encode())
                        logging.error(f"HTML file not found: {html_file}")
                else:
                    # Handle other paths or nested resources
                    requested_file = os.path.join(domain, path)
                    if os.path.exists(requested_file):
                        send_large_file(conn, requested_file)
                    else:
                        response = "SMP 1.0\nSTATUS: ERROR\nMESSAGE: Resource not found\n\n"
                        conn.send(response.encode())
                        logging.error(f"Resource not found: {requested_file}")
            else:
                response = "SMP 1.0\nSTATUS: ERROR\nMESSAGE: Invalid action or resource\n\n"
                conn.send(response.encode())
                logging.error(f"Invalid action or resource: ACTION={action}, RESOURCE={resource}")

        except ConnectionResetError as e:
            logging.info(f"Client disconnected {addr}: {e}")
            break
        except Exception as e:
            logging.error(f"Error with client {addr}: {e}")
            break

    conn.close()
    logging.info(f"Connection closed with {addr}")

def start_server():
    """
    Starts the SMP server to listen for incoming connections.
    """
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        server_socket.bind((HOST, PORT))
        server_socket.listen()
        logging.info(f"Server started on {HOST}:{PORT}")

        while True:
            conn, addr = server_socket.accept()
            client_thread = threading.Thread(target=handle_client, args=(conn, addr), daemon=True)
            client_thread.start()

if __name__ == "__main__":
    start_server()
