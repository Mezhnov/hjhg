#include <windows.h>
#include <richedit.h>
#include <string>
#include <fstream>

// Глобальные переменные
HINSTANCE hInst;
HWND hMarkyEdit;
HWND hStylinEdit;
HWND hOutputWindow;

// Декларация функций
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK OutputWndProc(HWND, UINT, WPARAM, LPARAM);

std::string ParseMarky(const std::string& markyCode);
std::string ParseStylin(const std::string& stylinCode);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow)
{
    LoadLibrary(TEXT("Riched20.dll")); // Загрузка библиотеки RichEdit
    hInst = hInstance;

    WNDCLASS wc = {};
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = TEXT("MarkyStylinIDE");

    RegisterClass(&wc);

    HWND hwnd = CreateWindowEx(
        0,
        wc.lpszClassName,
        TEXT("Marky & Stylin IDE"),
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 800, 600,
        nullptr,
        nullptr,
        hInstance,
        nullptr
    );

    ShowWindow(hwnd, nCmdShow);

    // Цикл сообщений
    MSG msg = {};
    while (GetMessage(&msg, nullptr, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return 0;
}

void CreateControls(HWND hwnd)
{
    CreateWindow(TEXT("STATIC"), TEXT("Marky Code:"),
        WS_VISIBLE | WS_CHILD,
        10, 10, 100, 20,
        hwnd, nullptr, hInst, nullptr);

    hMarkyEdit = CreateWindowEx(WS_EX_CLIENTEDGE, RICHEDIT_CLASS, TEXT(""),
        WS_VISIBLE | WS_CHILD | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
        10, 30, 360, 200,
        hwnd, nullptr, hInst, nullptr);

    CreateWindow(TEXT("STATIC"), TEXT("Stylin Code:"),
        WS_VISIBLE | WS_CHILD,
        380, 10, 100, 20,
        hwnd, nullptr, hInst, nullptr);

    hStylinEdit = CreateWindowEx(WS_EX_CLIENTEDGE, RICHEDIT_CLASS, TEXT(""),
        WS_VISIBLE | WS_CHILD | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
        380, 30, 360, 200,
        hwnd, nullptr, hInst, nullptr);

    HWND hRunButton = CreateWindow(TEXT("BUTTON"), TEXT("Запустить"),
        WS_VISIBLE | WS_CHILD,
        10, 240, 100, 30,
        hwnd, (HMENU)1, hInst, nullptr);
}

void OpenOutputWindow(const std::string& htmlContent)
{
    WNDCLASS wc = {};
    wc.lpfnWndProc = OutputWndProc;
    wc.hInstance = hInst;
    wc.lpszClassName = TEXT("OutputWindowClass");

    RegisterClass(&wc);

    hOutputWindow = CreateWindowEx(
        0,
        wc.lpszClassName,
        TEXT("Результат"),
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 800, 600,
        nullptr,
        nullptr,
        hInst,
        nullptr
    );

    ShowWindow(hOutputWindow, SW_SHOW);

    // Здесь можно использовать WebBrowser Control для отображения HTML
    // Или отобразить текст в статическом контроле
    HWND hContent = CreateWindowEx(WS_EX_CLIENTEDGE, RICHEDIT_CLASS, TEXT(""),
        WS_VISIBLE | WS_CHILD | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | ES_READONLY,
        10, 10, 760, 540,
        hOutputWindow, nullptr, hInst, nullptr);

    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
    std::wstring wHtmlContent = converter.from_bytes(htmlContent);

    SetWindowText(hContent, wHtmlContent.c_str());
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_CREATE:
        CreateControls(hwnd);
        break;
    case WM_COMMAND:
        if (LOWORD(wParam) == 1) // Нажата кнопка "Запустить"
        {
            // Получаем код из контролов
            TCHAR markyBuffer[10000];
            GetWindowText(hMarkyEdit, markyBuffer, 10000);
            std::wstring wMarkyCode = markyBuffer;
            std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
            std::string markyCode = converter.to_bytes(wMarkyCode);

            TCHAR stylinBuffer[10000];
            GetWindowText(hStylinEdit, stylinBuffer, 10000);
            std::wstring wStylinCode = stylinBuffer;
            std::string stylinCode = converter.to_bytes(wStylinCode);

            // Парсим код
            std::string htmlContent = ParseMarky(markyCode);
            std::string cssContent = ParseStylin(stylinCode);

            // Объединяем HTML и CSS
            std::string fullContent = "<html><head><style>" + cssContent + "</style></head><body>" + htmlContent + "</body></html>";

            // Открываем окно вывода
            OpenOutputWindow(fullContent);
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

LRESULT CALLBACK OutputWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_DESTROY:
        hOutputWindow = nullptr;
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// Простейший парсер Marky
std::string ParseMarky(const std::string& markyCode)
{
    // Здесь должен быть парсер Marky, преобразующий код в HTML
    // Для упрощения возвращаем заглушку
    return "<h1>Заголовок из Marky</h1><p>Текст из Marky</p>";
}

// Простейший парсер Stylin
std::string ParseStylin(const std::string& stylinCode)
{
    // Здесь должен быть парсер Stylin, преобразующий код в CSS
    // Для упрощения возвращаем заглушку
    return "body { font-family: Arial; } h1 { color: blue; }";
}
