// main.cpp

#include <windows.h>
#include <wlanapi.h>
#include <objbase.h>
#include <wtypes.h>
#include <string>
#include <vector>
#include <tchar.h>
#include <commctrl.h>
#include <strsafe.h>

#pragma comment(lib, "wlanapi.lib")
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "comctl32.lib")

#define IDC_LISTBOX 101
#define IDC_BUTTON_CONNECT 102
#define MAX_LOADSTRING 100

// Глобальные переменные
HINSTANCE hInst;                                // Текущий инстанс
WCHAR szTitle[MAX_LOADSTRING] = L"Wi-Fi Manager";                  // Заголовок окна
WCHAR szWindowClass[MAX_LOADSTRING] = L"WiFiManagerClass";            // имя класса окна

// Структура для хранения информации о Wi-Fi сетях
struct WiFiNetwork {
    std::wstring ssid;
    std::wstring security;
};

// Функции объявления
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
BOOL RefreshWiFiList(HWND hListBox);
BOOL ConnectToWiFi(const std::wstring& ssid, const std::wstring& password);

// Точка входа
int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
{
    // Инициализация COM
    HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (FAILED(hr)) {
        MessageBox(NULL, L"Не удалось инициализировать COM.", szTitle, MB_ICONERROR);
        return 0;
    }

    // Инициализация общих контролов
    INITCOMMONCONTROLSEX icex;
    icex.dwSize = sizeof(icex);
    icex.dwICC = ICC_LISTVIEW_CLASSES;
    InitCommonControlsEx(&icex);

    MyRegisterClass(hInstance);

    // Выполнить инициализацию приложения
    if (!InitInstance (hInstance, nCmdShow))
    {
        CoUninitialize();
        return FALSE;
    }

    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(0));

    MSG msg;

    // Цикл сообщений
    while (GetMessage(&msg, nullptr, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    CoUninitialize();
    return (int) msg.wParam;
}

// Функция регистрации класса окна
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEXW wcex;

    wcex.cbSize = sizeof(WNDCLASSEX);

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIconW(NULL, IDI_APPLICATION);
    wcex.hCursor        = LoadCursorW(NULL, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName   = NULL;
    wcex.lpszClassName  = szWindowClass;
    wcex.hIconSm        = LoadIconW(NULL, IDI_APPLICATION);

    return RegisterClassExW(&wcex);
}

// Функция инициализации экземпляра
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   hInst = hInstance; // Сохранить инстанс в глобальную переменную

   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, 600, 400, nullptr, nullptr, hInstance, nullptr);

   if (!hWnd)
   {
      return FALSE;
   }

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
}

// Основная процедура окна
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static HWND hListBox;
    static HWND hButtonConnect;
    static std::vector<WiFiNetwork> networks;

    switch (message)
    {
    case WM_CREATE:
        {
            // Создание ListBox для отображения сетей
            hListBox = CreateWindowEx(WS_EX_CLIENTEDGE, L"LISTBOX", NULL,
                WS_CHILD | WS_VISIBLE | LBS_STANDARD | WS_VSCROLL | WS_BORDER,
                20, 20, 400, 300, hWnd, (HMENU)IDC_LISTBOX, hInst, NULL);

            // Создание кнопки "Подключиться"
            hButtonConnect = CreateWindowEx(0, L"BUTTON", L"Подключиться",
                WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,
                440, 150, 120, 30, hWnd, (HMENU)IDC_BUTTON_CONNECT, hInst, NULL);

            // Сканирование сетей при запуске
            RefreshWiFiList(hListBox);
        }
        break;
    case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
            switch (wmId)
            {
            case IDC_BUTTON_CONNECT:
                {
                    int sel = (int)SendMessage(hListBox, LB_GETCURSEL, 0, 0);
                    if (sel != LB_ERR) {
                        wchar_t ssid[256];
                        wchar_t sec[256];
                        SendMessage(hListBox, LB_GETTEXT, sel, (LPARAM)ssid);
                        SendMessage(hListBox, LB_GETTEXT, sel | 0x8000, (LPARAM)sec); // Получение второй строки (безопасность)

                        // Запрос пароля
                        wchar_t password[256];
                        if (DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_DIALOG1), hWnd, [](HWND dlg, UINT msg, WPARAM wParam, LPARAM lParam) -> INT_PTR {
                            static wchar_t* pwd;
                            switch (msg)
                            {
                            case WM_INITDIALOG:
                                pwd = new wchar_t[256];
                                SetWindowText(dlg, L"Введите пароль:");
                                return TRUE;
                            case WM_COMMAND:
                                if (LOWORD(wParam) == IDC_BUTTON_OK) {
                                    GetDlgItemTextW(dlg, IDC_EDIT_PASSWORD, pwd, 256);
                                    EndDialog(dlg, TRUE);
                                    return TRUE;
                                }
                                else if (LOWORD(wParam) == IDC_BUTTON_CANCEL) {
                                    EndDialog(dlg, FALSE);
                                    return TRUE;
                                }
                                break;
                            }
                            return FALSE;
                        }, 0)) {
                            // Пользователь нажал "ОК" и ввёл пароль
                            // Здесь вы можете передать пароль в функцию подключения
                            // Например:
                            // ConnectToWiFi(ssid, password);
                            MessageBoxW(hWnd, L"Функция подключения не реализована.", L"Информация", MB_ICONINFORMATION);
                        }
                    }
                    else {
                        MessageBoxW(hWnd, L"Пожалуйста, выберите сеть для подключения.", L"Предупреждение", MB_ICONWARNING);
                    }
                }
                break;
            default:
                break;
            }
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hWnd, &ps);
            // Здесь можно добавить отрисовку, если необходимо
            EndPaint(hWnd, &ps);
        }
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

// Функция сканирования доступных Wi-Fi сетей и обновления ListBox
BOOL RefreshWiFiList(HWND hListBox)
{
    HANDLE hClient = NULL;
    DWORD dwMaxClient = 2;      // Версия API
    DWORD dwCurVersion = 0;
    PWLAN_INTERFACE_INFO_LIST pIfList = NULL;

    // Открытие дескриптора клиента WLAN
    if (WlanOpenHandle(dwMaxClient, NULL, &dwCurVersion, &hClient) != ERROR_SUCCESS) {
        MessageBoxW(NULL, L"Не удалось открыть дескриптор WLAN.", L"Ошибка", MB_ICONERROR);
        return FALSE;
    }

    // Перечисление интерфейсов WLAN
    if (WlanEnumInterfaces(hClient, NULL, &pIfList) != ERROR_SUCCESS) {
        MessageBoxW(NULL, L"Не удалось перечислить интерфейсы WLAN.", L"Ошибка", MB_ICONERROR);
        WlanCloseHandle(hClient, NULL);
        return FALSE;
    }

    // Очистка ListBox
    SendMessage(hListBox, LB_RESETCONTENT, 0, 0);

    // Перебор интерфейсов
    for (unsigned int i = 0; i < pIfList->dwNumberOfItems; i++) {
        PWLAN_INTERFACE_INFO pIfInfo = &pIfList->InterfaceInfo[i];
        HANDLE hScan = NULL;
        PWLAN_AVAILABLE_NETWORK_LIST pBssList = NULL;

        // Сканирование доступных сетей
        if (WlanScan(hClient, &pIfInfo->InterfaceGuid, NULL, NULL, &pBssList) != ERROR_SUCCESS) {
            continue;
        }

        // Получение списка доступных сетей
        if (WlanGetAvailableNetworkList(hClient, &pIfInfo->InterfaceGuid, 0, NULL, &pBssList) != ERROR_SUCCESS) {
            if (pBssList != NULL)
                WlanFreeMemory(pBssList);
            continue;
        }

        // Перебор доступных сетей
        for (unsigned int j = 0; j < pBssList->dwNumberOfItems; j++) {
            PWLAN_AVAILABLE_NETWORK pBssEntry = &pBssList->Network[j];
            std::wstring ssid(pBssEntry->dot11Ssid.ucSSID, pBssEntry->dot11Ssid.uSSIDLength);

            std::wstring security = pBssEntry->bSecurityEnabled ? L"Закрытая" : L"Открытая";

            // Добавление SSID в ListBox
            SendMessage(hListBox, LB_ADDSTRING, 0, (LPARAM)ssid.c_str());
            // Добавление информации о безопасности (на отдельной строке)
            SendMessage(hListBox, LB_ADDSTRING, 0, (LPARAM)security.c_str());
        }

        if (pBssList != NULL)
            WlanFreeMemory(pBssList);
    }

    if (pIfList != NULL)
        WlanFreeMemory(pIfList);

    // Закрытие дескриптора клиента WLAN
    WlanCloseHandle(hClient, NULL);

    return TRUE;
}

// Функция подключения к выбранной Wi-Fi сети (не реализована)
BOOL ConnectToWiFi(const std::wstring& ssid, const std::wstring& password)
{
    // Реализация подключения требует использования Native Wifi API с настройкой профиля безопасности
    // Это сложная процедура и выходит за рамки данного примера

    // Рекомендуется ознакомиться с документацией Microsoft по подключению к Wi-Fi сетям:
    // https://docs.microsoft.com/en-us/windows/win32/nativewifi/example--connect-to-a-wireless-network

    return TRUE;
}
