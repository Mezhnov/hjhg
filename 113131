#include <windows.h>
#include <commctrl.h>   // For common controls
#include <richedit.h>   // For Rich Edit controls
#include <string>
#include <vector>

// Resource identifiers
#define ID_EDIT         101
#define ID_DOWNLOAD_BAR 102
#define ID_TAB_CONTROL  103

// Global variables
HINSTANCE hInst;

// Forward declarations of functions
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void InitializeControls(HWND);
void ResizeControls(HWND);
void AddNewTab(HWND hTabCtrl, const TCHAR* szFileName);

// Structure to hold tab information
struct TabInfo {
    TCHAR fileName[MAX_PATH];
};

std::vector<TabInfo> tabInfos;

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine, int nCmdShow)
{
    // Store instance handle in our global variable
    hInst = hInstance;

    // Register the window class
    WNDCLASS wc = {};
    wc.lpfnWndProc   = WndProc;
    wc.hInstance     = hInstance;
    wc.lpszClassName = TEXT("BasicIDEWindow");
    wc.hCursor       = LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);

    if (!RegisterClass(&wc))
    {
        MessageBox(nullptr, TEXT("Failed to register window class!"), TEXT("Error"), MB_OK | MB_ICONERROR);
        return 0;
    }

    // Create the main window
    HWND hWnd = CreateWindow(
        wc.lpszClassName,
        TEXT("Basic IDE"),
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 800, 600,
        nullptr,
        nullptr,
        hInstance,
        nullptr
    );

    if (!hWnd)
    {
        MessageBox(nullptr, TEXT("Failed to create window!"), TEXT("Error"), MB_OK | MB_ICONERROR);
        return 0;
    }

    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);

    // Main message loop
    MSG msg = {};
    while (GetMessage(&msg, nullptr, 0, 0))
    {
        if (!TranslateAccelerator(hWnd, nullptr, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return (int) msg.wParam;
}

void InitializeControls(HWND hWnd)
{
    // Load the Rich Edit library
    LoadLibrary(TEXT("Msftedit.dll"));

    // Create the Tab Control
    HWND hTabCtrl = CreateWindowEx(
        0, WC_TABCONTROL, TEXT(""), 
        WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | TCS_FOCUSONBUTTONDOWN | TCS_HOTTRACK,
        0, 0, 0, 0, hWnd, (HMENU)ID_TAB_CONTROL, hInst, NULL);

    // Add an initial tab (Untitled)
    AddNewTab(hTabCtrl, TEXT("Untitled"));

    // Create the Edit control for code writing (multi-line, vertical scroll)
    HWND hEdit = CreateWindowEx(
        0,                      // Extended styles
        MSFTEDIT_CLASS,         // Rich Edit class
        nullptr,                // No default text
        WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
        0, 0, 0, 0,             // Will resize later
        hWnd,
        (HMENU)ID_EDIT,
        hInst,
        nullptr
    );

    // Create the "Download Bar" at the bottom
    HWND hDownloadBar = CreateWindowEx(
        0,
        TEXT("STATIC"),         // Static control for simplicity
        TEXT("Downloading: example_file.txt"), // File name displayed
        WS_CHILD | WS_VISIBLE | SS_LEFT,
        0, 0, 0, 0,             // Will resize later
        hWnd,
        (HMENU)ID_DOWNLOAD_BAR,
        hInst,
        nullptr
    );

    // Set font for controls
    HFONT hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    SendMessage(hEdit, WM_SETFONT, (WPARAM)hFont, TRUE);
    SendMessage(hDownloadBar, WM_SETFONT, (WPARAM)hFont, TRUE);
}

void ResizeControls(HWND hWnd)
{
    RECT rcClient;
    GetClientRect(hWnd, &rcClient);

    // Determine sizes
    int tabHeight = 30;
    int downloadBarHeight = 30;
    int editHeight = rcClient.bottom - tabHeight - downloadBarHeight;

    // Resize Tab Control
    HWND hTabCtrl = GetDlgItem(hWnd, ID_TAB_CONTROL);
    if (hTabCtrl)
    {
        SetWindowPos(hTabCtrl, nullptr, 0, 0, rcClient.right, tabHeight, SWP_NOZORDER);
    }

    // Resize Edit control
    HWND hEdit = GetDlgItem(hWnd, ID_EDIT);
    if (hEdit)
    {
        SetWindowPos(hEdit, nullptr, 0, tabHeight, rcClient.right, editHeight, SWP_NOZORDER);
    }

    // Resize Download Bar
    HWND hDownloadBar = GetDlgItem(hWnd, ID_DOWNLOAD_BAR);
    if (hDownloadBar)
    {
        SetWindowPos(hDownloadBar, nullptr, 0, tabHeight + editHeight, rcClient.right, downloadBarHeight, SWP_NOZORDER);
    }
}

void AddNewTab(HWND hTabCtrl, const TCHAR* szFileName)
{
    TC_ITEM tie = {0};
    tie.mask = TCIF_TEXT | TCIF_IMAGE;
    tie.pszText = (LPTSTR)szFileName;
    tie.cchTextMax = _tcslen(szFileName);

    int index = TabCtrl_InsertItem(hTabCtrl, tabInfos.size(), &tie);

    TabInfo newTab;
    _tcscpy_s(newTab.fileName, MAX_PATH, szFileName);
    tabInfos.push_back(newTab);

    // Select the newly added tab
    TabCtrl_SetCurSel(hTabCtrl, index);
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_CREATE:
        InitializeControls(hWnd);
        break;

    case WM_SIZE:
        ResizeControls(hWnd);
        break;

    case WM_COMMAND:
        {
            int wmId    = LOWORD(wParam);
            int wmEvent = HIWORD(wParam);

            // Handle menu and control messages here if needed
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code) 
            {
            case TCN_SELCHANGE: 
                {
                    HWND hTabCtrl = GetDlgItem(hWnd, ID_TAB_CONTROL);
                    int nTab = TabCtrl_GetCurSel(hTabCtrl);
                    if (nTab != -1 && nTab < (int)tabInfos.size())
                    {
                        // Here you would update the edit control content or perform other actions based on the selected tab
                        MessageBox(hWnd, tabInfos[nTab].fileName, TEXT("Current Tab"), MB_OK);
                    }
                }
                break;
            }
        }
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}
