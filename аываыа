#include <windows.h>
#include <gdiplus.h>
#include <urlmon.h>
#include <shlwapi.h>
#include <string>
#include <vector>
#include <ctime>

#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "urlmon.lib")
#pragma comment(lib, "shlwapi.lib")

using namespace Gdiplus;

Bitmap* LoadImageFromURL(const wchar_t* url) {
    wchar_t tempPath[MAX_PATH];
    if (!GetTempPath(MAX_PATH, tempPath)) {
        return nullptr;
    }
    wchar_t tempFile[MAX_PATH];
    if (!GetTempFileName(tempPath, L"IMG", 0, tempFile)) {
        return nullptr;
    }
    HRESULT hr = URLDownloadToFile(NULL, url, tempFile, 0, NULL);
    if (FAILED(hr)) {
        DeleteFile(tempFile);
        return nullptr;
    }
    Bitmap* bmp = Bitmap::FromFile(tempFile);
    DeleteFile(tempFile);
    return bmp && bmp->GetLastStatus() == Ok ? bmp : nullptr;
}

struct DraggableImage {
    Bitmap* image;
    POINT position;
    SIZE size;
    bool dragging = false;
    POINT dragStartPos;

    DraggableImage(Bitmap* bmp, int x, int y, int w, int h)
        : image(bmp), position{ x, y }, size{ w, h } {}

    void Draw(Graphics& graphics) {
        if (image) {
            graphics.DrawImage(image, position.x, position.y, size.cx, size.cy);
        }
    }

    bool HitTest(int x, int y) {
        return x >= position.x && x <= position.x + size.cx &&
               y >= position.y && y <= position.y + size.cy;
    }
};

std::vector<DraggableImage> images;

struct TimeDisplay {
    POINT position;
    bool dragging = false;
    POINT dragStartPos;

    void Draw(Graphics& graphics, HFONT font, HDC hdc) {
        SYSTEMTIME time;
        GetLocalTime(&time);

        wchar_t timeStr[16];
        swprintf(timeStr, 16, L"%02d:%02d", time.wHour, time.wMinute);

        SelectObject(hdc, font);
        TextOut(hdc, position.x, position.y, timeStr, wcslen(timeStr));
    }

    bool HitTest(int x, int y) {
        // Adjust as necessary based on the displayed time position
        RECT timeRect = { position.x, position.y, position.x + 60, position.y + 20 };
        return PtInRect(&timeRect, { x, y });
    }
};

TimeDisplay timeDisplay{ 10, 10 };

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    static bool draggingImage = false;
    static bool draggingTime = false;

    switch (uMsg) {
        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;

        case WM_PAINT: {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &ps);
            Graphics graphics(hdc);

            for (auto& img : images) {
                img.Draw(graphics);
            }

            HFONT font = CreateFont(20, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, DEFAULT_CHARSET,
                                    OUT_OUTLINE_PRECIS, CLIP_DEFAULT_PRECIS, ANTIALIASED_QUALITY,
                                    VARIABLE_PITCH, TEXT("Arial"));
            timeDisplay.Draw(graphics, font, hdc);
            DeleteObject(font);
            EndPaint(hwnd, &ps);
            return 0;
        }

        case WM_LBUTTONDOWN: {
            int x = GET_X_LPARAM(lParam);
            int y = GET_Y_LPARAM(lParam);

            for (auto& img : images) {
                if (img.HitTest(x, y)) {
                    img.dragging = true;
                    img.dragStartPos = { x - img.position.x, y - img.position.y };
                    SetCapture(hwnd);
                    return 0;
                }
            }

            if (timeDisplay.HitTest(x, y)) {
                timeDisplay.dragging = true;
                timeDisplay.dragStartPos = { x - timeDisplay.position.x, y - timeDisplay.position.y };
                SetCapture(hwnd);
            }
            return 0;
        }

        case WM_LBUTTONUP:
            for (auto& img : images) {
                img.dragging = false;
            }
            timeDisplay.dragging = false;
            ReleaseCapture();
            return 0;

        case WM_MOUSEMOVE:
            if (wParam & MK_LBUTTON) {
                int x = GET_X_LPARAM(lParam);
                int y = GET_Y_LPARAM(lParam);

                for (auto& img : images) {
                    if (img.dragging) {
                        img.position.x = x - img.dragStartPos.x;
                        img.position.y = y - img.dragStartPos.y;
                        InvalidateRect(hwnd, NULL, TRUE);
                        return 0;
                    }
                }

                if (timeDisplay.dragging) {
                    timeDisplay.position.x = x - timeDisplay.dragStartPos.x;
                    timeDisplay.position.y = y - timeDisplay.dragStartPos.y;
                    InvalidateRect(hwnd, NULL, TRUE);
                }
            }
            return 0;

        case WM_TIMER:
            if (wParam == 1) {
                InvalidateRect(hwnd, NULL, TRUE);
            }
            return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow) {
    GdiplusStartupInput gdiplusStartupInput;
    ULONG_PTR gdiplusToken;
    GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);

    const wchar_t* urls[] = {
        L"https://i.pinimg.com/736x/44/ba/d5/44bad5b1b0839e5ab430433c6ddfb4be.jpg",
        L"https://example.com/image2.jpg",
        L"https://example.com/image3.jpg",
        L"https://example.com/image4.jpg"
    };
    int posX = 10;
    for (const auto& url : urls) {
        Bitmap* bmp = LoadImageFromURL(url);
        if (bmp) {
            images.emplace_back(bmp, posX, 100, 200, 150);
            posX += 210;
        }
    }

    WNDCLASS wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L"Sample Window Class";
    RegisterClass(&wc);

    HWND hwnd = CreateWindowEx(0, L"Sample Window Class", L"My Window",
                               WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT,
                               800, 600, NULL, NULL, hInstance, NULL);

    ShowWindow(hwnd, nCmdShow);
    SetTimer(hwnd, 1, 60000, NULL); // Update time every 60 seconds

    MSG msg = {};
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    for (auto& img : images) {
        delete img.image;
    }
    GdiplusShutdown(gdiplusToken);
    return 0;
}
