// main.cpp

#include <windows.h>
#include <gdiplus.h>
#include <wininet.h>
#include <string>
#include <vector>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <locale>
#include <codecvt>
#include <windowsx.h>
#include <mmsystem.h> // For PlaySound
#include <CommCtrl.h> // For common controls
#include <richedit.h> // For rich edit controls
#include "resource.h" // Ensure you have this header for resource IDs

#pragma comment(lib, "Gdiplus.lib")
#pragma comment(lib, "Wininet.lib")
#pragma comment(lib, "Comctl32.lib")
#pragma comment(lib, "Msimg32.lib")
#pragma comment(lib, "Imm32.lib")
#pragma comment(lib, "Winmm.lib")

using namespace Gdiplus;

// Global variables
HINSTANCE hInst;
LPCWSTR szWindowClass = L"MainWindowClass";
LPCWSTR szTitle = L"Simple IDE";

// Forward declarations
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void InitializeGDIPlus();
void ShutdownGDIPlus();
void CreateMenus(HWND);
void CreateToolBar(HWND);
void CreateEditControl(HWND);
void OpenFile(HWND);
void SaveFile(HWND);
void AboutDialog(HWND);

ULONG_PTR gdiplusToken;

// Rich Edit handle
HWND hEdit;

// Entry point
int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
{
    hInst = hInstance;

    // Initialize GDI+
    InitializeGDIPlus();

    // Register the window class
    WNDCLASSEX wcex;
    ZeroMemory(&wcex, sizeof(WNDCLASSEX));

    wcex.cbSize = sizeof(WNDCLASSEX);
    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_APPLICATION));
    wcex.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDR_MENU1); // Убедитесь, что у вас есть меню ресурс
    wcex.lpszClassName  = szWindowClass;
    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_APPLICATION));

    if (!RegisterClassEx(&wcex))
    {
        MessageBox(NULL,
            L"Call to RegisterClassEx failed!",
            szTitle,
            NULL);

        ShutdownGDIPlus();
        return 1;
    }

    // Create the window
    HWND hWnd = CreateWindow(
        szWindowClass,
        szTitle,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,
        1024, 768,
        NULL,
        NULL,
        hInstance,
        NULL
    );

    if (!hWnd)
    {
        MessageBox(NULL,
            L"Call to CreateWindow failed!",
            szTitle,
            NULL);

        ShutdownGDIPlus();
        return 1;
    }

    // Show the window
    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);

    // Main message loop
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Shutdown GDI+
    ShutdownGDIPlus();

    return (int) msg.wParam;
}

void InitializeGDIPlus()
{
    GdiplusStartupInput gdiplusStartupInput;
    GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);
}

void ShutdownGDIPlus()
{
    GdiplusShutdown(gdiplusToken);
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_CREATE:
        {
            // Initialize common controls
            INITCOMMONCONTROLSEX icex;
            icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
            icex.dwICC = ICC_WIN95_CLASSES | ICC_BAR_CLASSES;
            InitCommonControlsEx(&icex);

            // Initialize Rich Edit control
            if (!LoadLibrary(L"Msftedit.dll"))
            {
                MessageBox(hWnd, L"Failed to load RichEdit library.", szTitle, MB_OK | MB_ICONERROR);
            }
            else
            {
                CreateEditControl(hWnd);
            }

            // Create Menu
            CreateMenus(hWnd);

            // Create Toolbar
            CreateToolBar(hWnd);
        }
        break;
    case WM_SIZE:
        {
            // Resize edit control to fit the window
            if (hEdit)
            {
                RECT rcClient;
                GetClientRect(hWnd, &rcClient);
                // Assuming toolbar height is 30
                MoveWindow(hEdit, 0, 30, rcClient.right, rcClient.bottom - 30, TRUE);
            }
        }
        break;
    case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
            // Разобрать выбор согласно меню:
            switch (wmId)
            {
            case IDM_NEW:
                SetWindowText(hEdit, L"");
                break;
            case IDM_OPEN:
                OpenFile(hWnd);
                break;
            case IDM_SAVE:
                SaveFile(hWnd);
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            case IDM_ABOUT:
                AboutDialog(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            }
        }
        break;
    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hWnd, &ps);

            // Можно добавить дополнительные графические элементы здесь

            EndPaint(hWnd, &ps);
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
        break;
    }

    return 0;
}

void CreateMenus(HWND hWnd)
{
    HMENU hMenu = CreateMenu();

    // Файл
    HMENU hFileMenu = CreateMenu();
    AppendMenu(hFileMenu, MF_STRING, IDM_NEW, L"&Новый\tCtrl+N");
    AppendMenu(hFileMenu, MF_STRING, IDM_OPEN, L"&Открыть\tCtrl+O");
    AppendMenu(hFileMenu, MF_STRING, IDM_SAVE, L"&Сохранить\tCtrl+S");
    AppendMenu(hFileMenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hFileMenu, MF_STRING, IDM_EXIT, L"&Выход\tAlt+F4");
    AppendMenu(hMenu, MF_POPUP, (UINT_PTR)hFileMenu, L"&Файл");

    // Справка
    HMENU hHelpMenu = CreateMenu();
    AppendMenu(hHelpMenu, MF_STRING, IDM_ABOUT, L"&О программе");
    AppendMenu(hMenu, MF_POPUP, (UINT_PTR)hHelpMenu, L"&Справка");

    SetMenu(hWnd, hMenu);
}

void CreateToolBar(HWND hWnd)
{
    // Создание панели инструментов
    HWND hToolbar = CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
        WS_CHILD | TBSTYLE_WRAPABLE, 0, 0, 0, 0,
        hWnd, (HMENU)IDR_TOOLBAR1, hInst, NULL);

    if (!hToolbar)
        return;

    // Инициализация панели инструментов
    SendMessage(hToolbar, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0);

    // Добавление кнопок (пример, нужно добавить ресурсы)
    TBBUTTON tbButtons[2] = {0};

    tbButtons[0].iBitmap = 0;
    tbButtons[0].idCommand = IDM_NEW;
    tbButtons[0].fsState = TBSTATE_ENABLED;
    tbButtons[0].fsStyle = BTNS_BUTTON;
    tbButtons[0].dwData = 0;
    tbButtons[0].iString = 0;

    tbButtons[1].iBitmap = 1;
    tbButtons[1].idCommand = IDM_OPEN;
    tbButtons[1].fsState = TBSTATE_ENABLED;
    tbButtons[1].fsStyle = BTNS_BUTTON;
    tbButtons[1].dwData = 0;
    tbButtons[1].iString = 0;

    SendMessage(hToolbar, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0);
    SendMessage(hToolbar, TB_ADDBUTTONS, (WPARAM)2, (LPARAM)&tbButtons);

    SendMessage(hToolbar, TB_AUTOSIZE, 0, 0);
}

void CreateEditControl(HWND hWnd)
{
    hEdit = CreateWindowEx(0, MSFTEDIT_CLASS, NULL,
        WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_HSCROLL |
        ES_MULTILINE | ES_AUTOVSCROLL | ES_AUTOHSCROLL,
        0, 30, 800, 600,
        hWnd, (HMENU)IDC_EDIT, hInst, NULL);

    if (!hEdit)
    {
        MessageBox(hWnd, L"Не удалось создать поле редактирования.", szTitle, MB_OK | MB_ICONERROR);
    }
    else
    {
        // Настройка шрифта
        CHARFORMAT2 cf;
        ZeroMemory(&cf, sizeof(CHARFORMAT2));
        cf.cbSize = sizeof(cf);
        cf.dwMask = CFM_FACE | CFM_SIZE | CFM_WEIGHT;
        cf.yHeight = 200; // 10pt
        cf.dwEffects = CFE_PROPORTIONAL | CFE_AUTOCOLOR;
        wcscpy_s(cf.szFaceName, L"Consolas");
        cf.wWeight = FW_NORMAL;

        SendMessage(hEdit, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
    }
}

void OpenFile(HWND hWnd)
{
    OPENFILENAME ofn;       // common dialog box structure
    wchar_t szFile[MAX_PATH] = {0};       // buffer for file name

    // Initialize OPENFILENAME
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWnd;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile)/sizeof(wchar_t);
    ofn.lpstrFilter = L"Python Files (*.py)\0*.py\0All Files (*.*)\0*.*\0";
    ofn.nFilterIndex = 1;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

    // Display the Open dialog box
    if (GetOpenFileName(&ofn)==TRUE)
    {
        // Открыть файл и загрузить в редактор
        HANDLE hFile = CreateFile(ofn.lpstrFile, GENERIC_READ, 0, NULL,
                                  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            DWORD dwSize = GetFileSize(hFile, NULL);
            if (dwSize != INVALID_FILE_SIZE)
            {
                char* buffer = new char[dwSize + 1];
                DWORD dwRead;
                if (ReadFile(hFile, buffer, dwSize, &dwRead, NULL))
                {
                    buffer[dwRead] = '\0';

                    // Преобразование из ANSI в Unicode
                    int len = MultiByteToWideChar(CP_UTF8, 0, buffer, -1, NULL, 0);
                    wchar_t* wBuffer = new wchar_t[len];
                    MultiByteToWideChar(CP_UTF8, 0, buffer, -1, wBuffer, len);

                    SetWindowText(hEdit, wBuffer);

                    delete[] wBuffer;
                }
                delete[] buffer;
            }
            CloseHandle(hFile);
        }
        else
        {
            MessageBox(hWnd, L"Не удалось открыть файл.", szTitle, MB_OK | MB_ICONERROR);
        }
    }
}

void SaveFile(HWND hWnd)
{
    OPENFILENAME ofn;       // common dialog box structure
    wchar_t szFile[MAX_PATH] = {0};       // buffer for file name

    // Initialize OPENFILENAME
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWnd;
    ofn.lpstrFile = szFile;
    ofn.lpstrFile[0] = '\0';
    ofn.nMaxFile = sizeof(szFile)/sizeof(wchar_t);
    ofn.lpstrFilter = L"Python Files (*.py)\0*.py\0All Files (*.*)\0*.*\0";
    ofn.nFilterIndex = 1;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

    // Display the Save dialog box
    if (GetSaveFileName(&ofn)==TRUE)
    {
        // Получить текст из редактора
        int len = GetWindowTextLength(hEdit);
        wchar_t* wBuffer = new wchar_t[len + 1];
        GetWindowText(hEdit, wBuffer, len + 1);

        // Преобразование из Unicode в ANSI
        int bufferSize = WideCharToMultiByte(CP_UTF8, 0, wBuffer, -1, NULL, 0, NULL, NULL);
        char* buffer = new char[bufferSize];
        WideCharToMultiByte(CP_UTF8, 0, wBuffer, -1, buffer, bufferSize, NULL, NULL);

        // Записать в файл
        HANDLE hFile = CreateFile(ofn.lpstrFile, GENERIC_WRITE, 0, NULL,
                                  CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            DWORD dwWritten;
            WriteFile(hFile, buffer, bufferSize - 1, &dwWritten, NULL);
            CloseHandle(hFile);
        }
        else
        {
            MessageBox(hWnd, L"Не удалось сохранить файл.", szTitle, MB_OK | MB_ICONERROR);
        }

        delete[] buffer;
        delete[] wBuffer;
    }
}

void AboutDialog(HWND hWnd)
{
    MessageBox(hWnd, L"Simple IDE v1.0\nСоздано с использованием Win32 API.", L"О программе", MB_OK | MB_ICONINFORMATION);
}
