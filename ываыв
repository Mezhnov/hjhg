#include <windows.h>
#include <gdiplus.h>
#include <urlmon.h>
#include <shlwapi.h> // For path manipulation functions
#include <string>
#include <ctime>
#include <vector>
#include <windowsx.h>
#include <cstdlib> // For rand()

#pragma comment (lib,"Gdiplus.lib")
#pragma comment (lib,"Urlmon.lib")
#pragma comment (lib,"Shlwapi.lib")

#include <sstream>
#include <map>

// Глобальные переменные
HINSTANCE hInst;
HWND hMarkyEdit;
HWND hStylinEdit;
HWND hRunButton;
HWND hMainWnd;

struct UIElement {
    std::string type;
    std::string id;
    std::string text;
    POINT position;
    SIZE size;
};

struct Style {
    int fontSize;
    COLORREF textColor;
    COLORREF backgroundColor;
};

// Словари для хранения элементов и стилей
std::vector<UIElement> uiElements;
std::map<std::string, Style> styles;

// Функции для парсинга
void ParseMarky(const std::string& markyCode);
void ParseStylin(const std::string& stylinCode);

// Функции для создания интерфейса
void CreateUI(HWND parent);

// Вспомогательные функции
COLORREF ParseColor(const std::string& colorStr);

// Прототипы оконных процедур
LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK UIWndProc(HWND, UINT, WPARAM, LPARAM);

// Главная функция
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow) {
    hInst = hInstance;

    // Регистрация класса окна
    WNDCLASS wc = {};
    wc.lpfnWndProc = MainWndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = TEXT("MarkyStylinIDE");

    RegisterClass(&wc);

    // Создание главного окна
    hMainWnd = CreateWindowEx(
        0,
        wc.lpszClassName,
        TEXT("Marky & Stylin IDE"),
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 800, 600,
        nullptr,
        nullptr,
        hInstance,
        nullptr
    );

    ShowWindow(hMainWnd, nCmdShow);

    // Цикл сообщений
    MSG msg = {};
    while (GetMessage(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return 0;
}

// Создание элементов управления в главном окне
void CreateControls(HWND hwnd) {
    CreateWindow(TEXT("STATIC"), TEXT("Marky Code:"),
        WS_VISIBLE | WS_CHILD,
        10, 10, 100, 20,
        hwnd, nullptr, hInst, nullptr);

    hMarkyEdit = CreateWindowEx(WS_EX_CLIENTEDGE, TEXT("EDIT"), TEXT(""),
        WS_VISIBLE | WS_CHILD | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
        10, 30, 360, 500,
        hwnd, nullptr, hInst, nullptr);

    CreateWindow(TEXT("STATIC"), TEXT("Stylin Code:"),
        WS_VISIBLE | WS_CHILD,
        380, 10, 100, 20,
        hwnd, nullptr, hInst, nullptr);

    hStylinEdit = CreateWindowEx(WS_EX_CLIENTEDGE, TEXT("EDIT"), TEXT(""),
        WS_VISIBLE | WS_CHILD | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
        380, 30, 360, 500,
        hwnd, nullptr, hInst, nullptr);

    hRunButton = CreateWindow(TEXT("BUTTON"), TEXT("Запустить"),
        WS_VISIBLE | WS_CHILD,
        10, 540, 100, 30,
        hwnd, (HMENU)1, hInst, nullptr);
}

// Оконная процедура главного окна
LRESULT CALLBACK MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg)
    {
    case WM_CREATE:
        CreateControls(hwnd);
        break;
    case WM_COMMAND:
        if (LOWORD(wParam) == 1) // Нажата кнопка "Запустить"
        {
            // Получаем код из контролов
            TCHAR markyBuffer[10000];
            GetWindowText(hMarkyEdit, markyBuffer, 10000);
            std::wstring wMarkyCode = markyBuffer;
            std::string markyCode(wMarkyCode.begin(), wMarkyCode.end());

            TCHAR stylinBuffer[10000];
            GetWindowText(hStylinEdit, stylinBuffer, 10000);
            std::wstring wStylinCode = stylinBuffer;
            std::string stylinCode(wStylinCode.begin(), wStylinCode.end());

            // Парсим код
            ParseMarky(markyCode);
            ParseStylin(stylinCode);

            // Создаем новое окно для отображения интерфейса
            WNDCLASS wc = {};
            wc.lpfnWndProc = UIWndProc;
            wc.hInstance = hInst;
            wc.lpszClassName = TEXT("UIWindowClass");

            RegisterClass(&wc);

            HWND hUIWindow = CreateWindowEx(
                0,
                wc.lpszClassName,
                TEXT("Результат"),
                WS_OVERLAPPEDWINDOW,
                CW_USEDEFAULT, CW_USEDEFAULT, 500, 400,
                nullptr,
                nullptr,
                hInst,
                nullptr
            );

            ShowWindow(hUIWindow, SW_SHOW);
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// Оконная процедура окна интерфейса
LRESULT CALLBACK UIWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg)
    {
    case WM_CREATE:
        CreateUI(hwnd);
        break;
    case WM_DESTROY:
        // Очищаем элементы и стили после закрытия окна
        uiElements.clear();
        styles.clear();
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// Функция парсинга Marky
void ParseMarky(const std::string& markyCode) {
    uiElements.clear();

    std::istringstream iss(markyCode);
    std::string line;
    UIElement currentWindow;
    bool inElements = false;

    while (std::getline(iss, line)) {
        // Убираем начальные и конечные пробелы
        line.erase(0, line.find_first_not_of(" \t"));
        line.erase(line.find_last_not_of(" \t") + 1);

        if (line.empty() || line[0] == '#')
            continue; // Пропускаем пустые строки и комментарии

        if (line.find("window:") == 0) {
            // Начало описания окна
            inElements = false;
        }
        else if (line.find("title:") == 0) {
            currentWindow.text = line.substr(6);
            currentWindow.text.erase(0, currentWindow.text.find_first_not_of(" \""));
            currentWindow.text.erase(currentWindow.text.find_last_not_of(" \"") + 1);
        }
        else if (line.find("size:") == 0) {
            std::string sizeStr = line.substr(5);
            sizeStr.erase(0, sizeStr.find_first_not_of(" \t"));
            int xPos = sizeStr.find('x');
            if (xPos != std::string::npos) {
                currentWindow.size.cx = std::atoi(sizeStr.substr(0, xPos).c_str());
                currentWindow.size.cy = std::atoi(sizeStr.substr(xPos + 1).c_str());
            }
        }
        else if (line.find("elements:") == 0) {
            inElements = true;
        }
        else if (inElements && line[0] == '-') {
            // Начало описания элемента
            UIElement element;
            size_t pos = line.find(':');
            if (pos != std::string::npos) {
                element.type = line.substr(1, pos - 1);
                element.type.erase(0, element.type.find_first_not_of(" \t"));
                element.type.erase(element.type.find_last_not_of(" \t") + 1);
            }
            // Читаем свойства элемента
            while (std::getline(iss, line)) {
                line.erase(0, line.find_first_not_of(" \t"));
                line.erase(line.find_last_not_of(" \t") + 1);

                if (line.empty())
                    break;

                if (line.find("id:") == 0) {
                    element.id = line.substr(3);
                    element.id.erase(0, element.id.find_first_not_of(" \""));
                    element.id.erase(element.id.find_last_not_of(" \"") + 1);
                }
                else if (line.find("text:") == 0) {
                    element.text = line.substr(5);
                    element.text.erase(0, element.text.find_first_not_of(" \""));
                    element.text.erase(element.text.find_last_not_of(" \"") + 1);
                }
                else if (line.find("position:") == 0) {
                    std::string posStr = line.substr(9);
                    posStr.erase(0, posStr.find_first_not_of(" \t"));
                    int xPos = posStr.find('x');
                    if (xPos != std::string::npos) {
                        element.position.x = std::atoi(posStr.substr(0, xPos).c_str());
                        element.position.y = std::atoi(posStr.substr(xPos + 1).c_str());
                    }
                }
                else {
                    break;
                }
            }
            uiElements.push_back(element);
        }
    }

    // Устанавливаем параметры окна на основе парсинга
    if (!currentWindow.text.empty()) {
        // Здесь можно сохранить параметры окна, если потребуется
    }
}

// Функция парсинга Stylin
void ParseStylin(const std::string& stylinCode) {
    styles.clear();

    std::istringstream iss(stylinCode);
    std::string line;
    std::string currentSelector;

    while (std::getline(iss, line)) {
        // Убираем начальные и конечные пробелы
        line.erase(0, line.find_first_not_of(" \t"));
        line.erase(line.find_last_not_of(" \t") + 1);

        if (line.empty() || line[0] == '#')
            continue; // Пропускаем пустые строки и комментарии

        if (line.back() == ':') {
            currentSelector = line.substr(0, line.length() - 1);
        }
        else {
            size_t colonPos = line.find(':');
            if (colonPos != std::string::npos) {
                std::string property = line.substr(0, colonPos);
                std::string value = line.substr(colonPos + 1);

                property.erase(0, property.find_first_not_of(" \t"));
                property.erase(property.find_last_not_of(" \t") + 1);
                value.erase(0, value.find_first_not_of(" \t"));
                value.erase(value.find_last_not_of(" \t") + 1);

                Style& style = styles[currentSelector];

                if (property == "font-size") {
                    style.fontSize = std::atoi(value.c_str());
                }
                else if (property == "color" || property == "text-color") {
                    style.textColor = ParseColor(value);
                }
                else if (property == "background-color") {
                    style.backgroundColor = ParseColor(value);
                }
            }
        }
    }
}

// Функция создания интерфейса на основе парсинга
void CreateUI(HWND parent) {
    for (const auto& element : uiElements) {
        HWND hControl = nullptr;
        if (element.type == "label") {
            hControl = CreateWindow(TEXT("STATIC"), std::wstring(element.text.begin(), element.text.end()).c_str(),
                WS_VISIBLE | WS_CHILD,
                element.position.x, element.position.y, 200, 30,
                parent, nullptr, hInst, nullptr);

            // Применяем стили
            auto it = styles.find("label");
            if (it != styles.end()) {
                Style style = it->second;

                if (style.fontSize > 0) {
                    // Изменяем размер шрифта
                    HFONT hFont = CreateFont(style.fontSize, 0, 0, 0, FW_NORMAL,
                        FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_OUTLINE_PRECIS,
                        CLIP_DEFAULT_PRECIS, CLEARTYPE_QUALITY, VARIABLE_PITCH, TEXT("Arial"));
                    SendMessage(hControl, WM_SETFONT, (WPARAM)hFont, TRUE);
                }

                if (style.textColor != 0) {
                    // Устанавливаем цвет текста
                    SetTextColor(GetDC(hControl), style.textColor);
                }
            }
        }
        else if (element.type == "button") {
            hControl = CreateWindow(TEXT("BUTTON"), std::wstring(element.text.begin(), element.text.end()).c_str(),
                WS_VISIBLE | WS_CHILD,
                element.position.x, element.position.y, 100, 30,
                parent, nullptr, hInst, nullptr);

            // Применяем стили
            auto it = styles.find("button");
            if (it != styles.end()) {
                Style style = it->second;

                if (style.backgroundColor != 0) {
                    // Устанавливаем цвет фона кнопки
                    HBRUSH hBrush = CreateSolidBrush(style.backgroundColor);
                    SetClassLongPtr(hControl, GCLP_HBRBACKGROUND, (LONG_PTR)hBrush);
                }

                if (style.textColor != 0) {
                    // Устанавливаем цвет текста
                    SetTextColor(GetDC(hControl), style.textColor);
                }
            }
        }
    }
}

// Функция парсинга цвета из строки
COLORREF ParseColor(const std::string& colorStr) {
    if (colorStr.find("RGB(") == 0 && colorStr.back() == ')') {
        std::string values = colorStr.substr(4, colorStr.length() - 5);
        int r = 0, g = 0, b = 0;
        sscanf_s(values.c_str(), "%d, %d, %d", &r, &g, &b);
        return RGB(r, g, b);
    }
    return 0;
}
