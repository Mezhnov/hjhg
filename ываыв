// Включаем необходимые заголовочные файлы
#include <windows.h>
#include <gdiplus.h>
#include <urlmon.h>
#include <shlwapi.h> // For path manipulation functions
#include <string>
#include <ctime>
#include <vector>
#include <windowsx.h>
#include <cstdlib> // For rand()
#include <sstream>
#include <map>
#include <codecvt>
#include <locale>

#pragma comment (lib,"Gdiplus.lib")
#pragma comment (lib,"Urlmon.lib")
#pragma comment (lib,"Shlwapi.lib")

// Глобальные переменные
HINSTANCE hInst;
HWND hMarkyEdit;
HWND hStylinEdit;
HWND hRunButton;
HWND hMainWnd;

struct UIElement {
    std::string type;
    std::string id;
    std::string text;
    std::string src; // Для изображений
    std::string action; // Для событий
    POINT position{ 0, 0 };
    SIZE size{ 0, 0 };
};

struct Style {
    int fontSize = 0;
    COLORREF textColor = RGB(0, 0, 0);
    COLORREF backgroundColor = RGB(255, 255, 255);
    std::string fontFamily = "Arial";
};

struct EventHandler {
    std::string id;
    std::string action;
};

// Словари для хранения элементов и стилей
std::vector<UIElement> uiElements;
std::map<std::string, Style> styles;
std::map<std::string, EventHandler> eventHandlers;

// Функции для парсинга
void ParseMarky(const std::string& markyCode);
void ParseStylin(const std::string& stylinCode);

// Функции для создания интерфейса
void CreateUI(HWND parent);

// Вспомогательные функции
COLORREF ParseColor(const std::string& colorStr);
void ApplyStyle(HWND hControl, const Style& style);
Gdiplus::Bitmap* LoadImageFromURL(const std::wstring& url);
LRESULT CALLBACK ButtonProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

// Прототипы оконных процедур
LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK UIWndProc(HWND, UINT, WPARAM, LPARAM);

// Глобальные переменные для GDI+
ULONG_PTR gdiplusToken;

// Карта для сопоставления HWND кнопки с ее действием
std::map<HWND, std::string> buttonActions;

// Главная функция
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow) {
    hInst = hInstance;

    // Инициализация GDI+
    Gdiplus::GdiplusStartupInput gdiplusStartupInput;
    if (Gdiplus::Ok != Gdiplus::GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, nullptr)) {
        MessageBox(nullptr, L"Не удалось инициализировать GDI+", L"Ошибка", MB_OK);
        return 1;
    }

    // Регистрация класса окна
    WNDCLASS wc = {};
    wc.lpfnWndProc = MainWndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = TEXT("MarkyStylinIDE");

    RegisterClass(&wc);

    // Создание главного окна
    hMainWnd = CreateWindowEx(
        0,
        wc.lpszClassName,
        TEXT("Marky & Stylin IDE"),
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 800, 600,
        nullptr,
        nullptr,
        hInstance,
        nullptr
    );

    ShowWindow(hMainWnd, nCmdShow);

    // Цикл сообщений
    MSG msg = {};
    while (GetMessage(&msg, nullptr, 0, 0)) {
        if (!IsDialogMessage(hMainWnd, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    // Завершение работы GDI+
    Gdiplus::GdiplusShutdown(gdiplusToken);

    return 0;
}

// Создание элементов управления в главном окне
void CreateControls(HWND hwnd) {
    CreateWindow(TEXT("STATIC"), TEXT("Marky Code:"),
        WS_VISIBLE | WS_CHILD,
        10, 10, 100, 20,
        hwnd, nullptr, hInst, nullptr);

    hMarkyEdit = CreateWindowEx(WS_EX_CLIENTEDGE, TEXT("EDIT"), TEXT(""),
        WS_VISIBLE | WS_CHILD | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
        10, 30, 360, 500,
        hwnd, (HMENU)101, hInst, nullptr);

    CreateWindow(TEXT("STATIC"), TEXT("Stylin Code:"),
        WS_VISIBLE | WS_CHILD,
        380, 10, 100, 20,
        hwnd, nullptr, hInst, nullptr);

    hStylinEdit = CreateWindowEx(WS_EX_CLIENTEDGE, TEXT("EDIT"), TEXT(""),
        WS_VISIBLE | WS_CHILD | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
        380, 30, 360, 500,
        hwnd, (HMENU)102, hInst, nullptr);

    hRunButton = CreateWindow(TEXT("BUTTON"), TEXT("Запустить"),
        WS_VISIBLE | WS_CHILD,
        10, 540, 100, 30,
        hwnd, (HMENU)1, hInst, nullptr);
}

// Оконная процедура главного окна
LRESULT CALLBACK MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg)
    {
    case WM_CREATE:
        CreateControls(hwnd);
        break;
    case WM_COMMAND:
        if (LOWORD(wParam) == 1) // Нажата кнопка "Запустить"
        {
            // Получаем код из контролов
            TCHAR markyBuffer[10000];
            GetWindowText(hMarkyEdit, markyBuffer, 10000);
            std::wstring wMarkyCode = markyBuffer;
            std::string markyCode(wMarkyCode.begin(), wMarkyCode.end());

            TCHAR stylinBuffer[10000];
            GetWindowText(hStylinEdit, stylinBuffer, 10000);
            std::wstring wStylinCode = stylinBuffer;
            std::string stylinCode(wStylinCode.begin(), wStylinCode.end());

            // Парсим код
            ParseMarky(markyCode);
            ParseStylin(stylinCode);

            // Создаем новое окно для отображения интерфейса
            WNDCLASS wc = {};
            wc.lpfnWndProc = UIWndProc;
            wc.hInstance = hInst;
            wc.lpszClassName = TEXT("UIWindowClass");

            RegisterClass(&wc);

            HWND hUIWindow = CreateWindowEx(
                0,
                wc.lpszClassName,
                L"Результат",
                WS_OVERLAPPEDWINDOW,
                CW_USEDEFAULT, CW_USEDEFAULT, 600, 500,
                hwnd,
                nullptr,
                hInst,
                nullptr
            );

            ShowWindow(hUIWindow, SW_SHOW);
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// Оконная процедура окна интерфейса
LRESULT CALLBACK UIWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg)
    {
    case WM_CREATE:
        CreateUI(hwnd);
        break;
    case WM_COMMAND:
    {
        HWND hControl = (HWND)lParam;
        if (buttonActions.find(hControl) != buttonActions.end()) {
            std::string action = buttonActions[hControl];
            if (action == "close") {
                DestroyWindow(hwnd);
            }
            else if (action == "message") {
                MessageBox(hwnd, L"Кнопка нажата!", L"Информация", MB_OK);
            }
            // Добавьте дополнительные действия здесь
        }
    }
    break;
    case WM_DESTROY:
        // Очищаем элементы и стили после закрытия окна
        uiElements.clear();
        styles.clear();
        eventHandlers.clear();
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// Функция парсинга Marky
void ParseMarky(const std::string& markyCode) {
    uiElements.clear();

    std::istringstream iss(markyCode);
    std::string line;
    UIElement currentWindow;
    bool inElements = false;
    UIElement element;

    while (std::getline(iss, line)) {
        // Убираем начальные и конечные пробелы
        line.erase(0, line.find_first_not_of(" \t"));
        line.erase(line.find_last_not_of(" \t\r\n") + 1);

        if (line.empty() || line[0] == '#')
            continue; // Пропускаем пустые строки и комментарии

        if (line.find("window:") == 0) {
            // Начало описания окна
            inElements = false;
        }
        else if (line.find("title:") == 0) {
            currentWindow.text = line.substr(6);
            currentWindow.text.erase(0, currentWindow.text.find_first_not_of(" \""));
            currentWindow.text.erase(currentWindow.text.find_last_not_of(" \"") + 1);
        }
        else if (line.find("size:") == 0) {
            std::string sizeStr = line.substr(5);
            sizeStr.erase(0, sizeStr.find_first_not_of(" \t"));
            int xPos = sizeStr.find('x');
            if (xPos != std::string::npos) {
                currentWindow.size.cx = std::atoi(sizeStr.substr(0, xPos).c_str());
                currentWindow.size.cy = std::atoi(sizeStr.substr(xPos + 1).c_str());
            }
        }
        else if (line.find("elements:") == 0) {
            inElements = true;
        }
        else if (inElements && line[0] == '-') {
            // Начало описания элемента
            element = UIElement();
            size_t pos = line.find(':');
            if (pos != std::string::npos) {
                element.type = line.substr(1, pos - 1);
                element.type.erase(0, element.type.find_first_not_of(" \t"));
                element.type.erase(element.type.find_last_not_of(" \t") + 1);
            }
        }
        else if (inElements) {
            size_t colonPos = line.find(':');
            if (colonPos != std::string::npos) {
                std::string key = line.substr(0, colonPos);
                std::string value = line.substr(colonPos + 1);
                key.erase(0, key.find_first_not_of(" \t"));
                key.erase(key.find_last_not_of(" \t") + 1);
                value.erase(0, value.find_first_not_of(" \t\""));
                value.erase(value.find_last_not_of(" \t\"") + 1);

                if (key == "id") {
                    element.id = value;
                }
                else if (key == "text") {
                    element.text = value;
                }
                else if (key == "src") {
                    element.src = value;
                }
                else if (key == "position") {
                    int xPos = value.find('x');
                    if (xPos != std::string::npos) {
                        element.position.x = std::stoi(value.substr(0, xPos));
                        element.position.y = std::stoi(value.substr(xPos + 1));
                    }
                }
                else if (key == "size") {
                    int xPos = value.find('x');
                    if (xPos != std::string::npos) {
                        element.size.cx = std::stoi(value.substr(0, xPos));
                        element.size.cy = std::stoi(value.substr(xPos + 1));
                    }
                }
                else if (key == "action") {
                    element.action = value;
                    // Сохраняем обработчик события
                    eventHandlers[element.id] = { element.id, element.action };
                }
            }
            else if (line.empty()) {
                // Конец описания элемента
                uiElements.push_back(element);
            }
        }
    }

    // Добавляем последний элемент, если не был добавлен
    if (!element.type.empty()) {
        uiElements.push_back(element);
    }

    // Устанавливаем параметры окна на основе парсинга
    if (!currentWindow.text.empty()) {
        // Здесь можно сохранить параметры окна, если потребуется
    }
}

// Функция парсинга Stylin
void ParseStylin(const std::string& stylinCode) {
    styles.clear();

    std::istringstream iss(stylinCode);
    std::string line;
    std::string currentSelector;

    while (std::getline(iss, line)) {
        // Убираем начальные и конечные пробелы
        line.erase(0, line.find_first_not_of(" \t"));
        line.erase(line.find_last_not_of(" \t\r\n") + 1);

        if (line.empty() || line[0] == '#')
            continue; // Пропускаем пустые строки и комментарии

        if (line.back() == ':') {
            currentSelector = line.substr(0, line.length() - 1);
            currentSelector.erase(0, currentSelector.find_first_not_of(" \t"));
            currentSelector.erase(currentSelector.find_last_not_of(" \t") + 1);
        }
        else {
            size_t colonPos = line.find(':');
            if (colonPos != std::string::npos) {
                std::string property = line.substr(0, colonPos);
                std::string value = line.substr(colonPos + 1);

                property.erase(0, property.find_first_not_of(" \t"));
                property.erase(property.find_last_not_of(" \t") + 1);
                value.erase(0, value.find_first_not_of(" \t"));
                value.erase(value.find_last_not_of(" \t") + 1);

                Style& style = styles[currentSelector];

                if (property == "font-size") {
                    style.fontSize = std::stoi(value);
                }
                else if (property == "color" || property == "text-color") {
                    style.textColor = ParseColor(value);
                }
                else if (property == "background-color") {
                    style.backgroundColor = ParseColor(value);
                }
                else if (property == "font-family") {
                    style.fontFamily = value;
                }
            }
        }
    }
}

// Функция создания интерфейса на основе парсинга
void CreateUI(HWND parent) {
    for (const auto& element : uiElements) {
        HWND hControl = nullptr;
        if (element.type == "label") {
            hControl = CreateWindow(TEXT("STATIC"), std::wstring(element.text.begin(), element.text.end()).c_str(),
                WS_VISIBLE | WS_CHILD,
                element.position.x, element.position.y, element.size.cx, element.size.cy,
                parent, nullptr, hInst, nullptr);

            // Применяем стили
            auto it = styles.find("label");
            if (it != styles.end()) {
                ApplyStyle(hControl, it->second);
            }
        }
        else if (element.type == "button") {
            hControl = CreateWindow(TEXT("BUTTON"), std::wstring(element.text.begin(), element.text.end()).c_str(),
                WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
                element.position.x, element.position.y, element.size.cx, element.size.cy,
                parent, nullptr, hInst, nullptr);

            // Применяем стили
            auto it = styles.find("button");
            if (it != styles.end()) {
                ApplyStyle(hControl, it->second);
            }

            // Обрабатываем события
            if (!element.action.empty()) {
                buttonActions[hControl] = element.action;
                SetWindowLongPtr(hControl, GWLP_ID, (LONG_PTR)hControl);
                SetWindowLongPtr(hControl, GWLP_USERDATA, (LONG_PTR)parent);
            }
        }
        else if (element.type == "image") {
            // Загружаем изображение
            Gdiplus::Bitmap* image = LoadImageFromURL(std::wstring(element.src.begin(), element.src.end()));
            if (image) {
                HWND hImageControl = CreateWindow(TEXT("STATIC"), nullptr,
                    WS_VISIBLE | WS_CHILD | SS_BITMAP,
                    element.position.x, element.position.y, element.size.cx, element.size.cy,
                    parent, nullptr, hInst, nullptr);

                // Устанавливаем изображение в контрол
                HBITMAP hBitmap;
                image->GetHBITMAP(NULL, &hBitmap);
                SendMessage(hImageControl, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
                delete image;
            }
        }

        // Применяем стили с использованием идентификатора
        if (!element.id.empty()) {
            auto it = styles.find("#" + element.id);
            if (it != styles.end()) {
                ApplyStyle(hControl, it->second);
            }
        }
    }
}

// Функция парсинга цвета из строки
COLORREF ParseColor(const std::string& colorStr) {
    if (colorStr.find("RGB(") == 0 && colorStr.back() == ')') {
        std::string values = colorStr.substr(4, colorStr.length() - 5);
        int r = 0, g = 0, b = 0;
        std::replace(values.begin(), values.end(), ',', ' ');
        std::istringstream iss(values);
        iss >> r >> g >> b;
        return RGB(r, g, b);
    }
    return RGB(0, 0, 0);
}

// Применение стилей к контролу
void ApplyStyle(HWND hControl, const Style& style) {
    if (style.fontSize > 0 || !style.fontFamily.empty()) {
        // Изменяем шрифт
        HFONT hFont = CreateFont(
            -MulDiv(style.fontSize, GetDeviceCaps(GetDC(hControl), LOGPIXELSY), 72),
            0, 0, 0, FW_NORMAL,
            FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_OUTLINE_PRECIS,
            CLIP_DEFAULT_PRECIS, CLEARTYPE_QUALITY, VARIABLE_PITCH, std::wstring(style.fontFamily.begin(), style.fontFamily.end()).c_str());
        SendMessage(hControl, WM_SETFONT, (WPARAM)hFont, TRUE);
    }

    // Устанавливаем цвета
    if (style.backgroundColor != RGB(255, 255, 255)) {
        HBRUSH hBrush = CreateSolidBrush(style.backgroundColor);
        SetClassLongPtr(hControl, GCLP_HBRBACKGROUND, (LONG_PTR)hBrush);
        InvalidateRect(hControl, NULL, TRUE);
    }

    // Сохраняем цвет текста в пользовательских данных
    SetWindowLongPtr(hControl, GWLP_USERDATA, (LONG_PTR)style.textColor);

    // Перехватываем сообщение WM_CTLCOLORSTATIC
    SetWindowLongPtr(hControl, GWLP_WNDPROC, (LONG_PTR)[] (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) -> LRESULT {
        if (msg == WM_CTLCOLORSTATIC || msg == WM_CTLCOLORBTN) {
            HDC hdc = (HDC)wParam;
            COLORREF textColor = (COLORREF)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            SetTextColor(hdc, textColor);
            SetBkMode(hdc, TRANSPARENT);
            return (LRESULT)GetStockObject(NULL_BRUSH);
        }
        return DefWindowProc(hwnd, msg, wParam, lParam);
    });
}

// Функция загрузки изображения по URL
Gdiplus::Bitmap* LoadImageFromURL(const std::wstring& url) {
    IStream* pStream = NULL;
    HRESULT hr = URLOpenBlockingStream(NULL, url.c_str(), &pStream, 0, NULL);
    if (SUCCEEDED(hr) && pStream) {
        Gdiplus::Bitmap* bitmap = new Gdiplus::Bitmap(pStream);
        pStream->Release();
        if (bitmap->GetLastStatus() == Gdiplus::Ok) {
            return bitmap;
        }
        delete bitmap;
    }
    return nullptr;
}
Сборка начата в 11:25...
1>------ Сборка начата: проект: тторор, Конфигурация: Debug x64 ------
1>тторор.cpp
1>C:\Users\User\source\repos\тторор\тторор\тторор.cpp(275,22): warning C4267: инициализация: преобразование из "size_t" в "int"; возможна потеря данных
1>C:\Users\User\source\repos\тторор\тторор\тторор.cpp(314,30): warning C4267: инициализация: преобразование из "size_t" в "int"; возможна потеря данных
1>C:\Users\User\source\repos\тторор\тторор\тторор.cpp(321,30): warning C4267: инициализация: преобразование из "size_t" в "int"; возможна потеря данных
1>C:\Users\User\source\repos\тторор\тторор\тторор.cpp(469,14): error C2039: "replace": не является членом "std".
1>    C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\codecvt(20,1):
1>     см. объявление "std"
1>C:\Users\User\source\repos\тторор\тторор\тторор.cpp(469,14): error C3861: replace: идентификатор не найден
1>C:\Users\User\source\repos\тторор\тторор\тторор.cpp(500,46): error C2440: приведение типов: невозможно преобразовать "ApplyStyle::<lambda_1>" в "LONG_PTR"
1>    C:\Users\User\source\repos\тторор\тторор\тторор.cpp(500,46):
1>    Для выполнения данного преобразования нет доступного оператора преобразования, определенного пользователем, или вызов оператора невозможен
1>C:\Users\User\source\repos\тторор\тторор\тторор.cpp(500,5): error C2660: SetWindowLongPtrW: функция не принимает 2 аргументов
1>    C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winuser.h(9869,1):
1>     см. объявление "SetWindowLongPtrW"
1>    C:\Users\User\source\repos\тторор\тторор\тторор.cpp(500,5):
1>    при попытке сопоставить список аргументов "(HWND, int)"
1>Сборка проекта "тторор.vcxproj" завершена с ошибкой.
========== Сборка: успешно выполнено — 0 , со сбоем — 1, в актуальном состоянии — 0, пропущено — 0 ==========
========== Сборка завершено в 11:25 и заняло 01,330 с ==========
