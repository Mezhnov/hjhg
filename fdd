// SimpleBrowser.cpp
// A simplified multi-tabbed browser using C++, Win32 API, GDI+, and WinInet

#include <windows.h>
#include <gdiplus.h>
#include <wininet.h>
#include <string>
#include <vector>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <locale>
#include <codecvt>
#include <thread>
#include <mutex>

#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "wininet.lib")

using namespace Gdiplus;

// Constants
const wchar_t CLASS_NAME[] = L"SimpleBrowserWindowClass";
const int WINDOW_WIDTH = 1280;
const int WINDOW_HEIGHT = 720;

const int NAVBAR_HEIGHT = 40;
const int TABBAR_HEIGHT = 30;
const int TAB_PADDING = 10;
const int TAB_SPACING = 5;
const int TAB_CLOSE_BUTTON_SIZE = 12;
const int ADDRESSBAR_PADDING = 5;

// Forward declarations
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Utility function to convert std::wstring to std::string
std::string WStringToString(const std::wstring& wstr) {
    std::wstring_convert<std::codecvt_utf8<wchar_t>> conv;
    return conv.to_bytes(wstr);
}

// Structure to hold tab information
struct Tab {
    std::wstring url;
    std::wstring htmlContent;
    RECT tabRect;
    bool loading;

    Tab(const std::wstring& u = L"https://www.example.com") : url(u), htmlContent(L"Loading..."), loading(true) {}
};

// Global Variables
std::vector<Tab> tabs;
int currentTab = 0;
std::mutex tabsMutex;

// GDI+ Token
ULONG_PTR gdiplusToken;

// Function to initialize GDI+
bool InitGDIPlus() {
    GdiplusStartupInput input;
    return GdiplusStartup(&gdiplusToken, &input, NULL) == Ok;
}

// Function to shutdown GDI+
void ShutdownGDIPlus() {
    GdiplusShutdown(gdiplusToken);
}

// Function to fetch HTML content using WinInet
bool FetchHTML(const std::wstring& url, std::wstring& htmlContent) {
    HINTERNET hInternet = InternetOpen(L"SimpleBrowser", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    if (!hInternet) {
        return false;
    }

    HINTERNET hConnect = InternetOpenUrl(hInternet, url.c_str(), NULL, 0, INTERNET_FLAG_RELOAD, 0);
    if (!hConnect) {
        InternetCloseHandle(hInternet);
        return false;
    }

    DWORD bytesRead = 0;
    wchar_t buffer[4096];
    htmlContent.clear();

    while (InternetReadFile(hConnect, buffer, sizeof(buffer) - sizeof(wchar_t), &bytesRead) && bytesRead > 0) {
        buffer[bytesRead / sizeof(wchar_t)] = L'\0';
        htmlContent += buffer;
    }

    InternetCloseHandle(hConnect);
    InternetCloseHandle(hInternet);
    return !htmlContent.empty();
}

// Function to add a new tab
void AddNewTab(const std::wstring& url = L"https://www.example.com") {
    std::lock_guard<std::mutex> lock(tabsMutex);
    tabs.emplace_back(url);
    currentTab = tabs.size() - 1;

    // Fetch HTML content in a separate thread to avoid blocking UI
    std::thread([=]() {
        std::wstring content;
        bool success = FetchHTML(url, content);

        {
            std::lock_guard<std::mutex> lock(tabsMutex);
            if (currentTab < tabs.size()) {
                tabs[currentTab].htmlContent = success ? content : L"Failed to load content.";
                tabs[currentTab].loading = false;
            }
        }

        // Invalidate window to trigger repaint
        HWND hwnd = FindWindow(NULL, L"Simple C++ Browser");
        if (hwnd) {
            InvalidateRect(hwnd, NULL, TRUE);
        }
    }).detach();
}

// Function to close a tab
void CloseTab(int index) {
    std::lock_guard<std::mutex> lock(tabsMutex);
    if (index >= 0 && index < tabs.size()) {
        tabs.erase(tabs.begin() + index);
        if (currentTab >= tabs.size()) {
            currentTab = tabs.empty() ? 0 : tabs.size() - 1;
        }
    }

    // Invalidate window to trigger repaint
    HWND hwnd = FindWindow(NULL, L"Simple C++ Browser");
    if (hwnd) {
        InvalidateRect(hwnd, NULL, TRUE);
    }
}

// Function to fetch and update HTML content for a tab
void UpdateTabContent(int index, const std::wstring& url) {
    std::lock_guard<std::mutex> lock(tabsMutex);
    if (index >= 0 && index < tabs.size()) {
        tabs[index].url = url;
        tabs[index].htmlContent = L"Loading...";
        tabs[index].loading = true;

        // Fetch content in a separate thread
        std::thread([=]() {
            std::wstring content;
            bool success = FetchHTML(url, content);

            {
                std::lock_guard<std::mutex> lock(tabsMutex);
                if (index < tabs.size()) {
                    tabs[index].htmlContent = success ? content : L"Failed to load content.";
                    tabs[index].loading = false;
                }
            }

            // Invalidate window to trigger repaint
            HWND hwnd = FindWindow(NULL, L"Simple C++ Browser");
            if (hwnd) {
                InvalidateRect(hwnd, NULL, TRUE);
            }
        }).detach();
    }
}

// Function to get current time as string
std::wstring GetCurrentTimeString() {
    using namespace std::chrono;
    auto now = system_clock::now();
    std::time_t now_c = system_clock::to_time_t(now);
    std::tm parts;

    // Thread-safe alternative to localtime
    localtime_s(&parts, &now_c);

    std::wstringstream ss;
    ss << std::put_time(&parts, L"%H:%M");
    return ss.str();
}

// Function to draw tabs
void DrawTabs(Graphics& graphics, RECT clientRect) {
    FontFamily fontFamily(L"Segoe UI");
    Font font(&fontFamily, 12, FontStyleRegular, UnitPixel);
    SolidBrush activeBrush(Color(255, 200, 200, 200)); // Light gray for active tab
    SolidBrush inactiveBrush(Color(255, 160, 160, 160)); // Darker gray for inactive tabs
    SolidBrush textBrush(Color(255, 0, 0, 0)); // Black text
    SolidBrush closeBrush(Color(255, 255, 0, 0)); // Red close button

    RECT tabArea = { 0, 0, clientRect.right, TABBAR_HEIGHT };
    graphics.FillRectangle(&SolidBrush(Color(255, 240, 240, 240)), RectF(tabArea.left, tabArea.top, (REAL)(tabArea.right - tabArea.left), (REAL)(tabArea.bottom - tabArea.top)));

    int x = TAB_PADDING;

    for (size_t i = 0; i < tabs.size(); ++i) {
        Tab& tab = tabs[i];

        // Measure text width
        RectF layoutRect(x, 5, 200, TABBAR_HEIGHT - 10);
        StringFormat format;
        format.SetTrimming(StringTrimmingEllipsisCharacter);
        RectF measuredRect;
        FontMetrics fm;
        font.GetMetrics(&fm);
        int textHeight = fm.height;

        // Set fill color based on active tab
        SolidBrush* tabBrush = (i == currentTab) ? &activeBrush : &inactiveBrush;
        graphics.FillRectangle(tabBrush, RectF(x, 0, 150, TABBAR_HEIGHT));

        // Draw tab text
        graphics.DrawString(tab.url.c_str(), -1, &font, layoutRect, &format, &textBrush);

        // Draw close button (a simple 'X')
        Pen pen(Color(255, 0, 0, 0));
        pen.SetWidth(2);
        graphics.DrawLine(&pen, x + 135, 10, x + 145, 20);
        graphics.DrawLine(&pen, x + 145, 10, x + 135, 20);

        // Set tab rectangle for hit-testing
        tab.tabRect = { x, 0, x + 150, TABBAR_HEIGHT };

        x += 150 + TAB_SPACING;
    }

    // Draw "+" button for new tab
    SolidBrush plusBrush(Color(255, 0, 128, 0)); // Green plus
    Font plusFont(&fontFamily, 16, FontStyleBold, UnitPixel);
    StringFormat plusFormat;
    plusFormat.SetAlignment(StringAlignmentCenter);
    plusFormat.SetLineAlignment(StringAlignmentCenter);
    graphics.FillRectangle(&SolidBrush(Color(255, 220, 220, 220)), RectF(x, 0, 30, TABBAR_HEIGHT));
    graphics.DrawString(L"+", -1, &plusFont, RectF(x, 0, 30, TABBAR_HEIGHT), &plusFormat, &plusBrush);
    // Set tabRect for "+" button
    if (!tabs.empty()) {
        tabs.back().tabRect = { x, 0, x + 30, TABBAR_HEIGHT };
    }
}

// Function to draw navigation bar
void DrawNavBar(Graphics& graphics, RECT clientRect) {
    FontFamily fontFamily(L"Segoe UI");
    Font font(&fontFamily, 12, FontStyleRegular, UnitPixel);
    SolidBrush brush(Color(255, 220, 220, 220)); // Light gray background
    SolidBrush textBrush(Color(255, 0, 0, 0)); // Black text

    // Draw navbar background
    graphics.FillRectangle(&brush, RectF(0, TABBAR_HEIGHT, (REAL)clientRect.right, (REAL)NAVBAR_HEIGHT));

    // Draw address bar background
    RectF addressBarRect(ADDRESSBAR_PADDING, TABBAR_HEIGHT + 5, (REAL)(clientRect.right - 2 * ADDRESSBAR_PADDING), 30);
    SolidBrush addressBrush(Color(255, 255, 255, 255)); // White background
    Pen pen(Color(255, 0, 0, 0));
    pen.SetWidth(1);
    graphics.FillRectangle(&addressBrush, addressBarRect);
    graphics.DrawRectangle(&pen, addressBarRect.X, addressBarRect.Y, addressBarRect.Width, addressBarRect.Height);

    // Draw address text
    if (currentTab < tabs.size()) {
        std::wstring address = tabs[currentTab].url;
        graphics.DrawString(address.c_str(), -1, &font, PointF(addressBarRect.X + 5, addressBarRect.Y + 5), &textBrush);
    }
}

// Function to draw HTML content (as plain text)
void DrawHTMLContent(Graphics& graphics, RECT clientRect) {
    if (currentTab >= tabs.size()) return;

    Tab& tab = tabs[currentTab];
    std::wstring content = tab.htmlContent;

    // Define the area to draw HTML content
    RectF contentRect(10, TABBAR_HEIGHT + NAVBAR_HEIGHT + 10, (REAL)(clientRect.right - 20), (REAL)(clientRect.bottom - TABBAR_HEIGHT - NAVBAR_HEIGHT - 20));

    // Draw the raw HTML content as text
    FontFamily fontFamily(L"Consolas");
    Font font(&fontFamily, 10, FontStyleRegular, UnitPixel);
    SolidBrush textBrush(Color(255, 0, 0, 0)); // Black text

    StringFormat format;
    format.SetTrimming(StringTrimmingCharacterEllipsis);
    format.SetFormatFlags(StringFormatFlagsNoClip);

    graphics.DrawString(content.c_str(), -1, &font, contentRect, &format, &textBrush);
}

// Function to handle mouse clicks
void HandleMouseClick(HWND hwnd, int x, int y) {
    // Click within tab bar
    if (y <= TABBAR_HEIGHT) {
        std::lock_guard<std::mutex> lock(tabsMutex);
        for (size_t i = 0; i < tabs.size(); ++i) {
            Tab& tab = tabs[i];
            if (x >= tab.tabRect.left && x <= tab.tabRect.right &&
                y >= tab.tabRect.top && y <= tab.tabRect.bottom) {

                // Check if close button area
                int closeXStart = tab.tabRect.right - TAB_CLOSE_BUTTON_SIZE - 5;
                if (x >= closeXStart && x <= closeXStart + TAB_CLOSE_BUTTON_SIZE &&
                    y >= 5 && y <= 5 + TAB_CLOSE_BUTTON_SIZE) {
                    // Close the tab
                    CloseTab(i);
                    return;
                }
                else if (x >= tab.tabRect.left + 5 && x <= tab.tabRect.left + 145) {
                    // Switch to the tab
                    currentTab = i;
                    InvalidateRect(hwnd, NULL, TRUE);
                    return;
                }
            }
        }

        // Check if "+" button is clicked
        if (!tabs.empty()) {
            Tab& lastTab = tabs.back();
            if (x >= lastTab.tabRect.left && x <= lastTab.tabRect.right &&
                y >= lastTab.tabRect.top && y <= lastTab.tabRect.bottom) {
                // Clicked on "+"
                AddNewTab();
                return;
            }
        }
    }

    // Click within address bar
    if (y > TABBAR_HEIGHT && y < TABBAR_HEIGHT + NAVBAR_HEIGHT) {
        // For simplicity, we'll prompt the user to enter a new URL
        wchar_t url[2048] = L"";
        if (DialogBoxParam(NULL, MAKEINTRESOURCE(101), hwnd, (DLGPROC)[](HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) -> BOOL {
            switch (msg) {
            case WM_INITDIALOG:
                SetDlgItemText(hwndDlg, 1001, L"https://");
                return TRUE;
            case WM_COMMAND:
                if (LOWORD(wParam) == IDOK) {
                    GetDlgItemText(hwndDlg, 1001, (LPWSTR)lParam, 2048);
                    EndDialog(hwndDlg, TRUE);
                    return TRUE;
                }
                else if (LOWORD(wParam) == IDCANCEL) {
                    EndDialog(hwndDlg, FALSE);
                    return TRUE;
                }
                break;
            }
            return FALSE;
        }, (LPARAM)url)) {
            // Update the current tab with the new URL
            if (currentTab < tabs.size()) {
                UpdateTabContent(currentTab, url);
            }
        }
    }
}

// Dialog Procedure for URL input
INT_PTR CALLBACK URLInputProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
    case WM_INITDIALOG:
        SetDlgItemText(hwndDlg, 1001, L"https://");
        return TRUE;
    case WM_COMMAND:
        if (LOWORD(wParam) == IDOK) {
            GetDlgItemText(hwndDlg, 1001, (LPWSTR)lParam, 2048);
            EndDialog(hwndDlg, TRUE);
            return TRUE;
        }
        else if (LOWORD(wParam) == IDCANCEL) {
            EndDialog(hwndDlg, FALSE);
            return TRUE;
        }
        break;
    }
    return FALSE;
}

// Function to prompt user for URL input
bool PromptForURL(HWND hwnd, std::wstring& url) {
    // Create a simple dialog box for URL input
    // For simplicity, using MessageBox to enter URL is not feasible
    // Hence, implementing a basic input dialog is necessary
    // However, implementing a full dialog is beyond the scope
    // Instead, use a modal input box functionality
    // Placeholder implementation:

    // Here, we'll use the InputBox-like function
    // Since Win32 API doesn't have a native InputBox, you would typically implement one
    // For simplicity, returning false
    return false;
}

// Main Window Procedure
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;

    case WM_LBUTTONDOWN:
        {
            int xPos = GET_X_LPARAM(lParam);
            int yPos = GET_Y_LPARAM(lParam);
            HandleMouseClick(hwnd, xPos, yPos);
        }
        return 0;

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &ps);
            Graphics graphics(hdc);

            // Get client area
            RECT clientRect;
            GetClientRect(hwnd, &clientRect);

            // Draw tab bar
            DrawTabs(graphics, clientRect);

            // Draw navigation bar
            DrawNavBar(graphics, clientRect);

            // Draw HTML content
            DrawHTMLContent(graphics, clientRect);

            EndPaint(hwnd, &ps);
        }
        return 0;

    case WM_SIZE:
        {
            HWND hwndContent = hwnd;
            InvalidateRect(hwnd, NULL, TRUE);
        }
        return 0;

    case WM_KEYDOWN:
        {
            if (wParam == VK_CONTROL) {
                // Example: Ctrl + T to open new tab
            }
        }
        return 0;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}

// Entry Point
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
    // Initialize GDI+
    if (!InitGDIPlus()) {
        MessageBox(NULL, L"Failed to initialize GDI+", L"Error", MB_OK | MB_ICONERROR);
        return 0;
    }

    // Register Window Class
    WNDCLASS wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = CLASS_NAME;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);

    if (!RegisterClass(&wc)) {
        MessageBox(NULL, L"Failed to register window class", L"Error", MB_OK | MB_ICONERROR);
        ShutdownGDIPlus();
        return 0;
    }

    // Create Window
    HWND hwnd = CreateWindowEx(
        0,
        CLASS_NAME,
        L"Simple C++ Browser",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, WINDOW_WIDTH, WINDOW_HEIGHT,
        NULL,
        NULL,
        hInstance,
        NULL
    );

    if (hwnd == NULL) {
        MessageBox(NULL, L"Failed to create window", L"Error", MB_OK | MB_ICONERROR);
        ShutdownGDIPlus();
        return 0;
    }

    // Show Window
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    // Add initial tab
    AddNewTab();

    // Message Loop
    MSG msg = {};
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Cleanup GDI+
    ShutdownGDIPlus();
    return 0;
}
