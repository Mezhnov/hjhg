#include <windows.h>
#include <gdiplus.h>
#include <urlmon.h>
#include <shlwapi.h> // Для функций манипуляции путями
#include <string>
#include <ctime>
#include <vector>
#include <windowsx.h>
#include <cstdlib> // Для rand()

#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "urlmon.lib")
#pragma comment(lib, "shlwapi.lib") // Для функций манипуляции путями

using namespace Gdiplus;

// Структура для хранения иконки приложения и его метки
struct AppIcon {
    Bitmap* image;
    std::wstring label;
};

// Глобальные переменные для хранения изображений
Bitmap* g_mainImage = nullptr;
Bitmap* g_wifiIcon = nullptr;
Bitmap* g_batteryIcon = nullptr;
Bitmap* g_signalIcon = nullptr;
Bitmap* g_internetIcon = nullptr;

// Вектор для хранения иконок приложений
std::vector<AppIcon> g_appIcons;

// Глобальные переменные для отображения времени и даты
bool isDragging = false;
POINT dragStartPoint = { 0, 0 };

// Позиция времени и даты: настройте значения для позиционирования
RECT timeRect = { 50, 50, 300, 100 }; // Начальная позиция и размер времени
Color timeColor = Color(255, 255, 255, 255); // Белый цвет по умолчанию
float timeFontSize = 50.0f; // Начальный размер шрифта времени

RECT dateRect = { 50, 110, 300, 150 }; // Начальная позиция и размер даты
Color dateColor = Color(255, 255, 255, 255); // Белый цвет даты
float dateFontSize = 20.0f; // Начальный размер шрифта даты

std::wstring currentTime = L"00:00"; // Текущее время
std::wstring currentDate = L"01 Сентябрь 2023"; // Текущая дата

// Функция для преобразования миллиметров в пиксели на основе DPI экрана
int mmToPixels(float mm, int dpi) {
    return static_cast<int>(mm * dpi / 25.4f); // 1 дюйм = 25.4 мм
}

// Функция для загрузки изображения из URL
Bitmap* LoadImageFromURL(const wchar_t* url) {
    // Получить временный путь
    wchar_t tempPath[MAX_PATH];
    if (!GetTempPath(MAX_PATH, tempPath)) {
        return nullptr;
    }

    // Создать временный файл
    wchar_t tempFile[MAX_PATH];
    if (!GetTempFileName(tempPath, L"IMG", 0, tempFile)) {
        return nullptr;
    }

    // Скачать изображение во временный файл
    HRESULT hr = URLDownloadToFile(NULL, url, tempFile, 0, NULL);
    if (FAILED(hr)) {
        // Удалить временный файл, если загрузка не удалась
        DeleteFile(tempFile);
        return nullptr;
    }

    // Загрузить изображение с помощью GDI+
    Bitmap* bmp = Bitmap::FromFile(tempFile);
    if (bmp && bmp->GetLastStatus() != Ok) {
        delete bmp;
        bmp = nullptr;
    }

    // Удалить временный файл
    DeleteFile(tempFile);

    return bmp;
}

// Функция для получения текущего времени в формате "HH:MM"
std::wstring GetCurrentTimeString() {
    std::time_t t = std::time(nullptr);
    std::tm localTime;
    localtime_s(&localTime, &t);
    wchar_t buffer[6];
    swprintf_s(buffer, 6, L"%02d:%02d", localTime.tm_hour, localTime.tm_min);
    return std::wstring(buffer);
}

// Функция для получения текущей даты в формате "ДД ММММ ГГГГ"
std::wstring GetCurrentDateString() {
    std::time_t t = std::time(nullptr);
    std::tm localTime;
    localtime_s(&localTime, &t);

    // Массив названий месяцев на русском языке
    const wchar_t* months[] = { L"января", L"февраля", L"марта", L"апреля", L"мая", L"июня",
                                 L"июля", L"августа", L"сентября", L"октября", L"11", L"декабря" };

    wchar_t buffer[100];
    swprintf_s(buffer, 100, L"%02d.%s.%04d", localTime.tm_mday, months[localTime.tm_mon], 1900 + localTime.tm_year);
    return std::wstring(buffer);
}

// Обработка сообщений окна
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;

    case WM_TIMER: {
        if (wParam == 1) { // Таймер для обновления времени каждую минуту
            currentTime = GetCurrentTimeString();
            currentDate = GetCurrentDateString();
            InvalidateRect(hwnd, NULL, FALSE); // Перерисовать окно
        }
        return 0;
    }

    case WM_PAINT: {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);

        // Инициализация GDI+
        Graphics graphics(hdc);
        graphics.SetSmoothingMode(SmoothingModeAntiAlias);
        graphics.SetTextRenderingHint(TextRenderingHintClearTypeGridFit);

        // Получить размер клиентской области окна
        RECT rect;
        GetClientRect(hwnd, &rect);
        int windowWidth = rect.right - rect.left;
        int windowHeight = rect.bottom - rect.top;

        // Нарисовать основное изображение (фон)
        if (g_mainImage) {
            // Нарисовать изображение, масштабированное на размер окна
            graphics.DrawImage(g_mainImage, 0, 0, windowWidth, windowHeight);
        }

        // Получить DPI
        HDC screen = GetDC(hwnd);
        int dpiX = GetDeviceCaps(screen, LOGPIXELSX);
        int dpiY = GetDeviceCaps(screen, LOGPIXELSY);
        ReleaseDC(hwnd, screen);

        // Рассчитать размеры иконок с учетом DPI
        int iconSizeMM_Wifi = 4; // 5 мм
        int iconSizeMM_Battery = 5; // 5 мм
        int iconSizeMM_Signal = 5; // 5 мм
        int iconSizeMM_Internet = 5; // 5 мм
        int iconSizeMM_App = 10;  // 10 мм
        int spacingMM = 10;       // 10 мм между иконками
        int marginMM = 5;         // 5 мм от края окна
        int labelSpacingMM = 5;   // 5 мм между иконкой и меткой

        int iconSize_Wifi = mmToPixels(static_cast<float>(iconSizeMM_Wifi), dpiX);
        int iconSize_Battery = mmToPixels(static_cast<float>(iconSizeMM_Battery), dpiX);
        int iconSize_Signal = mmToPixels(static_cast<float>(iconSizeMM_Signal), dpiX);
        int iconSize_Internet = mmToPixels(static_cast<float>(iconSizeMM_Internet), dpiX);
        int iconSize_App = mmToPixels(static_cast<float>(iconSizeMM_App), dpiX);
        int spacing = mmToPixels(static_cast<float>(spacingMM), dpiX);
        int margin = mmToPixels(static_cast<float>(marginMM), dpiX);
        int labelSpacing = mmToPixels(static_cast<float>(labelSpacingMM), dpiY);

        // Нарисовать системные иконки (WiFi, Батарея, Сигнал, Интернет) в правом верхнем углу
        int iconsStartX = windowWidth - margin;
        int iconY = margin;

        // WiFi
        if (g_wifiIcon) {
            int x = iconsStartX - iconSize_Wifi;
            graphics.DrawImage(g_wifiIcon, x, iconY, iconSize_Wifi, iconSize_Wifi);
            iconsStartX -= (iconSize_Wifi + spacing);
        }

        // Батарея
        if (g_batteryIcon) {
            int x = iconsStartX - iconSize_Battery;
            graphics.DrawImage(g_batteryIcon, x, iconY, iconSize_Battery, iconSize_Battery);
            iconsStartX -= (iconSize_Battery + spacing);
        }

        // Сигнал
        if (g_signalIcon) {
            int x = iconsStartX - iconSize_Signal;
            graphics.DrawImage(g_signalIcon, x, iconY, iconSize_Signal, iconSize_Signal);
            iconsStartX -= (iconSize_Signal + spacing);
        }

        // Интернет
        if (g_internetIcon) {
            int x = iconsStartX - iconSize_Internet;
            graphics.DrawImage(g_internetIcon, x, iconY, iconSize_Internet, iconSize_Internet);
            iconsStartX -= (iconSize_Internet + spacing);
        }

        // Определить размеры иконок приложений
        int appIconSize = iconSize_App; // 10 мм
        int appSpacing = mmToPixels(static_cast<float>(spacingMM), dpiX); // 10 мм

        // Установить количество иконок в строке
        int iconsPerRow = 4; // Количество иконок в одной строке
        int totalApps = static_cast<int>(g_appIcons.size());
        int totalRows = (totalApps + iconsPerRow - 1) / iconsPerRow;

        // Рассчитать высоту строки на основе максимального размера шрифта
        int maxFontHeight = static_cast<int>(timeFontSize) + labelSpacing; // При необходимости скорректируйте
        int rowHeight = appIconSize + labelSpacing + mmToPixels(10.0f, dpiY); // Иконка + отступ метки + высота метки

        // Начальная Y позиция для рисования иконок
        int startY = windowHeight - rowHeight * totalRows - mmToPixels(5.0f, dpiY); // 5 мм от нижнего края

        // Рассчитать количество иконок в последней строке
        int iconsInLastRow = totalApps % iconsPerRow;
        if (iconsInLastRow == 0 && totalApps != 0) {
            iconsInLastRow = iconsPerRow;
        }

        // Нарисовать каждую иконку приложения и её метку
        for (int row = 0; row < totalRows; ++row) {
            int iconsInThisRow = (row == totalRows - 1) ? iconsInLastRow : iconsPerRow;
            int totalWidth = iconsInThisRow * appIconSize + (iconsInThisRow - 1) * appSpacing;
            int startX = (windowWidth - totalWidth) / 2; // Центрировать по горизонтали

            for (int i = 0; i < iconsInThisRow; ++i) {
                int appIndex = row * iconsPerRow + i;
                if (appIndex >= totalApps) break;

                AppIcon& app = g_appIcons[appIndex];
                if (app.image) {
                    int x = startX + i * (appIconSize + appSpacing);
                    int y = startY - row * rowHeight;

                    // Нарисовать иконку приложения
                    graphics.DrawImage(app.image, x, y, appIconSize, appIconSize);

                    // Нарисовать метку
                    const wchar_t* text = app.label.c_str();
                    FontFamily fontFamily(L"Segoe UI"); // Современный шрифт
                    float labelFontSize = 12.0f; // Размер шрифта метки
                    Font font(&fontFamily, labelFontSize, FontStyleRegular, UnitPixel);
                    SolidBrush brush(Color(255, 255, 255, 255)); // Белый текст

                    // Рассчитать прямоугольник для метки с увеличенной шириной, чтобы предотвратить перенос
                    float labelWidth = static_cast<float>(appIconSize) * 1.2f; // 20% шире
                    float labelHeight = mmToPixels(10.0f, dpiY); // Высота метки 10 мм
                    RectF layoutRect(static_cast<float>(x - (labelWidth - appIconSize) / 2),
                        static_cast<float>(y + appIconSize + labelSpacing),
                        labelWidth,
                        labelHeight);

                    // Установить форматирование строки: центрирование и отсутствие переноса
                    StringFormat format;
                    format.SetAlignment(StringAlignmentCenter);
                    format.SetLineAlignment(StringAlignmentCenter);
                    format.SetFormatFlags(StringFormatFlagsNoWrap);
                    format.SetTrimming(StringTrimmingEllipsisCharacter);

                    graphics.DrawString(
                        text,
                        -1,
                        &font,
                        layoutRect,
                        &format,
                        &brush
                    );
                }
            }
        }

        // Отображение текущего времени
        // Создать шрифт
        FontFamily timeFontFamily(L"Segoe UI Semibold"); // Более современный шрифт
        Font timeFont(&timeFontFamily, timeFontSize, FontStyleBold, UnitPixel);

        // Создать кисть для текста
        SolidBrush timeBrush(timeColor);

        // Установить выравнивание текста по центру
        StringFormat timeFormat;
        timeFormat.SetAlignment(StringAlignmentCenter);
        timeFormat.SetLineAlignment(StringAlignmentCenter);
        timeFormat.SetFormatFlags(StringFormatFlagsNoWrap);
        timeFormat.SetTrimming(StringTrimmingEllipsisCharacter);

        // Рассчитать позицию времени (например, центр верхней панели)
        int verticalOffset = mmToPixels(10.0f, dpiY); // 10 мм вниз

        // Определить прямоугольник для времени с достаточной шириной
        float timeRectWidth = mmToPixels(40.0f, dpiX); // Ширина 40 мм
        float timeRectHeight = mmToPixels(20.0f, dpiY); // Высота 20 мм
        float timeRectX = (windowWidth - timeRectWidth) / 2.0f; // Центрировать по горизонтали
        float timeRectY = mmToPixels(5.0f, dpiY) + verticalOffset; // Отступ от верхнего края

        RectF currentTimeRect(static_cast<float>(timeRectX),
            static_cast<float>(timeRectY),
            static_cast<float>(timeRectWidth),
            static_cast<float>(timeRectHeight));

        // Нарисовать текущее время
        graphics.DrawString(
            currentTime.c_str(),
            -1,
            &timeFont,
            currentTimeRect,
            &timeFormat,
            &timeBrush
        );

        // Отображение текущей даты под временем
        // Создать шрифт для даты
        FontFamily dateFontFamily(L"Segoe UI Semibold"); // Современный шрифт
        Font dateFont(&dateFontFamily, dateFontSize, FontStyleRegular, UnitPixel);

        // Создать кисть для даты
        SolidBrush dateBrush(dateColor);

        // Установить выравнивание текста по центру
        StringFormat dateFormat;
        dateFormat.SetAlignment(StringAlignmentCenter);
        dateFormat.SetLineAlignment(StringAlignmentCenter);
        dateFormat.SetFormatFlags(StringFormatFlagsNoWrap);
        dateFormat.SetTrimming(StringTrimmingEllipsisCharacter);

        // Рассчитать позицию даты
        float dateRectWidth = mmToPixels(40.0f, dpiX); // Ширина 40 мм
        float dateRectHeight = mmToPixels(15.0f, dpiY); // Высота 15 мм
        float dateRectX = (windowWidth - dateRectWidth) / 2.0f; // Центрировать по горизонтали
        float dateRectY = timeRectY + timeRectHeight + mmToPixels(-6.0f, dpiY); // Отступ 5 мм от времени

        RectF currentDateRect(static_cast<float>(dateRectX),
            static_cast<float>(dateRectY),
            static_cast<float>(dateRectWidth),
            static_cast<float>(dateRectHeight));

        // Нарисовать текущую дату
        graphics.DrawString(
            currentDate.c_str(),
            -1,
            &dateFont,
            currentDateRect,
            &dateFormat,
            &dateBrush
        );

        EndPaint(hwnd, &ps);
        return 0;
    }

    case WM_LBUTTONDOWN: {
        // Проверить, находится ли клик в области времени или даты
        int xPos = GET_X_LPARAM(lParam);
        int yPos = GET_Y_LPARAM(lParam);
        if ((xPos >= timeRect.left && xPos <= timeRect.right &&
            yPos >= timeRect.top && yPos <= timeRect.bottom) ||
            (xPos >= dateRect.left && xPos <= dateRect.right &&
                yPos >= dateRect.top && yPos <= dateRect.bottom)) {
            isDragging = true;
            // Определить, в какую область был клик
            if (xPos >= timeRect.left && xPos <= timeRect.right &&
                yPos >= timeRect.top && yPos <= timeRect.bottom) {
                dragStartPoint.x = xPos - timeRect.left;
                dragStartPoint.y = yPos - timeRect.top;
                // Обновить прямоугольник даты относительно нового положения времени
                dateRect.left = timeRect.left;
                dateRect.top = timeRect.bottom + mmToPixels(5.0f, GetDeviceCaps(GetDC(hwnd), LOGPIXELSY));
                dateRect.right = timeRect.right;
                dateRect.bottom = dateRect.top + (dateRect.bottom - dateRect.top);
            }
            SetCapture(hwnd);
        }
        return 0;
    }

    case WM_MOUSEMOVE: {
        if (isDragging) {
            int xPos = GET_X_LPARAM(lParam);
            int yPos = GET_Y_LPARAM(lParam);

            // Новая позиция для времени
            int newLeft = xPos - dragStartPoint.x;
            int newTop = yPos - dragStartPoint.y;

            // Обновить RECT для времени
            int width = timeRect.right - timeRect.left;
            int height = timeRect.bottom - timeRect.top;
            timeRect.left = newLeft;
            timeRect.top = newTop;
            timeRect.right = newLeft + width;
            timeRect.bottom = newTop + height;

            // Обновить RECT для даты, чтобы она оставалась под временем
            int dateWidth = dateRect.right - dateRect.left;
            int dateHeight = dateRect.bottom - dateRect.top;
            dateRect.left = newLeft;
            dateRect.top = newTop + height + mmToPixels(5.0f, GetDeviceCaps(GetDC(hwnd), LOGPIXELSY));
            dateRect.right = newLeft + dateWidth;
            dateRect.bottom = dateRect.top + dateHeight;

            InvalidateRect(hwnd, NULL, FALSE);
        }
        return 0;
    }

    case WM_LBUTTONUP: {
        if (isDragging) {
            isDragging = false;
            ReleaseCapture();
        }
        return 0;
    }

    case WM_RBUTTONDOWN: {
        // Добавить контекстное меню для изменения цвета и размера времени и даты
        HMENU hMenu = CreatePopupMenu();
        if (hMenu) {
            AppendMenu(hMenu, MF_STRING, 1001, L"Изменить цвет времени");
            AppendMenu(hMenu, MF_STRING, 1002, L"Увеличить размер времени");
            AppendMenu(hMenu, MF_STRING, 1003, L"Уменьшить размер времени");
            AppendMenu(hMenu, MF_SEPARATOR, 0, NULL);
            AppendMenu(hMenu, MF_STRING, 1004, L"Изменить цвет даты");
            AppendMenu(hMenu, MF_STRING, 1005, L"Увеличить размер даты");
            AppendMenu(hMenu, MF_STRING, 1006, L"Уменьшить размер даты");

            POINT cursorPos;
            GetCursorPos(&cursorPos);
            TrackPopupMenu(hMenu, TPM_RIGHTBUTTON, cursorPos.x, cursorPos.y, 0, hwnd, NULL);
            DestroyMenu(hMenu);
        }
        return 0;
    }

    case WM_COMMAND: {
        switch (LOWORD(wParam)) {
        case 1001: { // Изменить цвет времени
            // Пример: изменить на случайный цвет
            BYTE r = rand() % 256;
            BYTE g = rand() % 256;
            BYTE b = rand() % 256;
            timeColor = Color(255, r, g, b);
            InvalidateRect(hwnd, NULL, FALSE);
            break;
        }
        case 1002: { // Увеличить размер времени
            timeFontSize += 2.0f; // Увеличить размер шрифта на 2 пикселя
            InvalidateRect(hwnd, NULL, FALSE);
            break;
        }
        case 1003: { // Уменьшить размер времени
            if (timeFontSize > 20.0f) { // Минимальный размер шрифта
                timeFontSize -= 2.0f; // Уменьшить размер шрифта на 2 пикселя
                InvalidateRect(hwnd, NULL, FALSE);
            }
            break;
        }
        case 1004: { // Изменить цвет даты
            // Пример: изменить на случайный цвет
            BYTE r = rand() % 256;
            BYTE g = rand() % 256;
            BYTE b = rand() % 256;
            dateColor = Color(255, r, g, b);
            InvalidateRect(hwnd, NULL, FALSE);
            break;
        }
        case 1005: { // Увеличить размер даты
            dateFontSize += 2.0f; // Увеличить размер шрифта на 2 пикселя
            InvalidateRect(hwnd, NULL, FALSE);
            break;
        }
        case 1006: { // Уменьшить размер даты
            if (dateFontSize > 10.0f) { // Минимальный размер шрифта
                dateFontSize -= 2.0f; // Уменьшить размер шрифта на 2 пикселя
                InvalidateRect(hwnd, NULL, FALSE);
            }
            break;
        }
        default:
            break;
        }
        return 0;
    }

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}

// Основная функция для приложений Windows
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    // Инициализировать GDI+
    GdiplusStartupInput gdiplusStartupInput;
    ULONG_PTR gdiplusToken;
    if (GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL) != Ok) {
        MessageBox(NULL, L"Не удалось инициализировать GDI+.", L"Ошибка", MB_ICONERROR);
        return 0;
    }

    // Загрузить основное изображение из URL
    const wchar_t* mainImageURL = L"https://i.pinimg.com/736x/44/ba/d5/44bad5b1b0839e5ab430433c6ddfb4be.jpg";
    g_mainImage = LoadImageFromURL(mainImageURL);
    if (!g_mainImage) {
        MessageBox(NULL, L"Не удалось загрузить основное изображение по указанному URL.", L"Ошибка", MB_ICONERROR);
        GdiplusShutdown(gdiplusToken);
        return 0;
    }

    // Загрузить иконку WiFi
    const wchar_t* wifiIconURL = L"https://upload.wikimedia.org/wikipedia/commons/thumb/7/74/Feather-core-wifi.svg/1200px-Feather-core-wifi.svg.png";
    g_wifiIcon = LoadImageFromURL(wifiIconURL);
    if (!g_wifiIcon) {
        MessageBox(NULL, L"Не удалось загрузить иконку WiFi из интернета.", L"Ошибка", MB_ICONERROR);
        // Продолжить без иконки WiFi
    }

    // Загрузить иконку Батареи
    const wchar_t* batteryIconURL = L"https://cdn-icons-png.flaticon.com/512/545/545680.png"; // Пример URL, замените при необходимости
    g_batteryIcon = LoadImageFromURL(batteryIconURL);
    if (!g_batteryIcon) {
        MessageBox(NULL, L"Не удалось загрузить иконку Батареи из интернета.", L"Ошибка", MB_ICONERROR);
        // Продолжить без иконки Батареи
    }

    // Загрузить иконку Сигнала
    const wchar_t* signalIconURL = L"https://cdn-icons-png.flaticon.com/512/1828/1828665.png"; // Пример URL, замените при необходимости
    g_signalIcon = LoadImageFromURL(signalIconURL);
    if (!g_signalIcon) {
        MessageBox(NULL, L"Не удалось загрузить иконку Сигнала из интернета.", L"Ошибка", MB_ICONERROR);
        // Продолжить без иконки Сигнала
    }

    // Загрузить иконку Интернет
    const wchar_t* internetIconURL = L"https://cdn-icons-png.flaticon.com/512/3754/3754433.png"; // Пример URL, замените при необходимости
    g_internetIcon = LoadImageFromURL(internetIconURL);
    if (!g_internetIcon) {
        MessageBox(NULL, L"Не удалось загрузить иконку Интернет из интернета.", L"Ошибка", MB_ICONERROR);
        // Продолжить без иконки Интернет
    }

    // Определить URL иконок приложений
    const wchar_t* settingsIconURL = L"https://s2.radikal.cloud/2024/11/13/Remove-bg.ai_1731525142042.png";
    const wchar_t* filesIconURL = L"https://s2.radikal.cloud/2024/11/13/nyc01temp__5w4tPKmHJwunW7xVwlLT.png";
    const wchar_t* cameraIconURL = L"https://s2.radikal.cloud/2024/11/13/localqGJ6hAAKkQqIUfMK5Ruz--fotor-bg-remover-2024111321504.png";
    const wchar_t* browserIconURL = L"https://i.postimg.cc/qgVxqq8N/Remove-bg-ai-1730637074101.png";

    // Определить дополнительные URL иконок приложений
    const wchar_t* mailIconURL = L"https://s2.radikal.cloud/2024/11/13/localnkbwzab3ouepucggin8uc.-1_batcheditor_fotor-fotor-bg-remover-20241113223052.png";        // Почта
    const wchar_t* musicIconURL = L"https://i.postimg.cc/X7WMDrgp/Remove-bg-ai-1730624299550.png";      // Музыка
    const wchar_t* calendarIconURL = L"https://cdn-icons-png.flaticon.com/512/747/747376.png";  // Календарь
    const wchar_t* notesIconURL = L"https://cdn-icons-png.flaticon.com/512/1827/1827372.png";     // Заметки

    // Функция для добавления иконки приложения и её метки
    auto AddAppIcon = [&](const wchar_t* url, const std::wstring& label) {
        Bitmap* bmp = LoadImageFromURL(url);
        if (bmp) {
            AppIcon app;
            app.image = bmp;
            app.label = label;
            g_appIcons.push_back(app);
        }
        else {
            wchar_t errorMsg[256];
            swprintf_s(errorMsg, 256, L"Не удалось загрузить иконку \"%s\" из интернета.", label.c_str());
            MessageBox(NULL, errorMsg, L"Ошибка", MB_ICONERROR);
            // Продолжить без этой иконки
        }
        };

    // Добавить основные иконки приложений
    AddAppIcon(settingsIconURL, L"Настройки");
    AddAppIcon(filesIconURL, L"Файлы");
    AddAppIcon(cameraIconURL, L"Камера");
    AddAppIcon(browserIconURL, L"Браузер");

    // Добавить дополнительные иконки приложений с метками
    AddAppIcon(mailIconURL, L"Почта");        // Почта
    AddAppIcon(musicIconURL, L"Музыка");      // Музыка
    AddAppIcon(calendarIconURL, L"Календарь"); // Календарь
    AddAppIcon(notesIconURL, L"Заметки");      // Заметки

    // Параметры окна
    const wchar_t CLASS_NAME[] = L"Sample Window Class";

    // Зарегистрировать класс окна
    WNDCLASS wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); // Цвет фона по умолчанию
    wc.lpszClassName = CLASS_NAME;

    RegisterClass(&wc);

    // Получить DPI экрана
    HDC screenDC = GetDC(NULL);
    int dpiX = GetDeviceCaps(screenDC, LOGPIXELSX);
    int dpiY = GetDeviceCaps(screenDC, LOGPIXELSY);
    ReleaseDC(NULL, screenDC);

    // Размер окна в миллиметрах
    float widthMM = 90.1f;
    float heightMM = 159.1f;

    // Перевести размер окна из миллиметров в пиксели
    int width = mmToPixels(widthMM, dpiX);
    int height = mmToPixels(heightMM, dpiY);

    // Подогнать размер окна с учетом границ
    RECT wr = { 0, 0, width, height };
    DWORD style = WS_POPUP; // Стиль окна без рамок
    AdjustWindowRectEx(&wr, style, FALSE, 0);
    int adjustedWidth = wr.right - wr.left;
    int adjustedHeight = wr.bottom - wr.top;

    // Создать окно без рамок и кнопок управления
    HWND hwnd = CreateWindowEx(
        0,
        CLASS_NAME,
        L"My OS Design",
        style, // Стиль окна без рамок и кнопок управления
        CW_USEDEFAULT, CW_USEDEFAULT, adjustedWidth, adjustedHeight,
        NULL,
        NULL,
        hInstance,
        NULL
    );

    if (hwnd == NULL) {
        // Освободить ресурсы перед выходом
        if (g_mainImage) delete g_mainImage;
        if (g_wifiIcon) delete g_wifiIcon;
        if (g_batteryIcon) delete g_batteryIcon;
        if (g_signalIcon) delete g_signalIcon;
        if (g_internetIcon) delete g_internetIcon;
        for (auto& app : g_appIcons) {
            if (app.image) delete app.image;
        }
        GdiplusShutdown(gdiplusToken);
        return 0;
    }

    ShowWindow(hwnd, nCmdShow);

    // Установить таймер для обновления времени каждую минуту
    SetTimer(hwnd, 1, 60000, NULL); // ID таймера = 1, интервал = 60 000 мс (1 минута)

    // Начальная установка времени и даты
    currentTime = GetCurrentTimeString();
    currentDate = GetCurrentDateString();
    InvalidateRect(hwnd, NULL, FALSE);

    // Цикл сообщений
    MSG msg = {};
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Освободить ресурсы
    if (g_mainImage) delete g_mainImage;
    if (g_wifiIcon) delete g_wifiIcon;
    if (g_batteryIcon) delete g_batteryIcon;
    if (g_signalIcon) delete g_signalIcon;
    if (g_internetIcon) delete g_internetIcon;
    for (auto& app : g_appIcons) {
        if (app.image) delete app.image;
    }

    // Завершить работу GDI+
    GdiplusShutdown(gdiplusToken);

    return 0;
}
