#include <windows.h>
#include <gdiplus.h>
#include <urlmon.h>
#include <shlwapi.h> // For path functions
#include <string>
#include <vector>

#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "urlmon.lib")
#pragma comment(lib, "shlwapi.lib") // For path functions

using namespace Gdiplus;

// Global vector for holding additional images and their properties
struct ImageInfo {
    Bitmap* image;
    int x, y;
    int width, height;
};
std::vector<ImageInfo> g_additionalImages;
Bitmap* g_backgroundImage = nullptr;

// Function to convert mm to pixels based on screen DPI
int mmToPixels(float mm, int dpi) {
    return static_cast<int>(mm * dpi / 25.4f); // 1 inch = 25.4 mm
}

// Function to load an image from a URL
Bitmap* LoadImageFromURL(const wchar_t* url) {
    wchar_t tempPath[MAX_PATH];
    if (!GetTempPath(MAX_PATH, tempPath)) {
        return nullptr;
    }
    wchar_t tempFile[MAX_PATH];
    if (!GetTempFileName(tempPath, L"IMG", 0, tempFile)) {
        return nullptr;
    }
    HRESULT hr = URLDownloadToFile(NULL, url, tempFile, 0, NULL);
    if (FAILED(hr)) {
        DeleteFile(tempFile);
        return nullptr;
    }
    Bitmap* bmp = Bitmap::FromFile(tempFile);
    if (bmp && bmp->GetLastStatus() != Ok) {
        delete bmp;
        bmp = nullptr;
    }
    DeleteFile(tempFile);
    return bmp;
}

// Function to render images on the window
void DrawImages(Graphics& graphics, int windowWidth, int windowHeight) {
    if (g_backgroundImage) {
        graphics.DrawImage(g_backgroundImage, 0, 0, windowWidth, windowHeight);
    }
    for (const auto& imgInfo : g_additionalImages) {
        if (imgInfo.image) {
            graphics.DrawImage(imgInfo.image, imgInfo.x, imgInfo.y, imgInfo.width, imgInfo.height);
        }
    }
}

// Window message processing function
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    static bool dragging = false;
    static int dragIndex = -1;
    static POINT lastMousePos = {};

    switch (uMsg) {
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;

    case WM_LBUTTONDOWN: {
        int x = GET_X_LPARAM(lParam);
        int y = GET_Y_LPARAM(lParam);
        for (int i = 0; i < g_additionalImages.size(); ++i) {
            const auto& imgInfo = g_additionalImages[i];
            if (x >= imgInfo.x && x <= imgInfo.x + imgInfo.width &&
                y >= imgInfo.y && y <= imgInfo.y + imgInfo.height) {
                dragging = true;
                dragIndex = i;
                lastMousePos = { x, y };
                SetCapture(hwnd);
                break;
            }
        }
        return 0;
    }

    case WM_MOUSEMOVE:
        if (dragging && dragIndex != -1 && (wParam & MK_LBUTTON)) {
            int x = GET_X_LPARAM(lParam);
            int y = GET_Y_LPARAM(lParam);
            int dx = x - lastMousePos.x;
            int dy = y - lastMousePos.y;

            g_additionalImages[dragIndex].x += dx;
            g_additionalImages[dragIndex].y += dy;
            lastMousePos = { x, y };

            InvalidateRect(hwnd, NULL, TRUE);
        }
        return 0;

    case WM_LBUTTONUP:
        if (dragging) {
            dragging = false;
            dragIndex = -1;
            ReleaseCapture();
        }
        return 0;

    case WM_PAINT: {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);
        Graphics graphics(hdc);

        RECT rect;
        GetClientRect(hwnd, &rect);
        int windowWidth = rect.right - rect.left;
        int windowHeight = rect.bottom - rect.top;

        DrawImages(graphics, windowWidth, windowHeight);

        EndPaint(hwnd, &ps);
        return 0;
    }

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}

// Main function for Windows application
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    GdiplusStartupInput gdiplusStartupInput;
    ULONG_PTR gdiplusToken;
    if (GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL) != Ok) {
        return 0;
    }

    const wchar_t* backgroundURL = L"https://i.pinimg.com/736x/44/ba/d5/44bad5b1b0839e5ab430433c6ddfb4be.jpg";
    g_backgroundImage = LoadImageFromURL(backgroundURL);
    if (!g_backgroundImage) {
        MessageBox(NULL, L"Failed to load background image.", L"Error", MB_ICONERROR);
        GdiplusShutdown(gdiplusToken);
        return 0;
    }

    const wchar_t* imageURLs[] = {
        L"https://example.com/image1.jpg",
        L"https://example.com/image2.jpg",
        L"https://example.com/image3.jpg",
        L"https://example.com/image4.jpg"
    };

    for (int i = 0; i < 4; ++i) {
        Bitmap* img = LoadImageFromURL(imageURLs[i]);
        if (img) {
            g_additionalImages.push_back({ img, 50 * i, 50 * i, img->GetWidth() / 4, img->GetHeight() / 4 });
        }
    }

    const wchar_t CLASS_NAME[] = L"Sample Window Class";

    WNDCLASS wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszClassName = CLASS_NAME;

    RegisterClass(&wc);

    HDC screen = GetDC(0);
    int dpiX = GetDeviceCaps(screen, LOGPIXELSX);
    int dpiY = GetDeviceCaps(screen, LOGPIXELSY);
    ReleaseDC(0, screen);

    float widthMM = 90.1f;
    float heightMM = 159.1f;
    int width = mmToPixels(widthMM, dpiX);
    int height = mmToPixels(heightMM, dpiY);

    RECT wr = { 0, 0, width, height };
    DWORD style = WS_POPUP;
    AdjustWindowRectEx(&wr, style, FALSE, 0);
    int adjustedWidth = wr.right - wr.left;
    int adjustedHeight = wr.bottom - wr.top;

    HWND hwnd = CreateWindowEx(
        0,
        CLASS_NAME,
        L"My Window",
        style,
        CW_USEDEFAULT, CW_USEDEFAULT, adjustedWidth, adjustedHeight,
        NULL,
        NULL,
        hInstance,
        NULL
    );

    if (hwnd == NULL) {
        delete g_backgroundImage;
        for (auto& imgInfo : g_additionalImages) {
            delete imgInfo.image;
        }
        GdiplusShutdown(gdiplusToken);
        return 0;
    }

    ShowWindow(hwnd, nCmdShow);

    MSG msg = {};
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    delete g_backgroundImage;
    for (auto& imgInfo : g_additionalImages) {
        delete imgInfo.image;
    }
    GdiplusShutdown(gdiplusToken);

    return 0;
}
