#include <windows.h>
#include <gdiplus.h>
#include <urlmon.h>
#include <shlwapi.h>
#include <string>
#include <ctime>
#include <vector>
#include <windowsx.h>
#include <cstdlib>
#include <sstream>
#include <map>

#pragma comment (lib,"Gdiplus.lib")
#pragma comment (lib,"Urlmon.lib")
#pragma comment (lib,"Shlwapi.lib")

// Глобальные переменные
HINSTANCE hInst;
HWND hMarkyEdit;
HWND hStylinEdit;
HWND hRunButton;
HWND hMainWnd;

struct UIElement {
    std::string tagName;
    std::string id;
    std::string className;
    std::string text;
    RECT rect;
    std::vector<UIElement> children;
};

struct Style {
    int fontSize = 0;
    COLORREF textColor = 0;
    COLORREF backgroundColor = 0;
    std::string className;
    std::string id;
};

// Словари для хранения элементов и стилей
UIElement rootElement;
std::vector<Style> styles;

// Функции для парсинга
void ParseHTML(const std::string& htmlCode);
void ParseCSS(const std::string& cssCode);

// Функции для создания интерфейса
void CreateUI(HWND parent, const UIElement& element, int& yOffset);

// Вспомогательные функции
COLORREF ParseColor(const std::string& colorStr);

// Прототипы оконных процедур
LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK UIWndProc(HWND, UINT, WPARAM, LPARAM);

// Главная функция
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow) {
    hInst = hInstance;

    // Регистрация класса окна
    WNDCLASS wc = {};
    wc.lpfnWndProc = MainWndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = TEXT("MarkyStylinIDE");

    RegisterClass(&wc);

    // Создание главного окна
    hMainWnd = CreateWindowEx(
        0,
        wc.lpszClassName,
        TEXT("HTML & CSS IDE"),
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 800, 600,
        nullptr,
        nullptr,
        hInstance,
        nullptr
    );

    ShowWindow(hMainWnd, nCmdShow);

    // Цикл сообщений
    MSG msg = {};
    while (GetMessage(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return 0;
}

// Создание элементов управления в главном окне
void CreateControls(HWND hwnd) {
    CreateWindow(TEXT("STATIC"), TEXT("HTML Code:"),
        WS_VISIBLE | WS_CHILD,
        10, 10, 100, 20,
        hwnd, nullptr, hInst, nullptr);

    hMarkyEdit = CreateWindowEx(WS_EX_CLIENTEDGE, TEXT("EDIT"), TEXT(""),
        WS_VISIBLE | WS_CHILD | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
        10, 30, 360, 500,
        hwnd, nullptr, hInst, nullptr);

    CreateWindow(TEXT("STATIC"), TEXT("CSS Code:"),
        WS_VISIBLE | WS_CHILD,
        380, 10, 100, 20,
        hwnd, nullptr, hInst, nullptr);

    hStylinEdit = CreateWindowEx(WS_EX_CLIENTEDGE, TEXT("EDIT"), TEXT(""),
        WS_VISIBLE | WS_CHILD | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
        380, 30, 360, 500,
        hwnd, nullptr, hInst, nullptr);

    hRunButton = CreateWindow(TEXT("BUTTON"), TEXT("Запустить"),
        WS_VISIBLE | WS_CHILD,
        10, 540, 100, 30,
        hwnd, (HMENU)1, hInst, nullptr);
}

// Оконная процедура главного окна
LRESULT CALLBACK MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg)
    {
    case WM_CREATE:
        CreateControls(hwnd);
        break;
    case WM_COMMAND:
        if (LOWORD(wParam) == 1) // Нажата кнопка "Запустить"
        {
            // Получаем код из контролов
            TCHAR markyBuffer[10000];
            GetWindowText(hMarkyEdit, markyBuffer, 10000);
            std::wstring wMarkyCode = markyBuffer;
            std::string htmlCode(wMarkyCode.begin(), wMarkyCode.end());

            TCHAR stylinBuffer[10000];
            GetWindowText(hStylinEdit, stylinBuffer, 10000);
            std::wstring wStylinCode = stylinBuffer;
            std::string cssCode(wStylinCode.begin(), wStylinCode.end());

            // Парсим код
            ParseHTML(htmlCode);
            ParseCSS(cssCode);

            // Создаем новое окно для отображения интерфейса
            WNDCLASS wc = {};
            wc.lpfnWndProc = UIWndProc;
            wc.hInstance = hInst;
            wc.lpszClassName = TEXT("UIWindowClass");

            RegisterClass(&wc);

            HWND hUIWindow = CreateWindowEx(
                0,
                wc.lpszClassName,
                TEXT("Результат"),
                WS_OVERLAPPEDWINDOW,
                CW_USEDEFAULT, CW_USEDEFAULT, 500, 400,
                nullptr,
                nullptr,
                hInst,
                nullptr
            );

            ShowWindow(hUIWindow, SW_SHOW);
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// Оконная процедура окна интерфейса
LRESULT CALLBACK UIWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg)
    {
    case WM_CREATE:
    {
        int yOffset = 10;
        CreateUI(hwnd, rootElement, yOffset);
        break;
    }
    case WM_DESTROY:
        // Очищаем элементы и стили после закрытия окна
        rootElement.children.clear();
        styles.clear();
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// Функция парсинга HTML
void ParseHTML(const std::string& htmlCode) {
    // Простая реализация парсера HTML для ограниченного набора тегов

    rootElement.children.clear();
    std::istringstream iss(htmlCode);
    std::string line;

    UIElement* currentElement = &rootElement;
    std::vector<UIElement*> elementStack;

    std::string textBuffer;

    while (std::getline(iss, line)) {
        // Избавляемся от пробелов в начале и конце строки
        line.erase(0, line.find_first_not_of(" \t\r\n"));
        line.erase(line.find_last_not_of(" \t\r\n") + 1);

        if (line.empty())
            continue;

        if (line[0] == '<') {
            // Это тег
            if (line[1] == '/') {
                // Закрывающий тег
                if (!elementStack.empty()) {
                    elementStack.pop_back();
                    if (!elementStack.empty()) {
                        currentElement = elementStack.back();
                    }
                    else {
                        currentElement = &rootElement;
                    }
                }
            }
            else {
                // Открывающий тег
                UIElement element;

                // Парсим тег и атрибуты
                size_t pos = line.find(' ');
                size_t endPos = line.find('>');
                std::string tagName;
                if (pos != std::string::npos && pos < endPos) {
                    tagName = line.substr(1, pos - 1);
                }
                else {
                    tagName = line.substr(1, endPos - 1);
                }

                element.tagName = tagName;

                // Парсим атрибуты
                if (pos != std::string::npos && pos < endPos) {
                    std::string attrString = line.substr(pos + 1, endPos - pos - 1);
                    std::istringstream attrStream(attrString);
                    std::string attr;
                    while (attrStream >> attr) {
                        size_t equalPos = attr.find('=');
                        if (equalPos != std::string::npos) {
                            std::string attrName = attr.substr(0, equalPos);
                            std::string attrValue = attr.substr(equalPos + 1);
                            // Убираем кавычки
                            if (attrValue.front() == '"' && attrValue.back() == '"') {
                                attrValue = attrValue.substr(1, attrValue.length() - 2);
                            }
                            if (attrName == "id") {
                                element.id = attrValue;
                            }
                            else if (attrName == "class") {
                                element.className = attrValue;
                            }
                        }
                    }
                }

                // Добавляем элемент в текущий
                currentElement->children.push_back(element);
                // Теперь спускаемся в него
                currentElement = &currentElement->children.back();
                elementStack.push_back(currentElement);
            }
        }
        else {
            // Это текстовый узел
            if (currentElement != nullptr) {
                currentElement->text += line + "\n";
            }
        }
    }
}

// Функция парсинга CSS
void ParseCSS(const std::string& cssCode) {
    styles.clear();

    std::istringstream iss(cssCode);
    std::string line;
    Style currentStyle;
    bool inStyle = false;

    while (std::getline(iss, line)) {
        // Избавляемся от пробелов в начале и конце строки
        line.erase(0, line.find_first_not_of(" \t\r\n"));
        line.erase(line.find_last_not_of(" \t\r\n") + 1);

        if (line.empty())
            continue;

        if (line.back() == '{') {
            // Начало блока стилей
            inStyle = true;
            std::string selector = line.substr(0, line.length() - 1);
            selector.erase(selector.find_last_not_of(" \t") + 1);
            if (selector.front() == '.') {
                currentStyle.className = selector.substr(1);
                currentStyle.id = "";
            }
            else if (selector.front() == '#') {
                currentStyle.id = selector.substr(1);
                currentStyle.className = "";
            }
            else {
                currentStyle.className = selector;
                currentStyle.id = "";
            }
        }
        else if (line == "}") {
            // Конец блока стилей
            inStyle = false;
            styles.push_back(currentStyle);
            currentStyle = Style();
        }
        else if (inStyle) {
            // Стиль внутри блока
            size_t colonPos = line.find(':');
            if (colonPos != std::string::npos) {
                std::string property = line.substr(0, colonPos);
                std::string value = line.substr(colonPos + 1);
                // Убираем пробелы
                property.erase(property.find_last_not_of(" \t") + 1);
                value.erase(0, value.find_first_not_of(" \t"));
                value.erase(value.find_last_not_of(" \t;") + 1);
                if (property == "font-size") {
                    currentStyle.fontSize = std::atoi(value.c_str());
                }
                else if (property == "color") {
                    currentStyle.textColor = ParseColor(value);
                }
                else if (property == "background-color") {
                    currentStyle.backgroundColor = ParseColor(value);
                }
            }
        }
    }
}

// Функция создания интерфейса на основе парсинга
void CreateUI(HWND parent, const UIElement& element, int& yOffset) {
    for (const auto& child : element.children) {
        HWND hControl = nullptr;
        int x = 10, width = 200, height = 30; // Простые значения по умолчанию

        // Создаем элемент управления в зависимости от тега
        if (child.tagName == "label") {
            hControl = CreateWindow(TEXT("STATIC"), std::wstring(child.text.begin(), child.text.end()).c_str(),
                WS_VISIBLE | WS_CHILD,
                x, yOffset, width, height,
                parent, nullptr, hInst, nullptr);
        }
        else if (child.tagName == "button") {
            hControl = CreateWindow(TEXT("BUTTON"), std::wstring(child.text.begin(), child.text.end()).c_str(),
                WS_VISIBLE | WS_CHILD,
                x, yOffset, width, height,
                parent, nullptr, hInst, nullptr);
        }
        else if (child.tagName == "input") {
            hControl = CreateWindowEx(WS_EX_CLIENTEDGE, TEXT("EDIT"), std::wstring(child.text.begin(), child.text.end()).c_str(),
                WS_VISIBLE | WS_CHILD,
                x, yOffset, width, height,
                parent, nullptr, hInst, nullptr);
        }

        // Применяем стили
        for (const auto& style : styles) {
            bool match = false;
            if (!style.id.empty() && style.id == child.id) {
                match = true;
            }
            else if (!style.className.empty() && style.className == child.className) {
                match = true;
            }
            else if (style.className == child.tagName) {
                match = true;
            }

            if (match && hControl != nullptr) {
                if (style.fontSize > 0) {
                    // Изменяем размер шрифта
                    HFONT hFont = CreateFont(style.fontSize, 0, 0, 0, FW_NORMAL,
                        FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_OUTLINE_PRECIS,
                        CLIP_DEFAULT_PRECIS, CLEARTYPE_QUALITY, VARIABLE_PITCH, TEXT("Arial"));
                    SendMessage(hControl, WM_SETFONT, (WPARAM)hFont, TRUE);
                }

                if (style.textColor != 0) {
                    // Устанавливаем цвет текста
                    // Это упрощенная реализация; для полного применения цвета текста потребуется собственный контрол или переопределение рисования
                }

                if (style.backgroundColor != 0) {
                    // Устанавливаем цвет фона
                    HBRUSH hBrush = CreateSolidBrush(style.backgroundColor);
                    SetClassLongPtr(hControl, GCLP_HBRBACKGROUND, (LONG_PTR)hBrush);
                }
            }
        }

        // Увеличиваем yOffset для следующего элемента
        yOffset += height + 10;

        // Рекурсивно создаем дочерние элементы
        CreateUI(hControl, child, yOffset);
    }
}

// Функция парсинга цвета из строки
COLORREF ParseColor(const std::string& colorStr) {
    if (colorStr[0] == '#') {
        // Цвет в формате HEX
        unsigned int rgb = 0;
        std::stringstream ss;
        ss << std::hex << colorStr.substr(1);
        ss >> rgb;
        return RGB((rgb >> 16) & 0xFF, (rgb >> 8) & 0xFF, rgb & 0xFF);
    }
    else if (colorStr.find("rgb(") != std::string::npos) {
        int r, g, b;
        sscanf_s(colorStr.c_str(), "rgb(%d,%d,%d)", &r, &g, &b);
        return RGB(r, g, b);
    }
    // Можно добавить другие форматы
    return 0;
}
<label id="myLabel">Привет, мир!</label>
<button class="btn">Нажми меня</button>
<input id="input1" type="text" value="Введите текст">
#myLabel {
    font-size: 24;
    color: #FF0000;
}

.btn {
    background-color: #00FF00;
    font-size: 16;
}

input {
    background-color: #FFFF00;
    font-size: 14;
}
