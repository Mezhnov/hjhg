# browser.py

import sys
import socket
import threading
import re
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QTabWidget, QLineEdit, QPushButton,
    QVBoxLayout, QWidget, QTextBrowser, QMessageBox, QHBoxLayout, QLabel, QFileDialog
)
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtCore import Qt, pyqtSignal, QObject
from PyQt5.QtWebEngineWidgets import QWebEngineView  # Для предпросмотра HTML


BUFFER_SIZE = 4096  # Размер буфера

# Настройки сервера
HOST = '192.168.0.150'  # IP адрес сервера (замените на ваш)
PORT = 8080


class Worker(QObject):
    finished = pyqtSignal()
    error = pyqtSignal(str)
    result = pyqtSignal(dict, bytes)  # headers, body

    def load_smp_url(self, url):
        """
        Загружает SMP URL, отправляя GET-запрос на сервер и передавая результат.
        """
        parts = url.split('://', 1)
        if len(parts) != 2:
            self.error.emit("Неверный URL: должен начинаться с 'smp://'")
            self.finished.emit()
            return

        protocol, resource = parts
        resource = resource.replace('\\', '/')  # Замена обратных слэшей на прямые

        if protocol != 'smp':
            self.error.emit("Неверный протокол: ожидается 'smp'")
            self.finished.emit()
            return

        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            try:
                sock.connect((HOST, PORT))
                request = f"SMP 1.0\nACTION: GET\nRESOURCE: {resource}\n\n"
                sock.sendall(request.encode())

                # Чтение заголовков
                data = b""
                while b"\n\n" not in data:
                    part = sock.recv(BUFFER_SIZE)
                    if not part:
                        break
                    data += part

                header_data, _, body = data.partition(b"\n\n")
                headers = {}
                for line in header_data.decode().split('\n'):
                    if ': ' in line:
                        key, value = line.split(': ', 1)
                        headers[key.strip().upper()] = value.strip()

                content_length = int(headers.get('CONTENT-LENGTH', '0'))
                content_type = headers.get('CONTENT-TYPE', 'text/plain')
                status = headers.get('STATUS', 'OK')

                # Чтение оставшейся части тела
                remaining = content_length - len(body)
                while remaining > 0:
                    part = sock.recv(min(BUFFER_SIZE, remaining))
                    if not part:
                        break
                    body += part
                    remaining -= len(part)

                # Отладочные сообщения
                print(f"Получен STATUS: {status}")
                print(f"Получен Content-Type: {content_type}")
                print(f"Content-Length: {content_length}")
                print(f"Получено байт: {len(body)}")
                if content_type == 'text/html':
                    html_snippet = body.decode('utf-8', errors='ignore')[:500]
                    print(f"HTML Контент: {html_snippet}...")  # Печать первых 500 символов

                self.result.emit(headers, body)

            except socket.error as e:
                self.error.emit(f"Ошибка сокета: {str(e)}")
            except Exception as e:
                self.error.emit(f"Неизвестная ошибка: {str(e)}")
            finally:
                self.finished.emit()


class HtmlPreviewWindow(QMainWindow):
    def __init__(self, html_content, parent=None):
        super().__init__(parent)
        self.setWindowTitle("HTML Preview")
        self.setGeometry(150, 150, 800, 600)

        # Используем QWebEngineView для отображения HTML
        self.webView = QWebEngineView()
        self.webView.setHtml(html_content)
        self.setCentralWidget(self.webView)


class Browser(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("SMP Browser")
        self.setGeometry(100, 100, 1200, 800)
        self.setWindowIcon(QIcon('static/icon.png'))  # Убедитесь, что 'icon.png' существует

        self.tabWidget = QTabWidget()
        self.setCentralWidget(self.tabWidget)

        self.history = {}  # История по вкладкам
        self.forward_history = {}  # Вперед история по вкладкам
        self.preview_windows = []  # Список для хранения окон предпросмотра

        self.createMainTab()
        self.openSearchTabOnStart()

    def createMainTab(self):
        """
        Создает основную вкладку с вводом URL и кнопками навигации.
        """
        mainTab = QWidget()

        # Ввод URL
        self.urlEdit = QLineEdit()
        self.urlEdit.setPlaceholderText("Введите URL (smp://...)")
        self.urlEdit.setStyleSheet("""
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
        """)

        # Кнопки
        self.loadButton = self.createButton("Загрузить")
        self.loadButton.clicked.connect(self.loadUrlInCurrentTab)

        self.addTabButton = self.createButton("Добавить вкладку")
        self.addTabButton.clicked.connect(self.addTab)

        self.backButton = self.createButton("Назад")
        self.backButton.clicked.connect(self.goBack)

        self.forwardButton = self.createButton("Вперед")
        self.forwardButton.clicked.connect(self.goForward)

        self.refreshButton = self.createButton("Обновить")
        self.refreshButton.clicked.connect(self.refreshPage)

        # Дополнительная кнопка для сохранения изображения
        self.saveImageButton = self.createButton("Сохранить изображение")
        self.saveImageButton.clicked.connect(self.saveImage)

        # Раскладка кнопок
        buttonLayout = QHBoxLayout()
        buttonLayout.addWidget(self.backButton)
        buttonLayout.addWidget(self.forwardButton)
        buttonLayout.addWidget(self.refreshButton)
        buttonLayout.addWidget(self.loadButton)
        buttonLayout.addWidget(self.addTabButton)
        buttonLayout.addWidget(self.saveImageButton)

        # Область отображения контента
        self.contentBrowser = QTextBrowser()
        self.contentBrowser.setOpenExternalLinks(True)
        self.contentBrowser.setStyleSheet("""
            font-size: 16px;
        """)

        self.imageLabel = QLabel()
        self.imageLabel.setAlignment(Qt.AlignCenter)
        self.imageLabel.hide()  # Изначально скрыто

        # Основная раскладка
        layout = QVBoxLayout()
        layout.addWidget(self.urlEdit)
        layout.addLayout(buttonLayout)
        layout.addWidget(self.contentBrowser)
        layout.addWidget(self.imageLabel)

        mainTab.setLayout(layout)
        self.tabWidget.addTab(mainTab, "Главная")
        self.tabWidget.currentChanged.connect(self.updateUrlBar)

        # Инициализация истории для основной вкладки
        self.history[mainTab] = []
        self.forward_history[mainTab] = []

    def createButton(self, text):
        """
        Создает стилизованную кнопку с заданным текстом.
        """
        button = QPushButton(text)
        button.setStyleSheet("""
            padding: 10px;
            background-color: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
        """)
        button.setFixedHeight(40)
        button.setStyleSheet(button.styleSheet() + """
            QPushButton:hover {
                background-color: #357ae8;
            }
        """)
        return button

    def addTab(self):
        """
        Добавляет новую вкладку с собственным вводом URL и областью для контента.
        """
        newTab = QWidget()
        layout = QVBoxLayout()

        # Ввод URL для новой вкладки
        urlEdit = QLineEdit()
        urlEdit.setPlaceholderText("Введите URL (smp://...)")
        urlEdit.setStyleSheet("""
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
        """)

        # Кнопка загрузки
        loadButton = self.createButton("Загрузить")
        view = QTextBrowser()
        view.setOpenExternalLinks(True)
        view.setStyleSheet("""
            font-size: 16px;
        """)
        imageLabel = QLabel()
        imageLabel.setAlignment(Qt.AlignCenter)
        imageLabel.hide()

        loadButton.clicked.connect(lambda: self.loadUrlInSpecificTab(urlEdit.text(), view, newTab, imageLabel))

        # Кнопка сохранения изображения
        saveImageBtn = self.createButton("Сохранить изображение")
        saveImageBtn.clicked.connect(lambda: self.saveImageFromTab(newTab))

        # Раскладка кнопок
        buttonsLayout = QHBoxLayout()
        buttonsLayout.addWidget(loadButton)
        buttonsLayout.addWidget(saveImageBtn)

        layout.addWidget(urlEdit)
        layout.addLayout(buttonsLayout)
        layout.addWidget(view)
        layout.addWidget(imageLabel)

        newTab.setLayout(layout)
        self.tabWidget.addTab(newTab, "Новая вкладка")
        self.tabWidget.setCurrentWidget(newTab)

        # Инициализация истории для новой вкладки
        self.history[newTab] = []
        self.forward_history[newTab] = []

    def loadUrlInCurrentTab(self):
        """
        Загружает URL, введенный в адресную строку, в текущую вкладку.
        """
        current_tab = self.tabWidget.currentWidget()
        if current_tab:
            url = self.urlEdit.text()
            if not url:
                QMessageBox.warning(self, "Предупреждение", "Пожалуйста, введите URL.")
                return
            # Поиск QTextBrowser и QLabel в текущей вкладке
            contentBrowser = current_tab.findChild(QTextBrowser)
            imageLabel = current_tab.findChild(QLabel)
            # Обновление истории
            self.history[current_tab].append(url)
            self.forward_history[current_tab].clear()
            # Загрузка URL
            self.loadSmpUrl(url, contentBrowser, current_tab, imageLabel)

    def loadUrlInSpecificTab(self, url, view, tab, imageLabel=None):
        """
        Загружает URL в определенную вкладку.
        """
        if not url.startswith('smp://'):
            QMessageBox.warning(self, "Предупреждение", "Неверный префикс URL. Используйте 'smp://'")
            return
        if not url:
            QMessageBox.warning(self, "Предупреждение", "Пожалуйста, введите URL.")
            return
        # Обновление истории
        self.history[tab].append(url)
        self.forward_history[tab].clear()
        # Загрузка URL
        self.loadSmpUrl(url, view, tab, imageLabel)

    def loadSmpUrl(self, url, view, tab, imageLabel=None):
        """
        Загружает SMP URL и отображает контент в QTextBrowser или QLabel.
        """
        self.worker = Worker()
        self.worker.result.connect(lambda headers, body: self.handleResult(headers, body, view, tab, imageLabel))
        self.worker.error.connect(self.showError)
        self.worker.finished.connect(self.workerFinished)

        # Запуск воркера в отдельном потоке
        thread = threading.Thread(target=self.worker.load_smp_url, args=(url,), daemon=True)
        thread.start()

    def handleResult(self, headers, body, view, tab, imageLabel=None):
        """
        Обрабатывает результат от воркера и отображает контент в зависимости от типа.
        """
        status = headers.get('STATUS', 'OK')
        if status == 'ERROR':
            message = headers.get('MESSAGE', 'Unknown error')
            self.showError(message)
            return

        content_type = headers.get('CONTENT-TYPE', 'text/plain')
        content_length = int(headers.get('CONTENT-LENGTH', '0'))
        if content_length == 0:
            # Возможно, команда без тела
            return

        if content_type == 'text/html':
            try:
                html_content = body.decode('utf-8', errors='ignore')
                view.setHtml(html_content)
                # Парсинг и загрузка дополнительных ресурсов (CSS и Изображения)
                self.parseAndLoadResources(html_content, view, tab)
                if imageLabel:
                    imageLabel.hide()

                # Создание и отображение окна с полным HTML для предпросмотра
                preview_window = HtmlPreviewWindow(html_content, parent=self)
                preview_window.show()
                self.preview_windows.append(preview_window)  # Keep a reference

            except Exception as e:
                self.showError(f"Ошибка при обработке HTML: {e}")
        elif content_type.startswith('image/'):
            if imageLabel:
                pixmap = QPixmap()
                pixmap.loadFromData(body)
                imageLabel.setPixmap(pixmap.scaled(400, 400, Qt.KeepAspectRatio, Qt.SmoothTransformation))
                imageLabel.show()
        elif content_type == 'text/css':
            try:
                css_content = body.decode('utf-8', errors='ignore')
                # Применение CSS к QTextBrowser
                existing_styles = view.styleSheet()
                combined_styles = existing_styles + "\n" + css_content
                view.setStyleSheet(combined_styles)
            except Exception as e:
                self.showError(f"Ошибка при обработке CSS: {e}")
        else:
            try:
                plain_text = body.decode('utf-8', errors='ignore')
                view.setPlainText(plain_text)
                if imageLabel:
                    imageLabel.hide()
            except Exception as e:
                self.showError(f"Ошибка при обработке текста: {e}")

    def parseAndLoadResources(self, html_content, view, tab):
        """
        Парсит HTML для поиска связанных CSS и Изображений и загружает их.
        """
        # Регулярные выражения для поиска ссылок на CSS и изображения
        css_pattern = re.compile(r'<link\s+rel=["\']stylesheet["\']\s+href=["\'](smp://.+?)["\']', re.IGNORECASE)
        img_pattern = re.compile(r'<img\s+src=["\'](smp://.+?)["\']', re.IGNORECASE)

        css_links = css_pattern.findall(html_content)
        img_links = img_pattern.findall(html_content)

        # Загрузка CSS файлов
        for css_link in css_links:
            self.loadSmpUrl(css_link, view, tab)

        # Загрузка Изображений
        for img_link in img_links:
            self.loadImageInTab(img_link, tab)

    def loadImageInTab(self, img_url, tab):
        """
        Загружает изображение из SMP URL и отображает его в QLabel.
        """
        # Поиск QLabel в вкладке
        imageLabel = tab.findChild(QLabel)
        if imageLabel:
            # Запуск воркера для загрузки изображения
            worker = Worker()
            worker.result.connect(lambda headers, body: self.displayImage(headers, body, imageLabel))
            worker.error.connect(self.showError)
            worker.finished.connect(self.workerFinished)

            thread = threading.Thread(target=worker.load_smp_url, args=(img_url,), daemon=True)
            thread.start()

    def displayImage(self, headers, body, imageLabel):
        """
        Отображает загруженное изображение в QLabel.
        """
        status = headers.get('STATUS', 'OK')
        if status == 'ERROR':
            message = headers.get('MESSAGE', 'Unknown error')
            self.showError(message)
            return

        content_type = headers.get('CONTENT-TYPE', 'image/png')
        if content_type.startswith('image/'):
            pixmap = QPixmap()
            pixmap.loadFromData(body)
            imageLabel.setPixmap(pixmap.scaled(400, 400, Qt.KeepAspectRatio, Qt.SmoothTransformation))
            imageLabel.show()

    def workerFinished(self):
        """
        Хранитель для действий после завершения работы воркера.
        """
        pass  # Действия после загрузки могут быть добавлены здесь

    def showError(self, message):
        """
        Отображает сообщение об ошибке.
        """
        QMessageBox.critical(self, "Ошибка", message)

    def goBack(self):
        """
        Переходит назад в истории просмотра.
        """
        current_tab = self.tabWidget.currentWidget()
        if current_tab and self.history.get(current_tab):
            if len(self.history[current_tab]) > 1:
                last_url = self.history[current_tab].pop()
                previous_url = self.history[current_tab][-1]
                self.forward_history[current_tab].append(last_url)
                self.urlEdit.setText(previous_url)
                # Поиск QTextBrowser и QLabel в вкладке
                contentBrowser = current_tab.findChild(QTextBrowser)
                imageLabel = current_tab.findChild(QLabel)
                # Загрузка предыдущего URL
                self.loadSmpUrl(previous_url, contentBrowser, current_tab, imageLabel)
            else:
                QMessageBox.information(self, "Информация", "Нет предыдущей страницы.")
        else:
            QMessageBox.information(self, "Информация", "История просмотра пуста.")

    def goForward(self):
        """
        Переходит вперед в истории просмотра.
        """
        current_tab = self.tabWidget.currentWidget()
        if current_tab and self.forward_history.get(current_tab):
            if self.forward_history[current_tab]:
                next_url = self.forward_history[current_tab].pop()
                self.history[current_tab].append(next_url)
                self.urlEdit.setText(next_url)
                # Поиск QTextBrowser и QLabel в вкладке
                contentBrowser = current_tab.findChild(QTextBrowser)
                imageLabel = current_tab.findChild(QLabel)
                # Загрузка следующего URL
                self.loadSmpUrl(next_url, contentBrowser, current_tab, imageLabel)
            else:
                QMessageBox.information(self, "Информация", "Нет впереди истории.")
        else:
            QMessageBox.information(self, "Информация", "Вперед история пуста.")

    def refreshPage(self):
        """
        Обновляет текущую страницу.
        """
        current_tab = self.tabWidget.currentWidget()
        if current_tab:
            if self.history.get(current_tab) and self.history[current_tab]:
                current_url = self.history[current_tab][-1]
                # Поиск QTextBrowser и QLabel в вкладке
                contentBrowser = current_tab.findChild(QTextBrowser)
                imageLabel = current_tab.findChild(QLabel)
                # Перезагрузка текущего URL
                self.loadSmpUrl(current_url, contentBrowser, current_tab, imageLabel)
            else:
                QMessageBox.warning(self, "Предупреждение", "Нет страницы для обновления.")
        else:
            QMessageBox.warning(self, "Предупреждение", "Нет активной вкладки.")

    def saveImage(self):
        """
        Сохраняет отображаемое изображение из основной вкладки.
        """
        current_tab = self.tabWidget.currentWidget()
        if current_tab:
            imageLabel = current_tab.findChild(QLabel)
            if imageLabel and imageLabel.pixmap():
                options = QFileDialog.Options()
                file_path, _ = QFileDialog.getSaveFileName(
                    self,
                    "Сохранить изображение",
                    "",
                    "JPEG Files (*.jpg);;PNG Files (*.png);;All Files (*)",
                    options=options
                )
                if file_path:
                    imageLabel.pixmap().save(file_path)
                    QMessageBox.information(self, "Успех", f"Изображение сохранено как {file_path}")
            else:
                QMessageBox.warning(self, "Предупреждение", "Нет изображения для сохранения.")
        else:
            QMessageBox.warning(self, "Предупреждение", "Нет активной вкладки.")

    def saveImageFromTab(self, tab):
        """
        Сохраняет изображение из определенной вкладки.
        """
        if tab:
            imageLabel = tab.findChild(QLabel)
            if imageLabel and imageLabel.pixmap():
                options = QFileDialog.Options()
                file_path, _ = QFileDialog.getSaveFileName(
                    self,
                    "Сохранить изображение",
                    "",
                    "JPEG Files (*.jpg);;PNG Files (*.png);;All Files (*)",
                    options=options
                )
                if file_path:
                    imageLabel.pixmap().save(file_path)
                    QMessageBox.information(self, "Успех", f"Изображение сохранено как {file_path}")
            else:
                QMessageBox.warning(self, "Предупреждение", "Нет изображения для сохранения в этой вкладке.")
        else:
            QMessageBox.warning(self, "Предупреждение", "Не выбрана вкладка.")

    def updateUrlBar(self, index):
        """
        Обновляет адресную строку при переключении вкладок.
        """
        current_tab = self.tabWidget.widget(index)
        if current_tab:
            if index == 0:
                # Основная вкладка
                last_url = self.history.get(current_tab, [])[-1] if self.history.get(current_tab) else ''
                self.urlEdit.setText(last_url)
            else:
                # Другие вкладки
                child_urlEdit = current_tab.findChild(QLineEdit)
                if child_urlEdit:
                    self.urlEdit.setText(child_urlEdit.text())

    def openSearchTabOnStart(self):
        """
        Автоматически открывает вкладку поиска при запуске браузера.
        """
        self.loadSmpUrl('smp://search.com/', self.contentBrowser, self.tabWidget.widget(0), self.imageLabel)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    browser = Browser()
    browser.show()
    sys.exit(app.exec_())
