#include <windows.h>
#include <gdiplus.h>
#include <urlmon.h>
#include <shlwapi.h> // For path manipulation functions
#include <string>
#include <ctime>
#include <vector>
#include <windowsx.h>

#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "urlmon.lib")
#pragma comment(lib, "shlwapi.lib") // For path manipulation functions

using namespace Gdiplus;

// Structure to store icon and its label
struct AppIcon {
    Bitmap* image;
    std::wstring label;
};

// Structure for draggable status icons
struct StatusIcon {
    Bitmap* image;
    RECT rect;
    bool isDragging;
    POINT dragStartPoint;
};

// Global variables to store images
Bitmap* g_mainImage = nullptr;
Bitmap* g_batteryIcon = nullptr;
Bitmap* g_signalIcon = nullptr;

// Status icons
StatusIcon g_batteryStatus = { nullptr, {0, 0, 0, 0}, false, {0, 0} };
StatusIcon g_signalStatus = { nullptr, {0, 0, 0, 0}, false, {0, 0} };

// Vector to store application icons
std::vector<AppIcon> g_appIcons;

// Globals for displaying time and date
bool isDraggingTime = false;
POINT dragStartPointTime = { 0, 0 };
RECT timeRect = { 50, 50, 300, 100 }; // Initial position and size of time
RECT dateRect = { 50, 120, 300, 160 }; // Initial position and size of date
Color timeColor = Color(255, 255, 255, 255); // White color by default
float timeFontSize = 50.0f; // Initial font size
std::wstring currentTime = L"00:00"; // Current time
std::wstring currentDate = L"01.01.2023"; // Current date

// Function to convert millimeters to pixels based on screen DPI
int mmToPixels(float mm, int dpi) {
    return static_cast<int>(mm * dpi / 25.4f); // 1 inch = 25.4 mm
}

// Function to load image from URL
Bitmap* LoadImageFromURL(const wchar_t* url) {
    // Get temporary path
    wchar_t tempPath[MAX_PATH];
    if (!GetTempPath(MAX_PATH, tempPath)) {
        return nullptr;
    }

    // Create temporary file
    wchar_t tempFile[MAX_PATH];
    if (!GetTempFileName(tempPath, L"IMG", 0, tempFile)) {
        return nullptr;
    }

    // Download image to temporary file
    HRESULT hr = URLDownloadToFile(NULL, url, tempFile, 0, NULL);
    if (FAILED(hr)) {
        // Delete temporary file if download failed
        DeleteFile(tempFile);
        return nullptr;
    }

    // Load image using GDI+
    Bitmap* bmp = Bitmap::FromFile(tempFile);
    if (bmp && bmp->GetLastStatus() != Ok) {
        delete bmp;
        bmp = nullptr;
    }

    // Delete temporary file
    DeleteFile(tempFile);

    return bmp;
}

// Function to get current time in "HH:MM" format
std::wstring GetCurrentTimeString() {
    std::time_t t = std::time(nullptr);
    std::tm localTime;
    localtime_s(&localTime, &t);
    wchar_t buffer[6];
    swprintf_s(buffer, 6, L"%02d:%02d", localTime.tm_hour, localTime.tm_min);
    return std::wstring(buffer);
}

// Function to get current date in "DD.MM.YYYY" format
std::wstring GetCurrentDateString() {
    std::time_t t = std::time(nullptr);
    std::tm localTime;
    localtime_s(&localTime, &t);
    wchar_t buffer[11];
    swprintf_s(buffer, 11, L"%02d.%02d.%04d", localTime.tm_mday, localTime.tm_mon + 1, localTime.tm_year + 1900);
    return std::wstring(buffer);
}

// Window message processing function
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;

    case WM_TIMER: {
        if (wParam == 1) { // Timer to update time and date every minute
            currentTime = GetCurrentTimeString();
            currentDate = GetCurrentDateString();
            InvalidateRect(hwnd, NULL, FALSE); // Redraw window
        }
        return 0;
    }

    case WM_PAINT: {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);

        // Initialize GDI+
        Graphics graphics(hdc);
        graphics.SetSmoothingMode(SmoothingModeAntiAlias);
        graphics.SetTextRenderingHint(TextRenderingHintClearTypeGridFit);

        // Get window client area size
        RECT rect;
        GetClientRect(hwnd, &rect);
        int windowWidth = rect.right - rect.left;
        int windowHeight = rect.bottom - rect.top;

        // Draw main image (background)
        if (g_mainImage) {
            // Draw image scaled to window size
            graphics.DrawImage(g_mainImage, 0, 0, windowWidth, windowHeight);
        }

        // Get DPI
        HDC screen = GetDC(hwnd);
        int dpiX = GetDeviceCaps(screen, LOGPIXELSX);
        int dpiY = GetDeviceCaps(screen, LOGPIXELSY);
        ReleaseDC(hwnd, screen);

        // Calculate icon sizes considering DPI
        int iconSizeMM_Wifi = 5; // 5 mm
        int iconSizeMM_Battery = 5; // 5 mm
        int iconSizeMM_Signal = 5; // 5 mm
        int spacingMM = 10;        // 10 mm between icons
        int marginMM = 5;          // 5 mm from window edge
        int labelSpacingMM = 5;    // 5 mm between icon and label

        int iconSize_Wifi = mmToPixels(static_cast<float>(iconSizeMM_Wifi), dpiX);
        int iconSize_Battery = mmToPixels(static_cast<float>(iconSizeMM_Battery), dpiX);
        int iconSize_Signal = mmToPixels(static_cast<float>(iconSizeMM_Signal), dpiX);
        int appSpacing = mmToPixels(static_cast<float>(spacingMM), dpiX);
        int margin = mmToPixels(static_cast<float>(marginMM), dpiX);
        int labelSpacing = mmToPixels(static_cast<float>(labelSpacingMM), dpiY);

        // Draw status icons (Battery, Signal)
        // Define status icon sizes
        int statusIconSizeMM = 5; // 5 mm
        int statusIconSize = mmToPixels(static_cast<float>(statusIconSizeMM), dpiX);

        // Define spacing between status icons
        int statusSpacingMM = 2; // 2 mm
        int statusSpacing = mmToPixels(static_cast<float>(statusSpacingMM), dpiX);

        // Define margin from top and side
        int statusMarginMM = 5; // 5 mm
        int statusMargin = mmToPixels(static_cast<float>(statusMarginMM), dpiX);

        // Initial X position for status icons
        int statusX = windowWidth - margin - (statusIconSize * 2 + statusSpacing);
        int statusY = margin;

        // Draw Battery icon
        if (g_batteryIcon) {
            g_batteryStatus.rect.left = statusX;
            g_batteryStatus.rect.top = statusY;
            g_batteryStatus.rect.right = statusX + statusIconSize;
            g_batteryStatus.rect.bottom = statusY + statusIconSize;

            graphics.DrawImage(g_batteryIcon, statusX, statusY, statusIconSize, statusIconSize);
            statusX += statusIconSize + statusSpacing;
        }

        // Draw Signal icon
        if (g_signalIcon) {
            g_signalStatus.rect.left = statusX;
            g_signalStatus.rect.top = statusY;
            g_signalStatus.rect.right = statusX + statusIconSize;
            g_signalStatus.rect.bottom = statusY + statusIconSize;

            graphics.DrawImage(g_signalIcon, statusX, statusY, statusIconSize, statusIconSize);
            // statusX += statusIconSize + statusSpacing;
        }

        // Draw application icons
        // Determine application icon sizes
        int appIconSize = mmToPixels(static_cast<float>(10.0f), dpiX); // 10 mm
        int appSpacingPixels = appSpacing; // 10 mm

        // Set number of icons per row
        int iconsPerRow = 4; // Number of icons in one row
        int totalApps = static_cast<int>(g_appIcons.size());
        int totalRows = (totalApps + iconsPerRow - 1) / iconsPerRow;

        // Calculate row height based on maximum font size
        int rowHeight = appIconSize + labelSpacing + mmToPixels(10.0f, dpiY); // Icon + label spacing + label height

        // Initial Y position for drawing icons
        int startY = windowHeight - rowHeight * totalRows - mmToPixels(5.0f, dpiY); // 5 mm from bottom

        // Calculate number of icons in last row
        int iconsInLastRow = totalApps % iconsPerRow;
        if (iconsInLastRow == 0 && totalApps != 0) {
            iconsInLastRow = iconsPerRow;
        }

        // Draw each application icon and its label
        for (int row = 0; row < totalRows; ++row) {
            int iconsInThisRow = (row == totalRows - 1) ? iconsInLastRow : iconsPerRow;
            int totalWidth = iconsInThisRow * appIconSize + (iconsInThisRow - 1) * appSpacingPixels;
            int startX = (windowWidth - totalWidth) / 2; // Center horizontally

            for (int i = 0; i < iconsInThisRow; ++i) {
                int appIndex = row * iconsPerRow + i;
                if (appIndex >= totalApps) break;

                AppIcon& app = g_appIcons[appIndex];
                if (app.image) {
                    int x = startX + i * (appIconSize + appSpacingPixels);
                    int y = startY - row * rowHeight;

                    // Draw the application icon
                    graphics.DrawImage(app.image, x, y, appIconSize, appIconSize);

                    // Draw the label
                    const wchar_t* text = app.label.c_str();
                    if (!app.label.empty()) {
                        FontFamily fontFamily(L"Segoe UI");
                        // Adjust font size as needed
                        float labelFontSize = 12.0f; // Example font size
                        Font font(&fontFamily, labelFontSize, FontStyleRegular, UnitPixel);
                        SolidBrush brush(Color(255, 255, 255, 255)); // White text

                        // Calculate label rectangle with increased width to prevent wrapping
                        float labelWidth = static_cast<float>(appIconSize) * 1.2f; // 20% wider
                        float labelHeight = mmToPixels(10.0f, dpiY); // 10 mm height
                        RectF layoutRect(static_cast<float>(x - (labelWidth - appIconSize) / 2),
                            static_cast<float>(y + appIconSize + labelSpacing),
                            labelWidth,
                            labelHeight);

                        // Set StringFormat to prevent wrapping and center text
                        StringFormat format;
                        format.SetAlignment(StringAlignmentCenter);
                        format.SetLineAlignment(StringAlignmentCenter);
                        format.SetFormatFlags(StringFormatFlagsNoWrap);
                        format.SetTrimming(StringTrimmingEllipsisCharacter);

                        graphics.DrawString(
                            text,
                            -1,
                            &font,
                            layoutRect,
                            &format,
                            &brush
                        );
                    }
                }
            }
        }

        // Display the current time
        // Create font
        FontFamily timeFontFamily(L"Segoe UI"); // More modern font
        Font timeFont(&timeFontFamily, timeFontSize, FontStyleBold, UnitPixel);

        // Create brush for text
        SolidBrush timeBrush(timeColor);

        // Set text alignment to center
        StringFormat timeFormat;
        timeFormat.SetAlignment(StringAlignmentCenter);
        timeFormat.SetLineAlignment(StringAlignmentCenter);
        timeFormat.SetFormatFlags(StringFormatFlagsNoWrap);
        timeFormat.SetTrimming(StringTrimmingEllipsisCharacter);

        // Calculate time position
        float timeRectWidth = mmToPixels(40.0f, dpiX); // 40 mm width
        float timeRectHeight = mmToPixels(20.0f, dpiY); // 20 mm height
        float timeRectX = static_cast<float>(timeRect.left);
        float timeRectY = static_cast<float>(timeRect.top);

        RectF currentTimeRect(static_cast<float>(timeRectX),
            static_cast<float>(timeRectY),
            static_cast<float>(timeRectWidth),
            static_cast<float>(timeRectHeight));

        // Draw the current time
        graphics.DrawString(
            currentTime.c_str(),
            -1,
            &timeFont,
            currentTimeRect,
            &timeFormat,
            &timeBrush
        );

        // Display the current date
        // Create font
        FontFamily dateFontFamily(L"Segoe UI");
        Font dateFont(&dateFontFamily, 20.0f, FontStyleRegular, UnitPixel);
        SolidBrush dateBrush(Color(255, 255, 255, 255)); // White text

        // Set text alignment to center
        StringFormat dateFormat;
        dateFormat.SetAlignment(StringAlignmentCenter);
        dateFormat.SetLineAlignment(StringAlignmentCenter);
        dateFormat.SetFormatFlags(StringFormatFlagsNoWrap);
        dateFormat.SetTrimming(StringTrimmingEllipsisCharacter);

        // Calculate date position
        float dateRectWidth = mmToPixels(40.0f, dpiX); // 40 mm width
        float dateRectHeight = mmToPixels(15.0f, dpiY); // 15 mm height
        float dateRectX = static_cast<float>(dateRect.left);
        float dateRectY = static_cast<float>(dateRect.top);

        RectF currentDateRect(static_cast<float>(dateRectX),
            static_cast<float>(dateRectY),
            static_cast<float>(dateRectWidth),
            static_cast<float>(dateRectHeight));

        // Draw the current date
        graphics.DrawString(
            currentDate.c_str(),
            -1,
            &dateFont,
            currentDateRect,
            &dateFormat,
            &dateBrush
        );

        EndPaint(hwnd, &ps);
        return 0;
    }

    case WM_LBUTTONDOWN: {
        int xPos = GET_X_LPARAM(lParam);
        int yPos = GET_Y_LPARAM(lParam);

        // Check if click is within time area
        if (xPos >= timeRect.left && xPos <= timeRect.right &&
            yPos >= timeRect.top && yPos <= timeRect.bottom) {
            isDraggingTime = true;
            dragStartPointTime.x = xPos - timeRect.left;
            dragStartPointTime.y = yPos - timeRect.top;
            SetCapture(hwnd);
            return 0;
        }

        // Check if click is within Battery icon
        if (g_batteryIcon &&
            xPos >= g_batteryStatus.rect.left && xPos <= g_batteryStatus.rect.right &&
            yPos >= g_batteryStatus.rect.top && yPos <= g_batteryStatus.rect.bottom) {
            g_batteryStatus.isDragging = true;
            g_batteryStatus.dragStartPoint.x = xPos - g_batteryStatus.rect.left;
            g_batteryStatus.dragStartPoint.y = yPos - g_batteryStatus.rect.top;
            SetCapture(hwnd);
            return 0;
        }

        // Check if click is within Signal icon
        if (g_signalIcon &&
            xPos >= g_signalStatus.rect.left && xPos <= g_signalStatus.rect.right &&
            yPos >= g_signalStatus.rect.top && yPos <= g_signalStatus.rect.bottom) {
            g_signalStatus.isDragging = true;
            g_signalStatus.dragStartPoint.x = xPos - g_signalStatus.rect.left;
            g_signalStatus.dragStartPoint.y = yPos - g_signalStatus.rect.top;
            SetCapture(hwnd);
            return 0;
        }

        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    case WM_MOUSEMOVE: {
        int xPos = GET_X_LPARAM(lParam);
        int yPos = GET_Y_LPARAM(lParam);

        // Dragging Time
        if (isDraggingTime) {
            int newLeft = xPos - dragStartPointTime.x;
            int newTop = yPos - dragStartPointTime.y;

            // Ensure within window bounds
            if (newLeft < 0) newLeft = 0;
            if (newTop < 0) newTop = 0;

            timeRect.left = newLeft;
            timeRect.top = newTop;
            timeRect.right = newLeft + (timeRect.right - timeRect.left);
            timeRect.bottom = newTop + (timeRect.bottom - timeRect.top);

            // Update dateRect to follow timeRect
            int dateOffset = mmToPixels(5.0f, GetDeviceCaps(GetDC(hwnd), LOGPIXELSY)); // 5 mm below
            dateRect.left = timeRect.left;
            dateRect.top = timeRect.bottom + dateOffset;
            dateRect.right = timeRect.left + (timeRect.right - timeRect.left);
            dateRect.bottom = dateRect.top + (dateRect.bottom - dateRect.top);

            InvalidateRect(hwnd, NULL, FALSE);
            return 0;
        }

        // Dragging Battery Icon
        if (g_batteryStatus.isDragging) {
            int newLeft = xPos - g_batteryStatus.dragStartPoint.x;
            int newTop = yPos - g_batteryStatus.dragStartPoint.y;

            // Ensure within window bounds
            if (newLeft < 0) newLeft = 0;
            if (newTop < 0) newTop = 0;

            g_batteryStatus.rect.left = newLeft;
            g_batteryStatus.rect.top = newTop;
            g_batteryStatus.rect.right = newLeft + (g_batteryStatus.rect.right - g_batteryStatus.rect.left);
            g_batteryStatus.rect.bottom = newTop + (g_batteryStatus.rect.bottom - g_batteryStatus.rect.top);

            InvalidateRect(hwnd, NULL, FALSE);
            return 0;
        }

        // Dragging Signal Icon
        if (g_signalStatus.isDragging) {
            int newLeft = xPos - g_signalStatus.dragStartPoint.x;
            int newTop = yPos - g_signalStatus.dragStartPoint.y;

            // Ensure within window bounds
            if (newLeft < 0) newLeft = 0;
            if (newTop < 0) newTop = 0;

            g_signalStatus.rect.left = newLeft;
            g_signalStatus.rect.top = newTop;
            g_signalStatus.rect.right = newLeft + (g_signalStatus.rect.right - g_signalStatus.rect.left);
            g_signalStatus.rect.bottom = newTop + (g_signalStatus.rect.bottom - g_signalStatus.rect.top);

            InvalidateRect(hwnd, NULL, FALSE);
            return 0;
        }

        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    case WM_LBUTTONUP: {
        // Stop dragging
        if (isDraggingTime) {
            isDraggingTime = false;
            ReleaseCapture();
            return 0;
        }

        if (g_batteryStatus.isDragging) {
            g_batteryStatus.isDragging = false;
            ReleaseCapture();
            return 0;
        }

        if (g_signalStatus.isDragging) {
            g_signalStatus.isDragging = false;
            ReleaseCapture();
            return 0;
        }

        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    case WM_RBUTTONDOWN: {
        // Add context menu to change time color and size
        HMENU hMenu = CreatePopupMenu();
        if (hMenu) {
            AppendMenu(hMenu, MF_STRING, 1001, L"Change Time Color");
            AppendMenu(hMenu, MF_STRING, 1002, L"Increase Time Size");
            AppendMenu(hMenu, MF_STRING, 1003, L"Decrease Time Size");

            POINT cursorPos;
            GetCursorPos(&cursorPos);
            TrackPopupMenu(hMenu, TPM_RIGHTBUTTON, cursorPos.x, cursorPos.y, 0, hwnd, NULL);
            DestroyMenu(hMenu);
        }
        return 0;
    }

    case WM_COMMAND: {
        switch (LOWORD(wParam)) {
        case 1001: { // Change time color
            // Example: change to random color
            BYTE r = rand() % 256;
            BYTE g = rand() % 256;
            BYTE b = rand() % 256;
            timeColor = Color(255, r, g, b);
            InvalidateRect(hwnd, NULL, FALSE);
            break;
        }
        case 1002: { // Increase time size
            timeFontSize += 2.0f; // Increase font size by 2 pixels
            InvalidateRect(hwnd, NULL, FALSE);
            break;
        }
        case 1003: { // Decrease time size
            if (timeFontSize > 12.0f) { // Minimum font size
                timeFontSize -= 2.0f; // Decrease font size by 2 pixels
                InvalidateRect(hwnd, NULL, FALSE);
            }
            break;
        }
        default:
            break;
        }
        return 0;
    }

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}

// Main function for Windows applications
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    // Initialize GDI+
    GdiplusStartupInput gdiplusStartupInput;
    ULONG_PTR gdiplusToken;
    if (GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL) != Ok) {
        MessageBox(NULL, L"Failed to initialize GDI+.", L"Error", MB_ICONERROR);
        return 0;
    }

    // Load main image from URL
    const wchar_t* mainImageURL = L"https://i.pinimg.com/736x/44/ba/d5/44bad5b1b0839e5ab430433c6ddfb4be.jpg";
    g_mainImage = LoadImageFromURL(mainImageURL);
    if (!g_mainImage) {
        MessageBox(NULL, L"Failed to load main image from the specified URL.", L"Error", MB_ICONERROR);
        GdiplusShutdown(gdiplusToken);
        return 0;
    }

    // Load Battery icon
    const wchar_t* batteryIconURL = L"https://cdn-icons-png.flaticon.com/512/1829/1829402.png"; // Example battery icon URL
    g_batteryIcon = LoadImageFromURL(batteryIconURL);
    if (!g_batteryIcon) {
        MessageBox(NULL, L"Failed to load Battery icon from the internet.", L"Error", MB_ICONERROR);
        // Continue without Battery icon
    }

    // Load Signal icon
    const wchar_t* signalIconURL = L"https://cdn-icons-png.flaticon.com/512/1384/1384060.png"; // Example Signal icon URL
    g_signalIcon = LoadImageFromURL(signalIconURL);
    if (!g_signalIcon) {
        MessageBox(NULL, L"Failed to load Signal icon from the internet.", L"Error", MB_ICONERROR);
        // Continue without Signal icon
    }

    // Define application icon URLs
    const wchar_t* settingsIconURL = L"https://cdn-icons-png.flaticon.com/512/2099/2099058.png";
    const wchar_t* filesIconURL = L"https://cdn-icons-png.flaticon.com/512/727/727399.png";
    const wchar_t* cameraIconURL = L"https://cdn-icons-png.flaticon.com/512/633/633759.png";
    const wchar_t* browserIconURL = L"https://cdn-icons-png.flaticon.com/512/2702/2702602.png";

    // Define additional application icon URLs
    const wchar_t* mailIconURL = L"https://cdn-icons-png.flaticon.com/512/561/561127.png";       // Example: Mail
    const wchar_t* musicIconURL = L"https://cdn-icons-png.flaticon.com/512/727/727245.png";     // Example: Music
    const wchar_t* calendarIconURL = L"https://cdn-icons-png.flaticon.com/512/747/747376.png"; // Example: Calendar
    const wchar_t* notesIconURL = L"https://cdn-icons-png.flaticon.com/512/1827/1827372.png";    // Example: Notes

    // Function to add icon and its label
    auto AddAppIcon = [&](const wchar_t* url, const std::wstring& label) {
        Bitmap* bmp = LoadImageFromURL(url);
        if (bmp) {
            AppIcon app;
            app.image = bmp;
            app.label = label;
            g_appIcons.push_back(app);
        }
        else {
            wchar_t errorMsg[256];
            swprintf_s(errorMsg, 256, L"Failed to load icon \"%ls\" from the internet.", label.empty() ? L"Unnamed" : label.c_str());
            MessageBox(NULL, errorMsg, L"Error", MB_ICONERROR);
            // Continue without this icon
        }
    };

    // Add main application icons
    AddAppIcon(settingsIconURL, L"Настройки");    // Settings
    AddAppIcon(filesIconURL, L"Файлы");           // Files
    AddAppIcon(cameraIconURL, L"Камера");         // Camera
    AddAppIcon(browserIconURL, L"Браузер");       // Browser

    // Add additional application icons with labels
    AddAppIcon(mailIconURL, L"Почта");            // Mail
    AddAppIcon(musicIconURL, L"Музыка");         // Music
    AddAppIcon(calendarIconURL, L"Календарь");    // Calendar
    AddAppIcon(notesIconURL, L"Заметки");         // Notes

    // Window parameters
    const wchar_t CLASS_NAME[] = L"Sample Window Class";

    // Register window class
    WNDCLASS wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); // Default background color
    wc.lpszClassName = CLASS_NAME;

    RegisterClass(&wc);

    // Get screen DPI
    HDC screenDC = GetDC(NULL);
    int dpiX = GetDeviceCaps(screenDC, LOGPIXELSX);
    int dpiY = GetDeviceCaps(screenDC, LOGPIXELSY);
    ReleaseDC(NULL, screenDC);

    // Window size in millimeters
    float widthMM = 90.1f;
    float heightMM = 159.1f;

    // Convert window size from millimeters to pixels
    int width = mmToPixels(widthMM, dpiX);
    int height = mmToPixels(heightMM, dpiY);

    // Adjust window size to include borders
    RECT wr = { 0, 0, width, height };
    DWORD style = WS_POPUP; // Borderless window style
    AdjustWindowRectEx(&wr, style, FALSE, 0);
    int adjustedWidth = wr.right - wr.left;
    int adjustedHeight = wr.bottom - wr.top;

    // Create window without borders and control buttons
    HWND hwnd = CreateWindowEx(
        0,
        CLASS_NAME,
        L"My OS Design",
        style, // Window style without borders and control buttons
        CW_USEDEFAULT, CW_USEDEFAULT, adjustedWidth, adjustedHeight,
        NULL,
        NULL,
        hInstance,
        NULL
    );

    if (hwnd == NULL) {
        // Release resources before exiting
        if (g_mainImage) delete g_mainImage;
        if (g_batteryIcon) delete g_batteryIcon;
        if (g_signalIcon) delete g_signalIcon;
        for (auto& app : g_appIcons) {
            if (app.image) delete app.image;
        }
        GdiplusShutdown(gdiplusToken);
        return 0;
    }

    ShowWindow(hwnd, nCmdShow);

    // Set timer to update time and date every minute
    SetTimer(hwnd, 1, 60000, NULL); // Timer ID = 1, interval = 60,000 ms (1 minute)

    // Initial time and date setup
    currentTime = GetCurrentTimeString();
    currentDate = GetCurrentDateString();
    InvalidateRect(hwnd, NULL, FALSE);

    // Message loop
    MSG msg = {};
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Release resources
    if (g_mainImage) delete g_mainImage;
    if (g_batteryIcon) delete g_batteryIcon;
    if (g_signalIcon) delete g_signalIcon;
    for (auto& app : g_appIcons) {
        if (app.image) delete app.image;
    }

    // Shutdown GDI+
    GdiplusShutdown(gdiplusToken);

    return 0;
}
