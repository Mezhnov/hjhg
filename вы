# flask_app.py

from flask import Flask, request, render_template
from whoosh.index import open_dir
from whoosh.qparser import MultifieldParser
from whoosh.fields import TEXT, ID
from whoosh.query import *
import nltk
from nltk.stem.snowball import RussianStemmer
from nltk.corpus import stopwords
import re
import os

# Initialize NLTK resources
nltk.download('punkt')
nltk.download('stopwords')

app = Flask(__name__)

# Path to the search index
INDEX_DIR = 'indexdir'

# Open the Whoosh index
if not os.path.exists(INDEX_DIR):
    raise Exception(f"Index directory '{INDEX_DIR}' does not exist. Please run 'indexer.py' first.")
ix = open_dir(INDEX_DIR)

# Initialize stemmer and stopwords
stemmer = RussianStemmer()
stop_words = set(stopwords.words('russian'))

def clean_query(query):
    """
    Cleans and processes the search query.
    """
    tokens = nltk.word_tokenize(query.lower(), language='russian')
    tokens = [re.sub(r'\W+', '', token) for token in tokens]
    tokens = [token for token in tokens if token and token not in stop_words]
    tokens = [stemmer.stem(token) for token in tokens]
    return ' '.join(tokens)

@app.route('/search', methods=['GET'])
def search():
    query = request.args.get('q', '')
    if not query:
        return render_template('search.html', query=query, results=[], error="Пожалуйста, введите запрос для поиска.")

    try:
        clean_q = clean_query(query)
        parser = MultifieldParser(["title", "content"], schema=ix.schema)
        with ix.searcher() as searcher:
            parsed_query = parser.parse(clean_q)
            results = searcher.search(parsed_query, limit=10)
            hits = [
                {
                    'title': r['title'],
                    'url': r['path'],
                    'description': r.get('description', ''),
                    'logo': r.get('logo', '')  # Path to logo if available
                }
                for r in results
            ]
        return render_template('search.html', query=query, results=hits, error=None)
    except Exception as e:
        return render_template('search.html', query=query, results=[], error=f"Ошибка при выполнении поиска: {e}")

@app.route('/')
def home():
    """
    Renders the search home page.
    """
    return render_template('search.html', query='', results=[], error=None)

if __name__ == '__main__':
    # Run Flask app on localhost with a different port to avoid conflict
    app.run(host='127.0.0.1', port=5000, debug=False)
# server.py

import socket
import threading
import logging
import os
import json
from urllib.parse import urlparse, parse_qs
import requests  # To communicate with Flask app

# Import Flask app
from flask_app import app as flask_app

# Configuration
HOST = '0.0.0.0'          # Listen on all interfaces
PORT = 8080               # SMP server port
BUFFER_SIZE = 4096        # Buffer size for data transmission
FLASK_HOST = '127.0.0.1'  # Flask app host
FLASK_PORT = 5000         # Flask app port

# Allowed domains and their root directories
allowed_domains = {
    'example.com': os.path.join('pages', 'example.com'),
    'test.com': os.path.join('pages', 'test.com'),
    'search.com': 'search'  # Special handling via Flask
}

# Initialize NLTK resources if needed (already handled in flask_app.py)

# Setup logging
logging.basicConfig(
    filename='smp_server.log',
    level=logging.INFO,
    format='%(asctime)s:%(levelname)s:%(message)s'
)

def run_flask():
    """
    Runs the Flask app in the same process but separate thread.
    """
    flask_app.run(host=FLASK_HOST, port=FLASK_PORT, debug=False, use_reloader=False)

def send_response(conn, status, content_type, body):
    """
    Sends an SMP-formatted response to the client.
    """
    content_length = len(body)
    response_headers = (
        f"SMP 1.0\n"
        f"STATUS: {status}\n"
        f"CONTENT-TYPE: {content_type}\n"
        f"CONTENT-LENGTH: {content_length}\n\n"
    )
    try:
        conn.sendall(response_headers.encode() + body)
        logging.info(f"Responded with STATUS={status}, CONTENT-TYPE={content_type}, CONTENT-LENGTH={content_length}")
    except Exception as e:
        logging.error(f"Failed to send response: {e}")

def send_file(conn, filepath):
    """
    Sends a file from the server to the client.
    """
    if not os.path.exists(filepath):
        message = "Resource not found."
        send_response(conn, "ERROR", "text/plain", message.encode())
        logging.warning(f"File not found: {filepath}")
        return

    try:
        with open(filepath, 'rb') as f:
            content = f.read()

        # Determine content type based on file extension
        _, ext = os.path.splitext(filepath)
        ext = ext.lower()
        if ext in ['.html', '.htm']:
            content_type = 'text/html'
        elif ext == '.css':
            content_type = 'text/css'
        elif ext == '.js':
            content_type = 'application/javascript'
        elif ext in ['.png', '.jpg', '.jpeg', '.gif']:
            content_type = f"image/{ext[1:]}"
        else:
            content_type = 'application/octet-stream'

        send_response(conn, "OK", content_type, content)
    except Exception as e:
        message = f"Failed to read file: {e}"
        send_response(conn, "ERROR", "text/plain", message.encode())
        logging.error(f"Error sending file {filepath}: {e}")

def handle_search_action(headers):
    """
    Handles the ACTION: SEARCH by communicating with Flask app.
    """
    query = headers.get('QUERY', '')
    if not query:
        return {'status': 'ERROR', 'message': 'Missing QUERY parameter.'}

    try:
        # Send a GET request to Flask's /search endpoint
        params = {'q': query}
        response = requests.get(f"http://{FLASK_HOST}:{FLASK_PORT}/search", params=params, timeout=5)

        if response.status_code == 200:
            # Flask returns rendered HTML
            return {'status': 'OK', 'content_type': 'text/html', 'body': response.text.encode('utf-8')}
        else:
            return {'status': 'ERROR', 'message': f"Search service failed with status code {response.status_code}"}
    except Exception as e:
        logging.error(f"Error communicating with Flask app: {e}")
        return {'status': 'ERROR', 'message': f"Search error: {e}"}

def handle_client(conn, addr):
    """
    Handles an individual client connection.
    """
    logging.info(f"Connected to client: {addr}")
    with conn:
        while True:
            try:
                data = b''
                while b'\n\n' not in data:
                    part = conn.recv(BUFFER_SIZE)
                    if not part:
                        logging.info(f"Client {addr} disconnected.")
                        return
                    data += part

                header_data, _, body = data.partition(b'\n\n')
                headers = {}
                for line in header_data.decode().split('\n'):
                    if ': ' in line:
                        key, value = line.split(': ', 1)
                        headers[key.strip().upper()] = value.strip()

                action = headers.get('ACTION')
                resource = headers.get('RESOURCE')

                if action == 'GET' and resource:
                    parsed = urlparse('smp://' + resource)
                    domain = parsed.hostname
                    path = parsed.path.lstrip('/')

                    if domain not in allowed_domains:
                        message = "Domain not allowed."
                        send_response(conn, "ERROR", "text/plain", message.encode())
                        logging.warning(f"Attempted access to disallowed domain: {domain}")
                        continue

                    if domain == 'search.com':
                        # Handle search.com via Flask
                        # Check for query parameters
                        query_params = parse_qs(parsed.query)
                        query = query_params.get('q', [''])[0]

                        if query:
                            # Perform search
                            search_result = handle_search_action({'QUERY': query})
                            if search_result.get('status') == 'OK':
                                send_response(conn, "OK", search_result['content_type'], search_result['body'])
                            else:
                                error_message = search_result.get('message', 'Unknown error.')
                                send_response(conn, "ERROR", "text/plain", error_message.encode())
                        else:
                            # Serve the search home page
                            flask_home_response = requests.get(f"http://{FLASK_HOST}:{FLASK_PORT}/", timeout=5)
                            if flask_home_response.status_code == 200:
                                send_response(conn, "OK", "text/html", flask_home_response.text.encode('utf-8'))
                            else:
                                message = "Failed to load search home page."
                                send_response(conn, "ERROR", "text/plain", message.encode())
                                logging.warning(f"Flask home page failed with status code {flask_home_response.status_code}")
                    else:
                        # Serve static files for other domains
                        domain_root = allowed_domains[domain]
                        file_path = os.path.join(domain_root, path) if path else os.path.join(domain_root, 'index.html')

                        # Prevent directory traversal
                        real_path = os.path.realpath(file_path)
                        real_root = os.path.realpath(domain_root)
                        if not real_path.startswith(real_root):
                            message = "Invalid resource path."
                            send_response(conn, "ERROR", "text/plain", message.encode())
                            logging.warning(f"Directory traversal attempt: {file_path}")
                            continue

                        if os.path.isdir(real_path):
                            file_path = os.path.join(real_path, 'index.html')
                            if not os.path.exists(file_path):
                                message = "Resource not found."
                                send_response(conn, "ERROR", "text/plain", message.encode())
                                logging.warning(f"Directory index not found: {file_path}")
                                continue

                        send_file(conn, file_path)

                elif action == 'SEARCH':
                    # Direct search action without specifying search.com
                    search_result = handle_search_action(headers)
                    if search_result.get('status') == 'OK':
                        send_response(conn, "OK", search_result['content_type'], search_result['body'])
                    else:
                        error_message = search_result.get('message', 'Unknown error.')
                        send_response(conn, "ERROR", "text/plain", error_message.encode())
                        logging.warning(f"Search action failed: {error_message}")

                else:
                    message = "Invalid ACTION or missing RESOURCE."
                    send_response(conn, "ERROR", "text/plain", message.encode())
                    logging.warning(f"Received invalid request: ACTION={action}, RESOURCE={resource}")

            except Exception as e:
                logging.error(f"Error handling client {addr}: {e}")
                message = f"Internal server error: {e}"
                send_response(conn, "ERROR", "text/plain", message.encode())
                break

def start_server():
    """
    Starts the SMP server and Flask app.
    """
    # Start Flask app in a separate thread
    flask_thread = threading.Thread(target=run_flask, daemon=True)
    flask_thread.start()
    logging.info(f"Flask app is running on http://{FLASK_HOST}:{FLASK_PORT}/")

    # Start SMP server
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        server_socket.bind((HOST, PORT))
        server_socket.listen()
        logging.info(f"SMP Server started on {HOST}:{PORT}")

        while True:
            conn, addr = server_socket.accept()
            client_thread = threading.Thread(target=handle_client, args=(conn, addr), daemon=True)
            client_thread.start()

if __name__ == "__main__":
    start_server()
