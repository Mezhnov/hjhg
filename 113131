# server.py

import socket
import threading
import logging
import os
import re
from urllib.parse import urlparse

from whoosh.index import open_dir, create_in
from whoosh.fields import Schema, TEXT, ID, STORED
from whoosh.qparser import MultifieldParser

from bs4 import BeautifulSoup

# -----------------------------
# Configuration and Setup
# -----------------------------

# Получаем абсолютный путь к директории проекта
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# Server Configuration
HOST = '0.0.0.0'  # Listen on all interfaces
PORT = 8080
BUFFER_SIZE = 4096  # Buffer size for data transmission

# Logging Configuration
logging.basicConfig(
    filename='smp_server.log',
    level=logging.INFO,
    format='%(asctime)s:%(levelname)s:%(message)s'
)

# Allowed Domains and Their Root Directories (используем абсолютные пути)
allowed_domains = {
    'search': os.path.join(BASE_DIR, 'search'),
    'sites': os.path.join(BASE_DIR, 'sites')
}

# Path to Whoosh Index Directory
INDEX_DIR = os.path.join(BASE_DIR, 'indexdir')

# Ensure the index directory exists
if not os.path.exists(INDEX_DIR):
    os.mkdir(INDEX_DIR)

# Define the schema for the index
schema = Schema(
    url=ID(stored=True, unique=True),
    title=TEXT(stored=True),
    content=TEXT,
    description=TEXT(stored=True),
    logo=STORED
)

# Initialize Whoosh Index
if not os.path.exists(INDEX_DIR) or not os.listdir(INDEX_DIR):
    ix = create_in(INDEX_DIR, schema)
    logging.info("Created new Whoosh index.")
else:
    ix = open_dir(INDEX_DIR)
    logging.info("Opened existing Whoosh index.")

# -----------------------------
# Helper Functions
# -----------------------------

import nltk
from nltk.stem.snowball import RussianStemmer
from nltk.corpus import stopwords
import re

# Инициализация NLTK данных
nltk.download('punkt')
nltk.download('stopwords')

stemmer = RussianStemmer()
stop_words = set(stopwords.words('russian'))

def clean_query_string(query):
    """
    Cleans and processes the search query.
    """
    tokens = nltk.word_tokenize(query.lower(), language='russian')
    tokens = [re.sub(r'\W+', '', token) for token in tokens]
    tokens = [token for token in tokens if token and token not in stop_words]
    tokens = [stemmer.stem(token) for token in tokens]
    return ' '.join(tokens)

def generate_search_results_html(query, hits):
    """
    Generates HTML content for search results.
    """
    html_header = f"""
    <!DOCTYPE html>
    <html lang="ru">
    <head>
        <meta charset="UTF-8">
        <title>Результаты поиска для "{query}"</title>
        <link rel="stylesheet" href="smp://search/styles.css">
    </head>
    <body>
        <div class="header">
            <div class="logo">
                <img src="smp://search/logos/logo.png" alt="Логотип поисковой системы">
            </div>
            <form method="GET" action="smp://search/index.html" class="search-form">
                <input type="text" name="query" value="{query}" required autocomplete="off" placeholder="Что вы ищете?">
                <button type="submit">Найти</button>
            </form>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="showResults('all')">Поиск</button>
            <button class="tab" onclick="showResults('images')">Картинки</button>
            <button class="tab" onclick="showResults('videos')">Видео</button>
            <button class="tab" onclick="showResults('news')">Новости</button>
        </div>

        <div class="results" id="results-all">
    """

    html_footer = """
        </div>

        <div class="results" id="results-images" style="display: none;">
            <!-- Здесь будут результаты для изображений -->
        </div>
        <div class="results" id="results-videos" style="display: none;">
            <!-- Здесь будут результаты для видео -->
        </div>
        <div class="results" id="results-news" style="display: none;">
            <!-- Здесь будут результаты для новостей -->
        </div>

        <script>
            function showResults(category) {
                const categories = ['all', 'images', 'videos', 'news'];
                categories.forEach(cat => {
                    const resultsDiv = document.getElementById(`results-${cat}`);
                    resultsDiv.style.display = cat === category ? 'block' : 'none';
                });
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`.tab[onclick="showResults('${category}')"]`).classList.add('active');
            }
        </script>
    </body>
    </html>
    """

    result_items = ""
    for hit in hits:
        logo_html = f"""<img src="{hit['logo']}" alt="Site Logo" class="site-logo-img">""" if hit['logo'] else ""
        result_items += f"""
        <div class="result">
            <div class="site-logo">
                {logo_html}
            </div>
            <div class="result-content">
                <h2><a href="{hit['url']}">{hit['title']}</a></h2>
                <div class="description">{hit['description']}</div>
            </div>
        </div>
        """

    return html_header + result_items + html_footer

def send_large_file(conn, filepath):
    """
    Sends a file to the client in chunks along with appropriate headers.
    """
    if not os.path.exists(filepath):
        logging.error(f"File not found: {filepath}")
        message = "File not found"
        response = (
            f"SMP 1.0\n"
            f"STATUS: ERROR\n"
            f"MESSAGE: {message}\n"
            f"CONTENT-TYPE: text/plain\n"
            f"CONTENT-LENGTH: {len(message)}\n\n"
            f"{message}"
        )
        conn.sendall(response.encode())
        return

    try:
        file_size = os.path.getsize(filepath)
        _, ext = os.path.splitext(filepath)
        ext = ext.lower()
        if ext in ['.html', '.htm']:
            content_type = 'text/html'
        elif ext == '.css':
            content_type = 'text/css'
        elif ext == '.png':
            content_type = 'image/png'
        elif ext in ['.jpg', '.jpeg']:
            content_type = 'image/jpeg'
        elif ext == '.gif':
            content_type = 'image/gif'
        elif ext == '.js':
            content_type = 'application/javascript'
        else:
            content_type = 'application/octet-stream'

        # Send headers
        response_headers = (
            f"SMP 1.0\n"
            f"STATUS: OK\n"
            f"CONTENT-TYPE: {content_type}\n"
            f"CONTENT-LENGTH: {file_size}\n\n"
        )
        conn.send(response_headers.encode())
        logging.info(f"Sending file: {filepath}")

        # Send the file in chunks
        with open(filepath, 'rb') as f:
            while True:
                chunk = f.read(BUFFER_SIZE)
                if not chunk:
                    break
                conn.sendall(chunk)
        logging.info(f"File sent: {filepath}")

    except Exception as e:
        logging.error(f"Error sending file {filepath}: {e}")
        message = f"Error sending file: {e}"
        response = (
            f"SMP 1.0\n"
            f"STATUS: ERROR\n"
            f"MESSAGE: {message}\n"
            f"CONTENT-TYPE: text/plain\n"
            f"CONTENT-LENGTH: {len(message)}\n\n"
            f"{message}"
        )
        conn.sendall(response.encode())

def send_error(conn, message):
    """
    Sends an error message to the client.
    """
    response = (
        f"SMP 1.0\n"
        f"STATUS: ERROR\n"
        f"MESSAGE: {message}\n"
        f"CONTENT-TYPE: text/plain\n"
        f"CONTENT-LENGTH: {len(message)}\n\n"
        f"{message}"
    )
    conn.sendall(response.encode())

def build_index():
    """
    Scans all allowed domains and indexes the content of HTML files for search functionality.
    """
    from bs4 import BeautifulSoup  # Import here to ensure it's available

    writer = ix.writer()
    for domain, root_dir in allowed_domains.items():
        if not os.path.isdir(root_dir):
            logging.warning(f"Root directory for domain '{domain}' does not exist: {root_dir}")
            continue
        for root, _, files in os.walk(root_dir):
            for file in files:
                if file.lower().endswith(('.html', '.htm')):
                    filepath = os.path.join(root, file)
                    try:
                        with open(filepath, 'r', encoding='utf-8') as f:
                            soup = BeautifulSoup(f, 'html.parser')
                            title = soup.title.string.strip() if soup.title else 'No Title'
                            text = soup.get_text(separator=' ', strip=True)
                            description = text[:200] + '...' if len(text) > 200 else text

                            # Extract logo path relative to 'search/static/logos/'
                            logo_tag = soup.find("img", {"class": "site-logo"})
                            logo_path = None
                            if logo_tag and 'src' in logo_tag.attrs:
                                logo_relative = logo_tag['src'].lstrip('/')
                                logo_path = os.path.join('search', logo_relative)
                                absolute_logo_path = os.path.join(BASE_DIR, logo_path)
                                if not os.path.exists(absolute_logo_path):
                                    # Файл логотипа отсутствует, использовать дефолтный
                                    logo_path = os.path.join('search', 'logos', 'default_icon.png')
                            else:
                                logo_path = os.path.join('search', 'logos', 'default_icon.png')  # Default logo

                            if os.path.exists(os.path.join(BASE_DIR, logo_path)):
                                # Преобразуем путь к логотипу в SMP URL
                                relative_logo_path = os.path.relpath(os.path.join(BASE_DIR, logo_path), BASE_DIR).replace(os.sep, '/')
                                logo_url = f"smp://{relative_logo_path}"
                            else:
                                logo_url = "smp://search/logos/default_icon.png"

                            # Prepare SMP resource path as unique ID
                            relative_path = os.path.relpath(filepath, BASE_DIR).replace(os.sep, '/')
                            resource_path = f"smp://{relative_path}"

                            # Add document to index
                            writer.update_document(
                                url=resource_path,
                                title=title,
                                content=text,
                                description=description,
                                logo=logo_url
                            )
                            logging.info(f"Indexed: {resource_path}")
                    except Exception as e:
                        logging.error(f"Failed to index file {filepath}: {e}")
    writer.commit()
    logging.info("Finished indexing all HTML files.")

def handle_search_action(conn, query):
    """
    Handles SEARCH requests by querying the Whoosh index and returning formatted results.
    """
    logging.info(f"Search request received: '{query}'")
    from whoosh.qparser import QueryParser, MultifieldParser

    try:
        # Clean and prepare the query
        clean_query = clean_query_string(query)
        with ix.searcher() as searcher:
            parser = MultifieldParser(["title", "content"], ix.schema)
            parsed_query = parser.parse(clean_query)
            results = searcher.search(parsed_query, limit=10)
            hits = [
                {
                    'title': r['title'],
                    'url': r['url'],
                    'description': r['description'],
                    'logo': r['logo'] if r['logo'] else 'smp://search/logos/default_icon.png'  # Default logo if none
                }
                for r in results
            ]

        # Format the search results into SMP response
        results_html = generate_search_results_html(query, hits)

        content_length = len(results_html.encode('utf-8'))

        # Prepare SMP response headers
        response_headers = (
            f"SMP 1.0\n"
            f"STATUS: OK\n"
            f"CONTENT-TYPE: text/html\n"
            f"CONTENT-LENGTH: {content_length}\n\n"
        )
        conn.send(response_headers.encode())
        conn.sendall(results_html.encode('utf-8'))
        logging.info(f"Search results sent for query: '{query}'")

    except Exception as e:
        logging.error(f"Error handling search query '{query}': {e}")
        message = f"Error processing search: {e}"
        response = (
            f"SMP 1.0\n"
            f"STATUS: ERROR\n"
            f"MESSAGE: {message}\n"
            f"CONTENT-TYPE: text/plain\n"
            f"CONTENT-LENGTH: {len(message)}\n\n"
            f"{message}"
        )
        conn.sendall(response.encode())

# -----------------------------
# Client Handling
# -----------------------------

def handle_get_action(conn, resource):
    """
    Handles GET requests by serving static files or search results.
    """
    # Parse the resource URL
    parsed = urlparse('smp://' + resource)  # To utilize urlparse
    domain = parsed.hostname
    path = parsed.path.lstrip('/')  # Remove leading '/'

    logging.debug(f"Received GET request for domain: {domain}, path: {path}")

    if domain not in allowed_domains:
        message = "Domain not allowed"
        send_error(conn, message)
        logging.warning(f"Disallowed domain requested: {domain}")
        return

    # Serve static files
    domain_root = allowed_domains[domain]
    file_path = os.path.join(domain_root, path) if path else os.path.join(domain_root, 'index.html')

    logging.debug(f"Attempting to serve file: {file_path}")

    # Prevent directory traversal
    real_file_path = os.path.realpath(file_path)
    real_domain_root = os.path.realpath(domain_root)
    if not real_file_path.startswith(real_domain_root):
        message = "Invalid resource path"
        send_error(conn, message)
        logging.warning(f"Invalid resource path requested: {file_path}")
        return

    # If the path points to a directory, serve index.html
    if os.path.isdir(real_file_path):
        file_path = os.path.join(real_file_path, 'index.html')
        logging.debug(f"Path is a directory. Serving index file: {file_path}")
        if not os.path.exists(file_path):
            message = "Resource not found"
            send_error(conn, message)
            logging.warning(f"Resource not found: {file_path}")
            return

    if not os.path.exists(file_path):
        message = "Resource not found"
        send_error(conn, message)
        logging.warning(f"Resource not found: {file_path}")
        return

    send_large_file(conn, file_path)

def handle_client(conn, addr):
    """
    Handles client connections in separate threads.
    """
    logging.info(f"Client connected: {addr}")

    while True:
        try:
            data = b""
            # Receive data until headers and body are separated by double newline
            while b"\n\n" not in data:
                part = conn.recv(BUFFER_SIZE)
                if not part:
                    raise ConnectionResetError("Client closed the connection")
                data += part

            header_data, _, body = data.partition(b"\n\n")
            headers = {}
            for line in header_data.decode().split('\n'):
                if ': ' in line:
                    key, value = line.split(': ', 1)
                    headers[key.strip().upper()] = value.strip()

            action = headers.get('ACTION')
            resource = headers.get('RESOURCE')
            query = headers.get('QUERY')

            if action == 'GET' and resource:
                handle_get_action(conn, resource)
            elif action == 'SEARCH' and query:
                handle_search_action(conn, query)
            else:
                message = "Invalid ACTION or missing RESOURCE/QUERY"
                send_error(conn, message)
                logging.warning(f"Invalid request from {addr}: ACTION={action}, RESOURCE={resource}, QUERY={query}")

        except ConnectionResetError as e:
            logging.info(f"Client {addr} disconnected: {e}")
            break
        except Exception as e:
            logging.error(f"Error handling client {addr}: {e}")
            break

    conn.close()
    logging.info(f"Connection with {addr} closed")

# -----------------------------
# Server Initialization
# -----------------------------

def start_server():
    """
    Starts the SMP server to listen for incoming connections.
    """
    build_index()  # Build the search index at startup
    logging.info("Whoosh indexing completed.")

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        server_socket.bind((HOST, PORT))
        server_socket.listen()
        logging.info(f"SMP Server started on {HOST}:{PORT}")

        while True:
            conn, addr = server_socket.accept()
            client_thread = threading.Thread(target=handle_client, args=(conn, addr), daemon=True)
            client_thread.start()

if __name__ == "__main__":
    start_server()
