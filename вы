import os
import socket
import threading
import subprocess
import logging
from urllib.parse import urlparse
from flask import Flask

# Настройки сервера
HOST = '0.0.0.0'  # Слушать на всех интерфейсах
PORT = 8080
BUFFER_SIZE = 4096  # Размер буфера для передачи данных

# Настройка логирования
logging.basicConfig(
    filename='smp_server.log',
    level=logging.INFO,
    format='%(asctime)s:%(levelname)s:%(message)s'
)

# Разрешенные домены и их корневые директории
allowed_domains = {
    'example.com': 'example',
    'test.com': 'test'  # Например, папка "test" будет содержать Flask-приложение
}


def start_flask_app(domain_root):
    """Запускает Flask-приложение в папке домена"""
    flask_app = Flask(__name__)

    @flask_app.route('/')
    def home():
        return "Flask app is running!"

    flask_app.run(host='0.0.0.0', port=5000)  # Flask-приложение будет запущено на порту 5000


def handle_client(conn, addr):
    """
    Обрабатывает подключения клиентов в отдельных потоках.
    """
    logging.info(f"Подключен клиент: {addr}")

    while True:
        try:
            data = b""
            while b"\n\n" not in data:
                part = conn.recv(BUFFER_SIZE)
                if not part:
                    raise ConnectionResetError("Клиент закрыл соединение")
                data += part

            header_data, _, body = data.partition(b"\n\n")
            headers = {}
            for line in header_data.decode().split('\n'):
                if ': ' in line:
                    key, value = line.split(': ', 1)
                    headers[key.strip().upper()] = value.strip()

            action = headers.get('ACTION')
            resource = headers.get('RESOURCE')

            if action == 'GET' and resource:
                # Разбор ресурса для извлечения домена и пути
                parsed = urlparse('smp://' + resource)
                domain = parsed.hostname
                path = parsed.path.lstrip('/')

                if domain not in allowed_domains:
                    message = "Domain not allowed"
                    response = (
                        f"SMP 1.0\n"
                        f"STATUS: ERROR\n"
                        f"MESSAGE: {message}\n"
                        f"CONTENT-TYPE: text/plain\n"
                        f"CONTENT-LENGTH: {len(message)}\n\n"
                        f"{message}"
                    )
                    conn.send(response.encode())
                    logging.warning(f"Запрошен запрещенный домен: {domain}")
                    continue

                # Определение пути к файлу или запуск Flask-приложения
                domain_root = allowed_domains[domain]
                file_path = os.path.join(domain_root, path) if path else os.path.join(domain_root, 'index.html')

                # Если это папка с Flask-приложением, запускаем его
                if os.path.isdir(file_path):
                    logging.info(f"Запуск Flask-приложения для домена: {domain}")
                    start_flask_app(domain_root)
                else:
                    # Отправка файла или обработка другого запроса
                    pass

        except ConnectionResetError as e:
            logging.info(f"Клиент {addr} отключился: {e}")
            break
        except Exception as e:
            logging.error(f"Ошибка при обработке клиента {addr}: {e}")
            break

    conn.close()
    logging.info(f"Соединение с {addr} закрыто")


def start_server():
    """
    Запускает SMP сервер для прослушивания входящих подключений.
    """
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        server_socket.bind((HOST, PORT))
        server_socket.listen()
        logging.info(f"SMP Server запущен на {HOST}:{PORT}")

        while True:
            conn, addr = server_socket.accept()
            client_thread = threading.Thread(target=handle_client, args=(conn, addr), daemon=True)
            client_thread.start()


if __name__ == "__main__":
    start_server()
