// IDEDesign.cpp
#include <windows.h>
#include <gdiplus.h>
#include <wininet.h>
#include <string>
#include <vector>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <locale>
#include <codecvt>
#include <windowsx.h>

#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "comctl32.lib")

using namespace Gdiplus;

// Глобальные переменные
HINSTANCE hInst;
HWND hToolbar, hStatusbar, hEdit;

// Идентификаторы ресурсов
#define IDM_FILE_NEW    1
#define IDM_FILE_OPEN   2
#define IDM_FILE_SAVE   3
#define IDM_FILE_EXIT   4

// Прототипы функций
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
VOID OnPaint(HDC hdc);
void InitializeToolbar(HWND hWnd);
void InitializeStatusbar(HWND hWnd);

// Точка входа
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    LPSTR lpCmdLine, int nCmdShow)
{
    GdiplusStartupInput gdiplusStartupInput;
    ULONG_PTR           gdiplusToken;

    // Инициализация GDI+
    GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);

    // Сохранение дескриптора инстанции в глобальную переменную
    hInst = hInstance;

    // Регистрация класса окна
    WNDCLASSEX wcex;
    ZeroMemory(&wcex, sizeof(WNDCLASSEX));

    wcex.cbSize         = sizeof(WNDCLASSEX);
    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(NULL, IDI_APPLICATION);
    wcex.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszClassName  = L"IDEWindowClass";

    if (!RegisterClassEx(&wcex))
    {
        MessageBox(NULL,
            L"Не удалось зарегистрировать класс окна!",
            L"Ошибка",
            NULL);

        return 1;
    }

    // Создание окна
    HWND hWnd = CreateWindow(
        L"IDEWindowClass",
        L"Профессиональный дизайн IDE",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,
        1000, 700,
        NULL,
        NULL,
        hInstance,
        NULL
    );

    if (!hWnd)
    {
        MessageBox(NULL,
            L"Не удалось создать окно!",
            L"Ошибка",
            NULL);

        return 1;
    }

    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);

    // Цикл обработки сообщений
    MSG msg;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Завершение работы GDI+
    GdiplusShutdown(gdiplusToken);

    return (int)msg.wParam;
}

// Процедура окна
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_CREATE:
        {
            // Инициализация компонентов
            InitializeToolbar(hWnd);
            InitializeStatusbar(hWnd);

            // Создание редактора
            hEdit = CreateWindowEx(0, L"EDIT", NULL,
                WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_HSCROLL | ES_MULTILINE,
                0, 0, 0, 0,
                hWnd, NULL, hInst, NULL);
        }
        break;

    case WM_SIZE:
        {
            // Изменение размера панели инструментов и строки состояния
            SendMessage(hToolbar, TB_AUTOSIZE, 0, 0);
            SendMessage(hStatusbar, WM_SIZE, 0, 0);

            // Получение размеров клиентской области
            RECT rcClient;
            GetClientRect(hWnd, &rcClient);

            // Получение размеров панели инструментов и строки состояния
            RECT rcToolbar, rcStatus;
            GetWindowRect(hToolbar, &rcToolbar);
            GetWindowRect(hStatusbar, &rcStatus);

            int toolbarHeight = rcToolbar.bottom - rcToolbar.top;
            int statusHeight = rcStatus.bottom - rcStatus.top;

            // Изменение размера редактора
            MoveWindow(hEdit,
                0, toolbarHeight,
                rcClient.right,
                rcClient.bottom - toolbarHeight - statusHeight,
                TRUE);
        }
        break;

    case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
            case IDM_FILE_NEW:
                // Обработка команды "Новый файл"
                SetWindowText(hEdit, L"");
                break;
            case IDM_FILE_OPEN:
                // Обработка команды "Открыть файл"
                MessageBox(hWnd, L"Открыть файл", L"Информация", MB_OK);
                break;
            case IDM_FILE_SAVE:
                // Обработка команды "Сохранить файл"
                MessageBox(hWnd, L"Сохранить файл", L"Информация", MB_OK);
                break;
            case IDM_FILE_EXIT:
                // Обработка команды "Выход"
                PostQuitMessage(0);
                break;
            default:
                break;
            }
        }
        break;

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hWnd, &ps);
            OnPaint(hdc);
            EndPaint(hWnd, &ps);
        }
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
        break;
    }

    return 0;
}

// Функция отрисовки
VOID OnPaint(HDC hdc)
{
    // Дополнительная отрисовка при необходимости
}

// Инициализация панели инструментов
void InitializeToolbar(HWND hWnd)
{
    // Загрузка библиотеки
    INITCOMMONCONTROLSEX icex;
    icex.dwSize = sizeof(icex);
    icex.dwICC  = ICC_BAR_CLASSES;
    InitCommonControlsEx(&icex);

    // Создание панели инструментов
    hToolbar = CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
        WS_CHILD | WS_VISIBLE | TBSTYLE_FLAT | TBSTYLE_WRAPABLE,
        0, 0, 0, 0,
        hWnd, NULL, hInst, NULL);

    SendMessage(hToolbar, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0);

    // Добавление кнопок
    TBBUTTON tbb[4] = { 0 };

    tbb[0].iBitmap = STD_FILENEW;
    tbb[0].idCommand = IDM_FILE_NEW;
    tbb[0].fsState = TBSTATE_ENABLED;
    tbb[0].fsStyle = TBSTYLE_BUTTON;

    tbb[1].iBitmap = STD_FILEOPEN;
    tbb[1].idCommand = IDM_FILE_OPEN;
    tbb[1].fsState = TBSTATE_ENABLED;
    tbb[1].fsStyle = TBSTYLE_BUTTON;

    tbb[2].iBitmap = STD_FILESAVE;
    tbb[2].idCommand = IDM_FILE_SAVE;
    tbb[2].fsState = TBSTATE_ENABLED;
    tbb[2].fsStyle = TBSTYLE_BUTTON;

    tbb[3].iBitmap = STD_DELETE;
    tbb[3].idCommand = IDM_FILE_EXIT;
    tbb[3].fsState = TBSTATE_ENABLED;
    tbb[3].fsStyle = TBSTYLE_BUTTON;

    HIMAGELIST hImageList;
    HBITMAP hBitmap;

    // Загрузка стандартных изображений
    hImageList = ImageList_LoadImage(hInst, MAKEINTRESOURCE(IDB_STD_SMALL_COLOR),
        16, 0, CLR_DEFAULT, IMAGE_BITMAP, LR_CREATEDIBSECTION);

    SendMessage(hToolbar, TB_SETIMAGELIST, 0, (LPARAM)hImageList);
    SendMessage(hToolbar, TB_ADDBUTTONS, sizeof(tbb)/sizeof(TBBUTTON), (LPARAM)&tbb);
    SendMessage(hToolbar, TB_AUTOSIZE, 0, 0);
    ShowWindow(hToolbar, TRUE);
}

// Инициализация строки состояния
void InitializeStatusbar(HWND hWnd)
{
    hStatusbar = CreateWindowEx(0, STATUSCLASSNAME, NULL,
        WS_CHILD | WS_VISIBLE | SBARS_SIZEGRIP,
        0, 0, 0, 0,
        hWnd, NULL, hInst, NULL);

    int statwidths[] = { 100, -1 };
    SendMessage(hStatusbar, SB_SETPARTS, sizeof(statwidths)/sizeof(int), (LPARAM)statwidths);
    SendMessage(hStatusbar, SB_SETTEXT, 0, (LPARAM)L"Готово");
}
