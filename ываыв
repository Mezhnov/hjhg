#include <windows.h>
#include <string>
#include <vector>
#include <map>
#include <sstream>

#pragma comment (lib,"user32.lib")

// Глобальные переменные
HINSTANCE hInst;
HWND hMarkyEdit;
HWND hStylinEdit;
HWND hRunButton;
HWND hMainWnd;

struct UIElement {
    std::string type;
    std::map<std::string, std::string> attributes;
    std::vector<UIElement> children;
};

struct Style {
    std::map<std::string, std::string> properties;
};

std::vector<UIElement> uiElements;
std::map<std::string, Style> styles;

// Функции парсинга
void ParseMarky(const std::string& markyCode);
void ParseStylin(const std::string& stylinCode);

// Функция создания интерфейса
void CreateUI(HWND parent, const std::vector<UIElement>& elements);

// Вспомогательные функции
COLORREF ParseColor(const std::string& colorStr);
int ParseSize(const std::string& sizeStr);
HFONT CreateFontFromStyle(const Style& style);

// Оконные процедуры
LRESULT CALLBACK MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK UIWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Главная функция
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow) {
    hInst = hInstance;

    // Регистрация класса главного окна
    WNDCLASS wc = {};
    wc.lpfnWndProc = MainWndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = TEXT("MarkyStylinIDE");

    RegisterClass(&wc);

    // Создание главного окна
    hMainWnd = CreateWindowEx(
        0,
        wc.lpszClassName,
        TEXT("Marky & Stylin IDE"),
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 800, 600,
        nullptr,
        nullptr,
        hInstance,
        nullptr
    );

    ShowWindow(hMainWnd, nCmdShow);

    // Цикл обработки сообщений
    MSG msg = {};
    while (GetMessage(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return 0;
}

// Создание элементов управления в главном окне
void CreateControls(HWND hwnd) {
    CreateWindow(TEXT("STATIC"), TEXT("Marky Code:"),
        WS_VISIBLE | WS_CHILD,
        10, 10, 100, 20,
        hwnd, nullptr, hInst, nullptr);

    hMarkyEdit = CreateWindowEx(WS_EX_CLIENTEDGE, TEXT("EDIT"), TEXT(""),
        WS_VISIBLE | WS_CHILD | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
        10, 30, 360, 500,
        hwnd, nullptr, hInst, nullptr);

    CreateWindow(TEXT("STATIC"), TEXT("Stylin Code:"),
        WS_VISIBLE | WS_CHILD,
        380, 10, 100, 20,
        hwnd, nullptr, hInst, nullptr);

    hStylinEdit = CreateWindowEx(WS_EX_CLIENTEDGE, TEXT("EDIT"), TEXT(""),
        WS_VISIBLE | WS_CHILD | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
        380, 30, 360, 500,
        hwnd, nullptr, hInst, nullptr);

    hRunButton = CreateWindow(TEXT("BUTTON"), TEXT("Запустить"),
        WS_VISIBLE | WS_CHILD,
        10, 540, 100, 30,
        hwnd, (HMENU)1, hInst, nullptr);
}

// Оконная процедура главного окна
LRESULT CALLBACK MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg)
    {
    case WM_CREATE:
        CreateControls(hwnd);
        break;
    case WM_COMMAND:
        if (LOWORD(wParam) == 1) { // Нажата кнопка "Запустить"
            // Получаем код из контролов
            TCHAR markyBuffer[10000];
            GetWindowText(hMarkyEdit, markyBuffer, 10000);
            std::wstring wMarkyCode = markyBuffer;
            std::string markyCode(wMarkyCode.begin(), wMarkyCode.end());

            TCHAR stylinBuffer[10000];
            GetWindowText(hStylinEdit, stylinBuffer, 10000);
            std::wstring wStylinCode = stylinBuffer;
            std::string stylinCode(wStylinCode.begin(), wStylinCode.end());

            // Парсим код
            ParseMarky(markyCode);
            ParseStylin(stylinCode);

            // Создаем новое окно для отображения интерфейса
            WNDCLASS wc = {};
            wc.lpfnWndProc = UIWndProc;
            wc.hInstance = hInst;
            wc.lpszClassName = TEXT("UIWindowClass");

            RegisterClass(&wc);

            HWND hUIWindow = CreateWindowEx(
                0,
                wc.lpszClassName,
                TEXT("Результат"),
                WS_OVERLAPPEDWINDOW,
                CW_USEDEFAULT, CW_USEDEFAULT, 800, 600,
                nullptr,
                nullptr,
                hInst,
                nullptr
            );

            ShowWindow(hUIWindow, SW_SHOW);
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// Оконная процедура окна интерфейса
LRESULT CALLBACK UIWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg)
    {
    case WM_CREATE:
        CreateUI(hwnd, uiElements);
        break;
    case WM_DESTROY:
        // Очищаем элементы и стили после закрытия окна
        uiElements.clear();
        styles.clear();
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// Функция парсинга Marky
void ParseMarky(const std::string& markyCode) {
    uiElements.clear();

    std::istringstream iss(markyCode);
    std::string line;
    std::vector<UIElement*> elementStack;
    int currentIndent = 0;

    while (std::getline(iss, line)) {
        // Убираем перевод строки и пробелы в конце
        line.erase(line.find_last_not_of(" \t\r\n") + 1);
        // Пропускаем пустые строки
        if (line.empty()) continue;

        // Определяем уровень отступа
        size_t indent = 0;
        while (indent < line.length() && (line[indent] == ' ' || line[indent] == '\t')) {
            indent++;
        }

        std::string trimmedLine = line.substr(indent);
        // Создаем новый элемент
        UIElement element;
        size_t pos = trimmedLine.find('(');
        if (pos != std::string::npos) {
            element.type = trimmedLine.substr(0, pos);
            size_t endPos = trimmedLine.find(')', pos);
            if (endPos != std::string::npos) {
                std::string attrs = trimmedLine.substr(pos + 1, endPos - pos - 1);
                // Разбиваем атрибуты
                std::istringstream attrStream(attrs);
                std::string attrPair;
                while (std::getline(attrStream, attrPair, ',')) {
                    size_t eqPos = attrPair.find('=');
                    if (eqPos != std::string::npos) {
                        std::string key = attrPair.substr(0, eqPos);
                        std::string value = attrPair.substr(eqPos + 1);
                        // Убираем возможные кавычки
                        if (!value.empty() && value.front() == '"') value.erase(0, 1);
                        if (!value.empty() && value.back() == '"') value.pop_back();
                        element.attributes[key] = value;
                    }
                }
            }
            else {
                element.type = trimmedLine.substr(0, pos);
            }
        }
        else {
            element.type = trimmedLine;
        }

        // Определяем родительский элемент на основе отступа
        if (indent == currentIndent) {
            if (elementStack.empty()) {
                uiElements.push_back(element);
                elementStack.push_back(&uiElements.back());
            }
            else {
                elementStack.back()->children.push_back(element);
                elementStack.pop_back();
                elementStack.push_back(&elementStack.back()->children.back());
            }
        }
        else if (indent > currentIndent) {
            if (!elementStack.empty()) {
                elementStack.back()->children.push_back(element);
                elementStack.push_back(&elementStack.back()->children.back());
            }
            else {
                uiElements.push_back(element);
                elementStack.push_back(&uiElements.back());
            }
            currentIndent = indent;
        }
        else {
            while (currentIndent > indent && !elementStack.empty()) {
                elementStack.pop_back();
                currentIndent -= 2;
            }
            if (elementStack.empty()) {
                uiElements.push_back(element);
                elementStack.push_back(&uiElements.back());
            }
            else {
                elementStack.back()->children.push_back(element);
                elementStack.push_back(&elementStack.back()->children.back());
            }
            currentIndent = indent;
        }
    }
}

// Функция парсинга Stylin
void ParseStylin(const std::string& stylinCode) {
    styles.clear();

    std::istringstream iss(stylinCode);
    std::string line;
    std::string currentSelector;

    while (std::getline(iss, line)) {
        // Убираем перевод строки и пробелы
        line.erase(line.find_last_not_of(" \t\r\n") + 1);
        line.erase(0, line.find_first_not_of(" \t"));
        
        if (line.empty()) continue;

        // Если строка заканчивается двоеточием, это селектор
        if (line.back() == ':') {
            currentSelector = line.substr(0, line.length() - 1);
            styles[currentSelector] = Style();
        }
        else {
            // Это свойство стиля
            size_t colonPos = line.find(':');
            if (colonPos != std::string::npos) {
                std::string property = line.substr(0, colonPos);
                std::string value = line.substr(colonPos + 1);
                // Убираем пробелы
                property.erase(property.find_last_not_of(" \t") + 1);
                value.erase(0, value.find_first_not_of(" \t"));
                value.erase(value.find_last_not_of(" \t") + 1);
                styles[currentSelector].properties[property] = value;
            }
        }
    }
}

// Функция создания интерфейса на основе парсинга
void CreateUI(HWND parent, const std::vector<UIElement>& elements) {
    for (const auto& element : elements) {
        if (element.type == "Window") {
            // Настраиваем окно
            std::string title = "Window";
            int width = 800, height = 600;

            auto itTitle = element.attributes.find("title");
            if (itTitle != element.attributes.end()) {
                title = itTitle->second;
            }
            auto itSize = element.attributes.find("size");
            if (itSize != element.attributes.end()) {
                std::string sizeStr = itSize->second;
                size_t xPos = sizeStr.find('x');
                if (xPos != std::string::npos) {
                    width = atoi(sizeStr.substr(0, xPos).c_str());
                    height = atoi(sizeStr.substr(xPos + 1).c_str());
                }
            }

            SetWindowText(parent, std::wstring(title.begin(), title.end()).c_str());
            SetWindowPos(parent, nullptr, 0, 0, width, height, SWP_NOMOVE | SWP_NOZORDER);

            // Создаем дочерние элементы
            CreateUI(parent, element.children);
        }
        else {
            // Создаем контролы
            HWND hControl = nullptr;
            std::string text = "";
            int x = 10, y = 10, width = 100, height = 30;
            std::string id = "";
            std::string className = "";

            auto itText = element.attributes.find("text");
            if (itText != element.attributes.end()) {
                text = itText->second;
            }
            auto itId = element.attributes.find("id");
            if (itId != element.attributes.end()) {
                id = "@" + itId->second;
            }
            auto itClass = element.attributes.find("class");
            if (itClass != element.attributes.end()) {
                className = "." + itClass->second;
            }

            // Можно добавить обработку координат и размеров из атрибутов

            if (element.type == "Label") {
                hControl = CreateWindow(TEXT("STATIC"), std::wstring(text.begin(), text.end()).c_str(),
                    WS_VISIBLE | WS_CHILD,
                    x, y, width, height,
                    parent, nullptr, hInst, nullptr);
            }
            else if (element.type == "Button") {
                hControl = CreateWindow(TEXT("BUTTON"), std::wstring(text.begin(), text.end()).c_str(),
                    WS_VISIBLE | WS_CHILD,
                    x, y, width, height,
                    parent, nullptr, hInst, nullptr);
            }

            // Применяем стили
            Style style;

            if (!id.empty() && styles.find(id) != styles.end()) {
                style = styles[id];
            }
            else if (!className.empty() && styles.find(className) != styles.end()) {
                style = styles[className];
            }
            else if (styles.find(element.type) != styles.end()) {
                style = styles[element.type];
            }

            // Применяем стиль к контролу
            if (hControl != nullptr) {
                // Применяем шрифт
                HFONT hFont = CreateFontFromStyle(style);
                if (hFont != nullptr) {
                    SendMessage(hControl, WM_SETFONT, (WPARAM)hFont, TRUE);
                }

                // Применяем цвет фона (для статических контролов нужно обрабатывать сообщение WM_CTLCOLORSTATIC)
                // Это требует более сложной реализации и обработки сообщений дочерних окон

                // Для упрощения можно пропустить этот шаг или ограничиться базовыми элементами
            }
        }
    }
}

// Вспомогательные функции

COLORREF ParseColor(const std::string& colorStr) {
    if (colorStr[0] == '#') {
        // Цвет в формате HEX
        unsigned int rgb = 0;
        std::stringstream ss;
        ss << std::hex << colorStr.substr(1);
        ss >> rgb;
        return RGB((rgb >> 16) & 0xFF, (rgb >> 8) & 0xFF, rgb & 0xFF);
    }
    return 0;
}

int ParseSize(const std::string& sizeStr) {
    // Преобразуем строку в число
    return atoi(sizeStr.c_str());
}

HFONT CreateFontFromStyle(const Style& style) {
    int fontSize = 16; // Размер по умолчанию
    std::string fontName = "Arial"; // Шрифт по умолчанию

    auto itFontSize = style.properties.find("font-size");
    if (itFontSize != style.properties.end()) {
        fontSize = ParseSize(itFontSize->second);
    }

    return CreateFont(fontSize, 0, 0, 0, FW_NORMAL,
        FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_OUTLINE_PRECIS,
        CLIP_DEFAULT_PRECIS, CLEARTYPE_QUALITY, VARIABLE_PITCH, std::wstring(fontName.begin(), fontName.end()).c_str());
}
Window(title="Добро пожаловать", size="800x600")
  Label(text="Добро пожаловать!", id="welcomeLabel")
  Button(text="Нажми меня", id="clickButton")



Необработанное исключение по адресу 0x00007FFF1BED829C (ucrtbased.dll) в тторор.exe: Недопустимый параметр был передан функции, для которой недопустимые параметры вызывают неустранимую ошибку.
