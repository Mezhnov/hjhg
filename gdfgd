// Включаем необходимые заголовочные файлы
#include <windows.h>
#include <gdiplus.h>
#include <wininet.h>
#include <string>
#include <vector>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <locale>
#include <windowsx.h>
#include <mmsystem.h>  // Для PlaySound
#include <CommCtrl.h>  // Для common controls
#include <richedit.h>  // Для rich edit controls
#include <map>
#include <functional>  // Для std::function
#include <memory>      // Для std::shared_ptr
#include <cctype>      // Для isdigit и isalpha
#include <stack>       // Для std::stack
#include <cmath>       // Для fmod

// Линкуем необходимые библиотеки
#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "wininet.lib")
#pragma comment(lib, "comctl32.lib")
#pragma comment(lib, "Winmm.lib")
#pragma comment(lib, "UxTheme.lib")

// Определение идентификаторов
#define IDM_FILE_NEW        1001
#define IDM_FILE_OPEN       1002
#define IDM_FILE_SAVE       1003
#define IDM_FILE_EXIT       1004
#define IDM_EDIT_UNDO       2001
#define IDM_EDIT_REDO       2002
#define IDM_EDIT_CUT        2003
#define IDM_EDIT_COPY       2004
#define IDM_EDIT_PASTE      2005
#define IDM_HELP_ABOUT      3001

// Идентификаторы изображения
#define IDB_TOOLBAR_IMAGES  4001
#define IDI_APP_ICON        5001
#define IDI_FOLDER_ICON     5002

// Глобальные переменные
HINSTANCE hInst;
HWND hMainWnd;
HWND hProjectPane, hHierarchyPane, hInspectorPane, hScenePane, hGamePane, hConsolePane;

// Прототипы функций
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void CreateMenus(HWND hWnd);
void CreateToolbar(HWND hWnd);
void CreateStatusBar(HWND hWnd);
void CreateDockablePanes(HWND hWnd);

// Добавляем поддержку тем
BOOL EnableVisualStyles()
{
    HMODULE hMod = LoadLibrary(L"uxtheme.dll");
    if (hMod)
    {
        typedef HRESULT(WINAPI* SetWindowThemeFunc)(HWND, LPCWSTR, LPCWSTR);
        SetWindowThemeFunc SetWindowTheme = (SetWindowThemeFunc)GetProcAddress(hMod, "SetWindowTheme");
        if (SetWindowTheme)
        {
            SetWindowTheme(hMainWnd, L"Explorer", NULL);
            FreeLibrary(hMod);
            return TRUE;
        }
        FreeLibrary(hMod);
    }
    return FALSE;
}

int APIENTRY wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nCmdShow)
{
    hInst = hInstance;

    // Инициализируем GDI+
    Gdiplus::GdiplusStartupInput gdiplusStartupInput;
    ULONG_PTR gdiplusToken;
    Gdiplus::GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);

    // Инициализируем common controls
    INITCOMMONCONTROLSEX icex = { sizeof(INITCOMMONCONTROLSEX) };
    icex.dwICC = ICC_WIN95_CLASSES | ICC_BAR_CLASSES;
    InitCommonControlsEx(&icex);

    // Регистрируем класс окна
    WNDCLASSEX wcex = { 0 };
    wcex.cbSize = sizeof(WNDCLASSEX);
    wcex.style = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc = WndProc;
    wcex.cbClsExtra = 0;
    wcex.cbWndExtra = 0;
    wcex.hInstance = hInst;
    wcex.hIcon = LoadIcon(hInst, MAKEINTRESOURCE(IDI_APP_ICON));
    wcex.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground = CreateSolidBrush(RGB(56, 56, 56)); // Темный фон
    wcex.lpszMenuName = nullptr;
    wcex.lpszClassName = L"UnityCloneClass";
    wcex.hIconSm = LoadIcon(hInst, MAKEINTRESOURCE(IDI_APP_ICON));

    RegisterClassEx(&wcex);

    // Создаем главное окно
    hMainWnd = CreateWindowW(L"UnityCloneClass", L"Unity Clone IDE", WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, 0, 1280, 720, nullptr, nullptr, hInst, nullptr);

    if (!hMainWnd)
    {
        MessageBox(nullptr, L"Не удалось создать главное окно!", L"Ошибка", MB_OK);
        return FALSE;
    }

    // Включаем визуальные стили
    EnableVisualStyles();

    ShowWindow(hMainWnd, nCmdShow);
    UpdateWindow(hMainWnd);

    // Главный цикл сообщений
    MSG msg;
    while (GetMessage(&msg, nullptr, 0, 0))
    {
        // Если сообщение не обрабатывается, передаем его функцию перевода и отправки
        if (!IsDialogMessage(hMainWnd, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    // Завершаем GDI+
    Gdiplus::GdiplusShutdown(gdiplusToken);

    return (int)msg.wParam;
}

// Обработчик окна
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static HWND hStatusBar;

    switch (message)
    {
    case WM_CREATE:
        CreateMenus(hWnd);
        CreateToolbar(hWnd);
        CreateStatusBar(hWnd);
        CreateDockablePanes(hWnd);
        break;
    case WM_SIZE:
    {
        RECT rect;
        GetClientRect(hWnd, &rect);

        // Обновляем размер статусной строки
        SendMessage(hStatusBar, WM_SIZE, 0, 0);

        // Обновляем размеры панелей
        int width = rect.right - rect.left;
        int height = rect.bottom - rect.top - 20; // Учитываем высоту статусной строки

        int panelWidth = 250;
        int panelHeight = 200;

        MoveWindow(hProjectPane, 0, 0, panelWidth, height - panelHeight, TRUE);
        MoveWindow(hHierarchyPane, 0, height - panelHeight, panelWidth, panelHeight, TRUE);
        MoveWindow(hInspectorPane, width - panelWidth, 0, panelWidth, height, TRUE);
        MoveWindow(hScenePane, panelWidth, 0, width - 2 * panelWidth, height / 2, TRUE);
        MoveWindow(hGamePane, panelWidth, height / 2, width - 2 * panelWidth, height / 2, TRUE);
        MoveWindow(hConsolePane, 0, height - panelHeight, width, panelHeight, TRUE);
    }
    break;
    case WM_COMMAND:
    {
        int wmId = LOWORD(wParam);
        // Обработка команд меню
        switch (wmId)
        {
        case IDM_FILE_NEW:
            MessageBox(hWnd, L"Новый проект создан.", L"Файл", MB_OK);
            break;
        case IDM_FILE_OPEN:
            MessageBox(hWnd, L"Открытие проекта.", L"Файл", MB_OK);
            break;
        case IDM_FILE_SAVE:
            MessageBox(hWnd, L"Проект сохранен.", L"Файл", MB_OK);
            break;
        case IDM_FILE_EXIT:
            DestroyWindow(hWnd);
            break;
        case IDM_EDIT_UNDO:
            MessageBox(hWnd, L"Отменить действие.", L"Правка", MB_OK);
            break;
        case IDM_EDIT_REDO:
            MessageBox(hWnd, L"Повторить действие.", L"Правка", MB_OK);
            break;
        case IDM_EDIT_CUT:
            MessageBox(hWnd, L"Вырезать.", L"Правка", MB_OK);
            break;
        case IDM_EDIT_COPY:
            MessageBox(hWnd, L"Копировать.", L"Правка", MB_OK);
            break;
        case IDM_EDIT_PASTE:
            MessageBox(hWnd, L"Вставить.", L"Правка", MB_OK);
            break;
        case IDM_HELP_ABOUT:
            MessageBox(hWnd, L"Unity Clone IDE\nВерсия 1.0", L"О программе", MB_OK);
            break;
        default:
            return DefWindowProc(hWnd, message, wParam, lParam);
        }
    }
    break;
    case WM_NOTIFY:
    {
        LPNMHDR lpnmh = (LPNMHDR)lParam;
        if (lpnmh->hwndFrom == hProjectPane && lpnmh->code == NM_DBLCLK)
        {
            // Обработка двойного щелчка по элементу в панели проекта
            MessageBox(hWnd, L"Вы открыли файл из панели проекта.", L"Информация", MB_OK);
        }
    }
    break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    case WM_CTLCOLORSTATIC:
    {
        HDC hdcStatic = (HDC)wParam;
        SetBkMode(hdcStatic, TRANSPARENT);
        SetTextColor(hdcStatic, RGB(220, 220, 220)); // Светлый текст
        return (INT_PTR)CreateSolidBrush(RGB(56, 56, 56)); // Темный фон
    }
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

// Создание меню
void CreateMenus(HWND hWnd)
{
    HMENU hMenuBar = CreateMenu();

    HMENU hFileMenu = CreateMenu();
    HMENU hEditMenu = CreateMenu();
    HMENU hWindowMenu = CreateMenu();
    HMENU hHelpMenu = CreateMenu();

    AppendMenu(hFileMenu, MF_STRING, IDM_FILE_NEW, L"&New Project\tCtrl+N");
    AppendMenu(hFileMenu, MF_STRING, IDM_FILE_OPEN, L"&Open Project...\tCtrl+O");
    AppendMenu(hFileMenu, MF_STRING, IDM_FILE_SAVE, L"&Save Project\tCtrl+S");
    AppendMenu(hFileMenu, MF_SEPARATOR, 0, nullptr);
    AppendMenu(hFileMenu, MF_STRING, IDM_FILE_EXIT, L"E&xit");

    AppendMenu(hEditMenu, MF_STRING, IDM_EDIT_UNDO, L"&Undo\tCtrl+Z");
    AppendMenu(hEditMenu, MF_STRING, IDM_EDIT_REDO, L"&Redo\tCtrl+Y");
    AppendMenu(hEditMenu, MF_SEPARATOR, 0, nullptr);
    AppendMenu(hEditMenu, MF_STRING, IDM_EDIT_CUT, L"Cu&t\tCtrl+X");
    AppendMenu(hEditMenu, MF_STRING, IDM_EDIT_COPY, L"&Copy\tCtrl+C");
    AppendMenu(hEditMenu, MF_STRING, IDM_EDIT_PASTE, L"&Paste\tCtrl+V");

    AppendMenu(hHelpMenu, MF_STRING, IDM_HELP_ABOUT, L"&About");

    AppendMenu(hMenuBar, MF_POPUP, (UINT_PTR)hFileMenu, L"&File");
    AppendMenu(hMenuBar, MF_POPUP, (UINT_PTR)hEditMenu, L"&Edit");
    AppendMenu(hMenuBar, MF_POPUP, (UINT_PTR)hWindowMenu, L"&Window");
    AppendMenu(hMenuBar, MF_POPUP, (UINT_PTR)hHelpMenu, L"&Help");

    SetMenu(hWnd, hMenuBar);
}

// Создание панели инструментов
void CreateToolbar(HWND hWnd)
{
    TBBUTTON tbb[3];
    TBADDBITMAP tbab;

    HWND hToolbar = CreateWindowEx(0, TOOLBARCLASSNAME, nullptr,
        WS_CHILD | WS_VISIBLE | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS,
        0, 0, 0, 0, hWnd, nullptr, hInst, nullptr);

    SendMessage(hToolbar, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0);

    tbab.hInst = hInst;
    tbab.nID = IDB_TOOLBAR_IMAGES;

    SendMessage(hToolbar, TB_ADDBITMAP, 3, (LPARAM)&tbab);

    ZeroMemory(tbb, sizeof(tbb));

    tbb[0].iBitmap = 0;
    tbb[0].idCommand = IDM_FILE_NEW;
    tbb[0].fsState = TBSTATE_ENABLED;
    tbb[0].fsStyle = TBSTYLE_BUTTON;
    tbb[0].iString = (INT_PTR)L"New";

    tbb[1].iBitmap = 1;
    tbb[1].idCommand = IDM_FILE_OPEN;
    tbb[1].fsState = TBSTATE_ENABLED;
    tbb[1].fsStyle = TBSTYLE_BUTTON;
    tbb[1].iString = (INT_PTR)L"Open";

    tbb[2].iBitmap = 2;
    tbb[2].idCommand = IDM_FILE_SAVE;
    tbb[2].fsState = TBSTATE_ENABLED;
    tbb[2].fsStyle = TBSTYLE_BUTTON;
    tbb[2].iString = (INT_PTR)L"Save";

    SendMessage(hToolbar, TB_ADDBUTTONS, 3, (LPARAM)&tbb);
}

// Создание статусной строки
void CreateStatusBar(HWND hWnd)
{
    HWND hStatus = CreateWindowEx(0, STATUSCLASSNAME, nullptr,
        WS_CHILD | WS_VISIBLE | SBARS_SIZEGRIP,
        0, 0, 0, 0, hWnd, (HMENU)1, hInst, nullptr);

    int statwidths[] = { 100, -1 };
    SendMessage(hStatus, SB_SETPARTS, sizeof(statwidths) / sizeof(int), (LPARAM)statwidths);
    SendMessage(hStatus, SB_SETTEXT, 0, (LPARAM)L"Готово");

    // Сохраняем handle статусной строки для обновления в WndProc
    SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)hStatus);
}

// Создание докируемых панелей
void CreateDockablePanes(HWND hWnd)
{
    // Размеры окна
    RECT rect;
    GetClientRect(hWnd, &rect);

    int width = rect.right - rect.left;
    int height = rect.bottom - rect.top - 20; // Учитываем высоту статусной строки
    int panelWidth = 250;
    int panelHeight = 200;

    // Создаем окно списка для панели "Project"
    hProjectPane = CreateWindowEx(WS_EX_CLIENTEDGE, WC_LISTVIEW, nullptr,
        WS_CHILD | WS_VISIBLE | LVS_REPORT | LVS_ICON,
        0, 0, panelWidth, height - panelHeight,
        hWnd, (HMENU)2, hInst, nullptr);

    // Настраиваем список панели "Project"
    HIMAGELIST hImageList;
    hImageList = ImageList_Create(32, 32, ILC_COLOR32, 1, 1);
    HICON hIcon = LoadIcon(hInst, MAKEINTRESOURCE(IDI_FOLDER_ICON));
    ImageList_AddIcon(hImageList, hIcon);
    SendMessage(hProjectPane, LVM_SETIMAGELIST, LVSIL_NORMAL, (LPARAM)hImageList);

    LVITEM lvItem = { 0 };
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
    lvItem.iItem = 0;
    lvItem.pszText == L"Assets";
    lvItem.iImage = 0;
    SendMessage(hProjectPane, LVM_INSERTITEM, 0, (LPARAM)&lvItem);

    lvItem.iItem = 1;
    lvItem.pszText == L"Scripts";
    lvItem.iImage = 0;
    SendMessage(hProjectPane, LVM_INSERTITEM, 0, (LPARAM)&lvItem);

    // Создаем окно дерева для панели "Hierarchy"
    hHierarchyPane = CreateWindowEx(WS_EX_CLIENTEDGE, WC_TREEVIEW, nullptr,
        WS_CHILD | WS_VISIBLE | TVS_HASLINES | TVS_HASBUTTONS,
        0, height - panelHeight, panelWidth, panelHeight,
        hWnd, (HMENU)3, hInst, nullptr);

    // Добавляем элементы в дерево
    TVINSERTSTRUCT tvInsert = { 0 };
    tvInsert.hParent = TVI_ROOT;
    tvInsert.hInsertAfter = TVI_LAST;
    tvInsert.item.mask = TVIF_TEXT;
    tvInsert.item.pszText == L"Main Camera";
    HTREEITEM hCamera = (HTREEITEM)SendMessage(hHierarchyPane, TVM_INSERTITEM, 0, (LPARAM)&tvInsert);

    tvInsert.item.pszText == L"Directional Light";
    HTREEITEM hLight = (HTREEITEM)SendMessage(hHierarchyPane, TVM_INSERTITEM, 0, (LPARAM)&tvInsert);

    // Создаем статический контрол для панели "Inspector"
    hInspectorPane = CreateWindowEx(WS_EX_CLIENTEDGE, L"STATIC", L"Inspector Pane",
        WS_CHILD | WS_VISIBLE | SS_LEFT,
        width - panelWidth, 0, panelWidth, height,
        hWnd, (HMENU)4, hInst, nullptr);

    // Создаем статический контрол для панели "Scene"
    hScenePane = CreateWindowEx(WS_EX_CLIENTEDGE, L"STATIC", L"Scene Pane",
        WS_CHILD | WS_VISIBLE | SS_LEFT,
        panelWidth, 0, width - 2 * panelWidth, height / 2,
        hWnd, (HMENU)5, hInst, nullptr);

    // Создаем статический контрол для панели "Game"
    hGamePane = CreateWindowEx(WS_EX_CLIENTEDGE, L"STATIC", L"Game Pane",
        WS_CHILD | WS_VISIBLE | SS_LEFT,
        panelWidth, height / 2, width - 2 * panelWidth, height / 2,
        hWnd, (HMENU)6, hInst, nullptr);

    // Создаем окно списка для панели "Console"
    hConsolePane = CreateWindowEx(WS_EX_CLIENTEDGE, WC_LISTBOX, nullptr,
        WS_CHILD | WS_VISIBLE | LBS_NOINTEGRALHEIGHT,
        0, height - panelHeight, width, panelHeight,
        hWnd, (HMENU)7, hInst, nullptr);

    // Добавляем сообщения в консоль
    SendMessage(hConsolePane, LB_ADDSTRING, 0, (LPARAM)L"Console initialized.");
}

// Остальная часть кода...
