import socket
import threading
import logging
import os
from urllib.parse import urlparse, parse_qs
import sqlite3
import re

# Настройки сервера
HOST = '0.0.0.0'  # Слушать на всех интерфейсах
PORT = 8080
BUFFER_SIZE = 4096  # Размер буфера для передачи данных

# Настройка логирования
logging.basicConfig(
    filename='smp_server.log',
    level=logging.INFO,
    format='%(asctime)s:%(levelname)s:%(message)s'
)

# Разрешенные домены и их корневые директории
allowed_domains = {
    'example.com': 'sites/example',
    'test.com': 'sites/test'
}

# Initialize or connect to the search index database
def init_search_index():
    conn = sqlite3.connect('search_index/index.db')
    c = conn.cursor()
    c.execute('''
        CREATE TABLE IF NOT EXISTS pages (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            domain TEXT,
            path TEXT,
            title TEXT,
            description TEXT,
            content TEXT
        )
    ''')
    c.execute('''
        CREATE VIRTUAL TABLE IF NOT EXISTS pages_fts USING fts5(
            title,
            description,
            content,
            content='pages',
            content_rowid='id'
        )
    ''')
    conn.commit()
    return conn

search_conn = init_search_index()

# Function to index a page
def index_page(domain, path, title, description, content):
    c = search_conn.cursor()
    c.execute('''
        INSERT INTO pages (domain, path, title, description, content)
        VALUES (?, ?, ?, ?, ?)
    ''', (domain, path, title, description, content))
    page_id = c.lastrowid
    c.execute('''
        INSERT INTO pages_fts (rowid, title, description, content)
        VALUES (?, ?, ?, ?)
    ''', (page_id, title, description, content))
    search_conn.commit()

# Function to perform search
def search(query):
    c = search_conn.cursor()
    c.execute('''
        SELECT pages.domain, pages.path, pages.title, pages.description
        FROM pages_fts
        JOIN pages ON pages_fts.rowid = pages.id
        WHERE pages_fts MATCH ?
        LIMIT 10
    ''', (query,))
    results = c.fetchall()
    return results

# Function to parse and index all pages in allowed domains
def build_search_index():
    for domain, root in allowed_domains.items():
        for root_dir, dirs, files in os.walk(root):
            for file in files:
                if file.endswith(('.html', '.htm')):
                    file_path = os.path.join(root_dir, file)
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                        title_match = re.search(r'<title>(.*?)</title>', content, re.IGNORECASE)
                        title = title_match.group(1) if title_match else 'No Title'
                        description_match = re.search(r'<meta name="description" content="(.*?)"', content, re.IGNORECASE)
                        description = description_match.group(1) if description_match else 'No Description'
                        relative_path = os.path.relpath(file_path, root)
                        index_page(domain, relative_path, title, description, content)
    logging.info("Search index built successfully.")

# Initially build the search index
build_search_index()

def send_large_file(conn, filepath):
    """
    Отправляет файл клиенту частями с соответствующими заголовками.
    """
    if not os.path.exists(filepath):
        logging.error(f"Файл не найден: {filepath}")
        message = "File not found"
        response = (
            f"SMP 1.0\n"
            f"STATUS: ERROR\n"
            f"MESSAGE: {message}\n"
            f"CONTENT-TYPE: text/plain\n"
            f"CONTENT-LENGTH: {len(message)}\n\n"
            f"{message}"
        )
        conn.sendall(response.encode())
        return

    try:
        file_size = os.path.getsize(filepath)
        _, ext = os.path.splitext(filepath)
        ext = ext.lower()
        if ext in ['.html', '.htm']:
            content_type = 'text/html'
        elif ext == '.css':
            content_type = 'text/css'
        elif ext == '.png':
            content_type = 'image/png'
        elif ext in ['.jpg', '.jpeg']:
            content_type = 'image/jpeg'
        elif ext == '.gif':
            content_type = 'image/gif'
        elif ext == '.js':
            content_type = 'application/javascript'
        else:
            content_type = 'application/octet-stream'

        # Отправка заголовков
        response_headers = (
            f"SMP 1.0\n"
            f"STATUS: OK\n"
            f"CONTENT-TYPE: {content_type}\n"
            f"CONTENT-LENGTH: {file_size}\n\n"
        )
        conn.send(response_headers.encode())
        logging.info(f"Отправка файла: {filepath}")

        # Отправка файла частями
        with open(filepath, 'rb') as f:
            while True:
                chunk = f.read(BUFFER_SIZE)
                if not chunk:
                    break
                conn.sendall(chunk)
        logging.info(f"Файл отправлен: {filepath}")

    except Exception as e:
        logging.error(f"Ошибка при отправке файла {filepath}: {e}")
        message = f"Error sending file: {e}"
        response = (
            f"SMP 1.0\n"
            f"STATUS: ERROR\n"
            f"MESSAGE: {message}\n"
            f"CONTENT-TYPE: text/plain\n"
            f"CONTENT-LENGTH: {len(message)}\n\n"
            f"{message}"
        )
        conn.sendall(response.encode())

def handle_search(conn, query):
    """
    Обрабатывает запросы поиска и возвращает результаты.
    """
    results = search(query)
    # Build HTML response
    html = "<html><head><title>Search Results</title></head><body>"
    html += f"<h1>Search Results for '{query}'</h1>"
    if results:
        html += "<ul>"
        for domain, path, title, description in results:
            link = f"smp://{domain}/{path}"
            html += f"<li>"
            html += f"<h2>{title}</h2>"
            html += f"<p>{description}</p>"
            html += f"<a href='{link}'>Visit</a>"
            html += f"</li>"
        html += "</ul>"
    else:
        html += "<p>No results found.</p>"
    html += "</body></html>"

    response = (
        f"SMP 1.0\n"
        f"STATUS: OK\n"
        f"CONTENT-TYPE: text/html\n"
        f"CONTENT-LENGTH: {len(html.encode())}\n\n"
        f"{html}"
    )
    conn.send(response.encode())
    logging.info(f"Отправлены результаты поиска для запроса: {query}")

def handle_client(conn, addr):
    """
    Обрабатывает подключения клиентов в отдельных потоках.
    """
    logging.info(f"Подключен клиент: {addr}")

    while True:
        try:
            data = b""
            while b"\n\n" not in data:
                part = conn.recv(BUFFER_SIZE)
                if not part:
                    raise ConnectionResetError("Клиент закрыл соединение")
                data += part

            header_data, _, body = data.partition(b"\n\n")
            headers = {}
            for line in header_data.decode().split('\n'):
                if ': ' in line:
                    key, value = line.split(': ', 1)
                    headers[key.strip().upper()] = value.strip()

            action = headers.get('ACTION')
            resource = headers.get('RESOURCE')

            if action == 'GET' and resource:
                # Check if it's a search request
                if resource.startswith('search?'):
                    query_params = parse_qs(urlparse(resource).query)
                    query = query_params.get('q', [''])[0]
                    handle_search(conn, query)
                    continue

                # Parse resource to extract domain and path
                parsed = urlparse('smp://' + resource)  # For using urlparse
                domain = parsed.hostname
                path = parsed.path.lstrip('/')  # Remove leading '/'

                if domain not in allowed_domains:
                    message = "Domain not allowed"
                    response = (
                        f"SMP 1.0\n"
                        f"STATUS: ERROR\n"
                        f"MESSAGE: {message}\n"
                        f"CONTENT-TYPE: text/plain\n"
                        f"CONTENT-LENGTH: {len(message)}\n\n"
                        f"{message}"
                    )
                    conn.send(response.encode())
                    logging.warning(f"Запрошен запрещенный домен: {domain}")
                    continue

                # Determine the file path
                domain_root = allowed_domains[domain]
                file_path = os.path.join(domain_root, path) if path else os.path.join(domain_root, 'index.html')

                # Prevent directory traversal
                real_file_path = os.path.realpath(file_path)
                real_domain_root = os.path.realpath(domain_root)
                if not real_file_path.startswith(real_domain_root):
                    message = "Invalid resource path"
                    response = (
                        f"SMP 1.0\n"
                        f"STATUS: ERROR\n"
                        f"MESSAGE: {message}\n"
                        f"CONTENT-TYPE: text/plain\n"
                        f"CONTENT-LENGTH: {len(message)}\n\n"
                        f"{message}"
                    )
                    conn.send(response.encode())
                    logging.warning(f"Некорректный путь ресурса: {file_path}")
                    continue

                # If path points to a directory, send index.html
                if os.path.isdir(file_path):
                    file_path = os.path.join(file_path, 'index.html')
                if os.path.exists(file_path):
                    send_large_file(conn, file_path)
                else:
                    # Resource not found
                    message = "Resource not found"
                    response = (
                        f"SMP 1.0\n"
                        f"STATUS: ERROR\n"
                        f"MESSAGE: {message}\n"
                        f"CONTENT-TYPE: text/plain\n"
                        f"CONTENT-LENGTH: {len(message)}\n\n"
                        f"{message}"
                    )
                    conn.send(response.encode())
                    logging.warning(f"Ресурс не найден: {file_path}")

            else:
                message = "Invalid ACTION or missing RESOURCE"
                response = (
                    f"SMP 1.0\n"
                    f"STATUS: ERROR\n"
                    f"MESSAGE: {message}\n"
                    f"CONTENT-TYPE: text/plain\n"
                    f"CONTENT-LENGTH: {len(message)}\n\n"
                    f"{message}"
                )
                conn.send(response.encode())
                logging.warning(f"Некорректный запрос: ACTION={action}, RESOURCE={resource}")

        except ConnectionResetError as e:
            logging.info(f"Клиент {addr} отключился: {e}")
            break
        except Exception as e:
            logging.error(f"Ошибка при обработке клиента {addr}: {e}")
            break

    conn.close()
    logging.info(f"Соединение с {addr} закрыто")

def start_server():
    """
    Запускает SMP сервер для прослушивания входящих подключений.
    """
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        server_socket.bind((HOST, PORT))
        server_socket.listen()
        logging.info(f"SMP Server запущен на {HOST}:{PORT}")

        while True:
            conn, addr = server_socket.accept()
            client_thread = threading.Thread(target=handle_client, args=(conn, addr), daemon=True)
            client_thread.start()

if __name__ == "__main__":
    start_server()
