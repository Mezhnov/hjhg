// Include necessary headers
#include <windows.h>
#include <commctrl.h>
#include <tchar.h>
#include <vector>

#pragma comment(lib, "comctl32.lib")

// Define IDs for controls
#define ID_TAB_CONTROL 1001
#define ID_FILE_PANEL  1002

// Structure to hold tab information
struct TabInfo {
    TCHAR fileName[MAX_PATH];
};

// Global variables
std::vector<TabInfo> tabInfos;
HWND hMainWnd;

// Function prototypes
void AddNewFile(HWND hWnd, const TCHAR* szFileName);
void AddNewTab(HWND hTabCtrl, const TCHAR* szFileName);
void UpdateFilePanel(HWND hFilePanel);
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

// Custom drawing function for tabs
void InitializeCustomTabControl(HWND hTabCtrl);
LRESULT CALLBACK TabCtrlProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Original tab control procedure
WNDPROC OriginalTabCtrlProc;

// Entry point
int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                       LPTSTR lpCmdLine, int nCmdShow)
{
    // Register window class, create window, etc. (omitted for brevity)
    // ...

    // Initialize common controls
    INITCOMMONCONTROLSEX icex = { sizeof(INITCOMMONCONTROLSEX) };
    icex.dwICC = ICC_TAB_CLASSES;
    InitCommonControlsEx(&icex);

    // Create main window (hMainWnd)
    // ...

    // Message loop
    MSG msg;
    while (GetMessage(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int)msg.wParam;
}

// Main window procedure
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_CREATE:
    {
        // Create tab control
        HWND hTabCtrl = CreateWindow(WC_TABCONTROL, NULL,
            WS_CHILD | WS_VISIBLE | TCS_OWNERDRAWFIXED,
            0, 0, 400, 200, hWnd, (HMENU)ID_TAB_CONTROL, GetModuleHandle(NULL), NULL);

        // Initialize custom drawing
        InitializeCustomTabControl(hTabCtrl);

        // Create file panel
        HWND hFilePanel = CreateWindowEx(0, WC_STATIC, _T("File Panel"),
            WS_CHILD | WS_VISIBLE | SS_LEFT,
            0, 210, 400, 200, hWnd, (HMENU)ID_FILE_PANEL, GetModuleHandle(NULL), NULL);

        break;
    }
    case WM_COMMAND:
        // Handle menu commands, button clicks, etc.
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

// Function to add a new file
void AddNewFile(HWND hWnd, const TCHAR* szFileName)
{
    // Add new file to the tabs
    HWND hTabCtrl = GetDlgItem(hWnd, ID_TAB_CONTROL);

    TabInfo newTab;
    _tcscpy_s(newTab.fileName, MAX_PATH, szFileName);
    tabInfos.push_back(newTab);

    AddNewTab(hTabCtrl, newTab.fileName);

    // Update the file panel to show the new file
    HWND hFilePanel = GetDlgItem(hWnd, ID_FILE_PANEL);
    UpdateFilePanel(hFilePanel);
}

// Function to add a new tab with custom design
void AddNewTab(HWND hTabCtrl, const TCHAR* szFileName)
{
    TCITEM tie;
    tie.mask = TCIF_TEXT;
    tie.pszText = const_cast<LPTSTR>(szFileName);

    TabCtrl_InsertItem(hTabCtrl, tabInfos.size() - 1, &tie);

    // Redraw the tab control to apply custom colors
    InvalidateRect(hTabCtrl, NULL, TRUE);
}

// Function to update the file panel
void UpdateFilePanel(HWND hFilePanel)
{
    // For demonstration, we'll just update the text
    if (!tabInfos.empty()) {
        const TCHAR* currentFile = tabInfos.back().fileName;
        SetWindowText(hFilePanel, currentFile);
    }
}

// Function to initialize custom drawing for tab control
void InitializeCustomTabControl(HWND hTabCtrl)
{
    // Subclass the tab control
    OriginalTabCtrlProc = (WNDPROC)SetWindowLongPtr(hTabCtrl, GWLP_WNDPROC, (LONG_PTR)TabCtrlProc);
}

// Custom window procedure for tab control
LRESULT CALLBACK TabCtrlProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {
    case WM_DRAWITEM:
    {
        LPDRAWITEMSTRUCT lpDrawItem = (LPDRAWITEMSTRUCT)lParam;
        // Custom drawing code (not needed here since we handle WM_PAINT)
        return TRUE;
    }
    case WM_ERASEBKGND:
        return TRUE; // Prevent flickering
    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);

        // Get the number of tabs
        int tabCount = TabCtrl_GetItemCount(hwnd);

        for (int i = 0; i < tabCount; ++i) {
            RECT rect;
            TabCtrl_GetItemRect(hwnd, i, &rect);

            BOOL isSelected = (TabCtrl_GetCurSel(hwnd) == i);

            // Set colors
            COLORREF bgColor = isSelected ? RGB(66, 133, 244) : RGB(255, 255, 255);
            COLORREF textColor = isSelected ? RGB(255, 255, 255) : RGB(0, 0, 0);

            // Fill background
            HBRUSH hBrush = CreateSolidBrush(bgColor);
            FillRect(hdc, &rect, hBrush);
            DeleteObject(hBrush);

            // Draw text
            TCITEM tie;
            TCHAR szText[MAX_PATH];
            tie.mask = TCIF_TEXT;
            tie.pszText = szText;
            tie.cchTextMax = MAX_PATH;
            TabCtrl_GetItem(hwnd, i, &tie);

            SetTextColor(hdc, textColor);
            SetBkMode(hdc, TRANSPARENT);
            DrawText(hdc, szText, -1, &rect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
        }

        EndPaint(hwnd, &ps);
        return 0;
    }
    default:
        break;
    }
    return CallWindowProc(OriginalTabCtrlProc, hwnd, msg, wParam, lParam);
}
