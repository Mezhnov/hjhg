// SimpleBrowser.cpp
// A simplified multi-tabbed browser using C++, Win32 API, GDI+, and WinInet

#include <windows.h>
#include <windowsx.h> // Для макросов GET_X_LPARAM и GET_Y_LPARAM
#include <gdiplus.h>
#include <wininet.h>
#include <string>
#include <vector>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <locale>
#include <codecvt>
#include <thread>
#include <mutex>
#include <iostream>

#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "wininet.lib")

using namespace Gdiplus;

// Константы
const wchar_t CLASS_NAME[] = L"SimpleBrowserWindowClass";
const int WINDOW_WIDTH = 1280;
const int WINDOW_HEIGHT = 720;

const int NAVBAR_HEIGHT = 40;
const int TABBAR_HEIGHT = 30;
const int TAB_PADDING = 10;
const int TAB_SPACING = 5;
const int TAB_WIDTH = 150;
const int TAB_CLOSE_BUTTON_SIZE = 12;
const int ADDRESSBAR_PADDING = 5;

// Декларации функций
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Вспомогательная функция для преобразования std::wstring в std::string
std::string WStringToString(const std::wstring& wstr) {
    std::wstring_convert<std::codecvt_utf8<wchar_t>> conv;
    return conv.to_bytes(wstr);
}

// Структура для хранения информации о вкладке
struct Tab {
    std::wstring url;
    std::wstring htmlContent;
    RECT tabRect;
    bool loading;

    Tab(const std::wstring& u = L"https://www.example.com") : url(u), htmlContent(L"Loading..."), loading(true) {}
};

// Глобальные переменные
std::vector<Tab> tabs;
int currentTab = 0;
std::mutex tabsMutex;

// Токен GDI+
ULONG_PTR gdiplusToken;

// Функция инициализации GDI+
bool InitGDIPlus() {
    GdiplusStartupInput input;
    return GdiplusStartup(&gdiplusToken, &input, NULL) == Ok;
}

// Функция завершения работы GDI+
void ShutdownGDIPlus() {
    GdiplusShutdown(gdiplusToken);
}

// Функция для получения HTML-контента с помощью WinInet
bool FetchHTML(const std::wstring& url, std::wstring& htmlContent) {
    HINTERNET hInternet = InternetOpen(L"SimpleBrowser", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    if (!hInternet) {
        std::cerr << "InternetOpen failed" << std::endl;
        return false;
    }

    // Открываем URL с необходимыми флагами
    HINTERNET hConnect = InternetOpenUrl(hInternet, url.c_str(), NULL, 0, INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE, 0);
    if (!hConnect) {
        std::cerr << "InternetOpenUrl failed: " << WStringToString(url) << std::endl;
        InternetCloseHandle(hInternet);
        return false;
    }

    // Читаем все данные
    std::vector<BYTE> buffer;
    DWORD bytesAvailable = 0;
    DWORD bytesRead = 0;
    BYTE tempBuffer[4096];
    while (InternetQueryDataAvailable(hConnect, &bytesAvailable, 0, 0) && bytesAvailable > 0) {
        DWORD toRead = min(bytesAvailable, (DWORD)sizeof(tempBuffer));
        if (InternetReadFile(hConnect, tempBuffer, toRead, &bytesRead) && bytesRead > 0) {
            buffer.insert(buffer.end(), tempBuffer, tempBuffer + bytesRead);
        }
        else {
            break;
        }
    }

    InternetCloseHandle(hConnect);
    InternetCloseHandle(hInternet);

    if (buffer.empty()) {
        std::cerr << "No data downloaded from URL: " << WStringToString(url) << std::endl;
        return false;
    }

    // Преобразуем буфер из UTF-8 в std::wstring
    int size_needed = MultiByteToWideChar(CP_UTF8, 0, (const char*)buffer.data(), buffer.size(), NULL, 0);
    std::wstring wstr(size_needed, 0);
    MultiByteToWideChar(CP_UTF8, 0, (const char*)buffer.data(), buffer.size(), &wstr[0], size_needed);
    htmlContent = wstr;

    return true;
}

// Функция для добавления новой вкладки
void AddNewTab(const std::wstring& url = L"https://www.example.com") {
    std::lock_guard<std::mutex> lock(tabsMutex);
    tabs.emplace_back(url);
    currentTab = tabs.size() - 1;

    // Загружаем HTML-контент в отдельном потоке для избежания блокировки UI
    std::thread([=]() {
        std::wstring content;
        bool success = FetchHTML(url, content);

        {
            std::lock_guard<std::mutex> lock(tabsMutex);
            if (currentTab < tabs.size()) {
                tabs[currentTab].htmlContent = success ? content : L"Failed to load content.";
                tabs[currentTab].loading = false;
            }
        }

        // Обновляем окно для перерисовки
        HWND hwndTarget = FindWindow(CLASS_NAME, L"Simple C++ Browser");
        if (hwndTarget) {
            InvalidateRect(hwndTarget, NULL, TRUE);
        }
    }).detach();
}

// Функция для закрытия вкладки
void CloseTab(int index) {
    std::lock_guard<std::mutex> lock(tabsMutex);
    if (index >= 0 && index < tabs.size()) {
        tabs.erase(tabs.begin() + index);
        if (currentTab >= tabs.size()) {
            currentTab = tabs.empty() ? 0 : tabs.size() - 1;
        }
    }

    // Обновляем окно для перерисовки
    HWND hwndTarget = FindWindow(CLASS_NAME, L"Simple C++ Browser");
    if (hwndTarget) {
        InvalidateRect(hwndTarget, NULL, TRUE);
    }
}

// Функция для обновления контента вкладки
void UpdateTabContent(int index, const std::wstring& url) {
    std::lock_guard<std::mutex> lock(tabsMutex);
    if (index >= 0 && index < tabs.size()) {
        tabs[index].url = url;
        tabs[index].htmlContent = L"Loading...";
        tabs[index].loading = true;

        // Загружаем контент в отдельном потоке
        std::thread([=]() {
            std::wstring content;
            bool success = FetchHTML(url, content);

            {
                std::lock_guard<std::mutex> lock(tabsMutex);
                if (index < tabs.size()) {
                    tabs[index].htmlContent = success ? content : L"Failed to load content.";
                    tabs[index].loading = false;
                }
            }

            // Обновляем окно для перерисовки
            HWND hwndTarget = FindWindow(CLASS_NAME, L"Simple C++ Browser");
            if (hwndTarget) {
                InvalidateRect(hwndTarget, NULL, TRUE);
            }
        }).detach();
    }
}

// Функция для получения текущего времени в строковом формате
std::wstring GetCurrentTimeString() {
    using namespace std::chrono;
    auto now = system_clock::now();
    std::time_t now_c = system_clock::to_time_t(now);
    std::tm parts;

    // Потокобезопасная альтернатива localtime
    localtime_s(&parts, &now_c);

    std::wstringstream ss;
    ss << std::put_time(&parts, L"%H:%M");
    return ss.str();
}

// Функция рисования вкладок
void DrawTabs(Graphics& graphics, RECT clientRect) {
    FontFamily fontFamily(L"Segoe UI");
    Font font(&fontFamily, 12, FontStyleRegular, UnitPixel);
    SolidBrush activeBrush(Color(255, 200, 200, 200)); // Светло-серый для активной вкладки
    SolidBrush inactiveBrush(Color(255, 160, 160, 160)); // Темнее серый для неактивных вкладок
    SolidBrush textBrush(Color(255, 0, 0, 0)); // Чёрный текст
    Pen closePen(Color(255, 0, 0, 0));
    closePen.SetWidth(2);

    // Рисуем фон области вкладок
    graphics.FillRectangle(&SolidBrush(Color(255, 240, 240, 240)), RectF(0, 0, (REAL)clientRect.right, (REAL)TABBAR_HEIGHT));

    int x = TAB_PADDING;

    for (size_t i = 0; i < tabs.size(); ++i) {
        Tab& tab = tabs[i];

        // Измеряем ширину текста
        RectF layoutRect((REAL)x + 5, 5, 140, TABBAR_HEIGHT - 10);
        StringFormat format;
        format.SetTrimming(StringTrimmingEllipsisCharacter);
        RectF measuredRect;
        FontMetrics fm;
        font.GetMetrics(&fm);
        int textHeight = fm.height;

        // Выбираем цвет заливки вкладки
        SolidBrush* tabBrush = (i == currentTab) ? &activeBrush : &inactiveBrush;
        graphics.FillRectangle(tabBrush, RectF((REAL)x, 0, (REAL)TAB_WIDTH, (REAL)TABBAR_HEIGHT));

        // Рисуем текст вкладки
        graphics.DrawString(tab.url.c_str(), -1, &font, layoutRect, &format, &textBrush);

        // Рисуем кнопку закрытия ('X')
        graphics.DrawLine(&closePen, (REAL)x + TAB_WIDTH - TAB_CLOSE_BUTTON_SIZE - 5, 10, (REAL)x + TAB_WIDTH - 5, 20);
        graphics.DrawLine(&closePen, (REAL)x + TAB_WIDTH - 5, 10, (REAL)x + TAB_WIDTH - TAB_CLOSE_BUTTON_SIZE - 5, 20);

        // Устанавливаем прямоугольник вкладки для обработки кликов
        tab.tabRect = { x, 0, x + TAB_WIDTH, TABBAR_HEIGHT };

        x += TAB_WIDTH + TAB_SPACING;
    }

    // Рисуем кнопку "+" для новой вкладки
    Font plusFont(&fontFamily, 16, FontStyleBold, UnitPixel);
    StringFormat plusFormat;
    plusFormat.SetAlignment(StringAlignmentCenter);
    plusFormat.SetLineAlignment(StringAlignmentCenter);
    SolidBrush plusBrush(Color(255, 0, 128, 0)); // Зелёный плюс
    SolidBrush plusBackgroundBrush(Color(255, 220, 220, 220)); // Серый фон для "+"
    graphics.FillRectangle(&plusBackgroundBrush, RectF((REAL)x, 0, 30, TABBAR_HEIGHT));
    graphics.DrawString(L"+", -1, &plusFont, RectF((REAL)x, 0, 30, TABBAR_HEIGHT), &plusFormat, &plusBrush);
}

// Функция рисования навигационной панели
void DrawNavBar(Graphics& graphics, RECT clientRect) {
    FontFamily fontFamily(L"Segoe UI");
    Font font(&fontFamily, 12, FontStyleRegular, UnitPixel);
    SolidBrush brush(Color(255, 220, 220, 220)); // Светло-серый фон
    SolidBrush textBrush(Color(255, 0, 0, 0)); // Чёрный текст

    // Рисуем фон навигационной панели
    graphics.FillRectangle(&brush, RectF(0, (REAL)TABBAR_HEIGHT, (REAL)clientRect.right, (REAL)NAVBAR_HEIGHT));

    // Рисуем фон адресной строки
    RectF addressBarRect((REAL)ADDRESSBAR_PADDING, (REAL)(TABBAR_HEIGHT + 5), (REAL)(clientRect.right - 2 * ADDRESSBAR_PADDING), 30);
    SolidBrush addressBrush(Color(255, 255, 255, 255)); // Белый фон
    Pen pen(Color(255, 0, 0, 0));
    pen.SetWidth(1);
    graphics.FillRectangle(&addressBrush, addressBarRect);
    graphics.DrawRectangle(&pen, addressBarRect.X, addressBarRect.Y, addressBarRect.Width, addressBarRect.Height);

    // Рисуем текст адреса
    if (currentTab < tabs.size()) {
        std::wstring address = tabs[currentTab].url;
        graphics.DrawString(address.c_str(), -1, &font, PointF(addressBarRect.X + 5, addressBarRect.Y + 5), &textBrush);
    }
}

// Функция рисования HTML-контента (в виде простого текста)
void DrawHTMLContent(Graphics& graphics, RECT clientRect) {
    if (currentTab >= tabs.size()) return;

    Tab& tab = tabs[currentTab];
    std::wstring content = tab.htmlContent;

    // Определяем область для рисования HTML-контента
    RectF contentRect(10, TABBAR_HEIGHT + NAVBAR_HEIGHT + 10, (REAL)(clientRect.right - 20), (REAL)(clientRect.bottom - TABBAR_HEIGHT - NAVBAR_HEIGHT - 20));

    // Рисуем HTML-контент как текст
    FontFamily fontFamily(L"Consolas");
    Font font(&fontFamily, 10, FontStyleRegular, UnitPixel);
    SolidBrush textBrush(Color(255, 0, 0, 0)); // Чёрный текст

    StringFormat format;
    format.SetTrimming(StringTrimmingEllipsisCharacter);
    format.SetFormatFlags(StringFormatFlagsNoClip);

    graphics.DrawString(content.c_str(), -1, &font, contentRect, &format, &textBrush);
}

// Функция обработки кликов мыши
void HandleMouseClick(HWND hwnd, int x, int y) {
    // Обработка кликов в области вкладок
    if (y <= TABBAR_HEIGHT) {
        std::lock_guard<std::mutex> lock(tabsMutex);
        for (size_t i = 0; i < tabs.size(); ++i) {
            Tab& tab = tabs[i];
            if (x >= tab.tabRect.left && x <= tab.tabRect.right &&
                y >= tab.tabRect.top && y <= tab.tabRect.bottom) {

                // Проверка области кнопки закрытия ('X')
                int closeXStart = tab.tabRect.right - TAB_CLOSE_BUTTON_SIZE - 5;
                if (x >= closeXStart && x <= closeXStart + TAB_CLOSE_BUTTON_SIZE &&
                    y >= 5 && y <= 5 + TAB_CLOSE_BUTTON_SIZE) {
                    // Закрываем вкладку
                    CloseTab(i);
                    return;
                }
                else if (x >= tab.tabRect.left + 5 && x <= tab.tabRect.left + TAB_WIDTH - TAB_CLOSE_BUTTON_SIZE - 5) {
                    // Переключаемся на вкладку
                    currentTab = i;
                    InvalidateRect(hwnd, NULL, TRUE);
                    return;
                }
            }
        }

        // Проверка клика на кнопку "+" для новой вкладки
        int plusXStart = TAB_PADDING + ((TAB_WIDTH + TAB_SPACING) * tabs.size());
        if (x >= plusXStart && x <= plusXStart + 30 && y >= 0 && y <= TABBAR_HEIGHT) {
            // Добавляем новую вкладку
            AddNewTab();
            return;
        }
    }

    // Обработка кликов в области адресной строки
    if (y > TABBAR_HEIGHT && y < TABBAR_HEIGHT + NAVBAR_HEIGHT) {
        // Для простоты при клике на адресную строку выводим информационное сообщение
        MessageBox(hwnd, L"Ввод URL через адресную строку не реализован.", L"Информация", MB_OK | MB_ICONINFORMATION);
    }
}

// Главная оконная процедура
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;

    case WM_LBUTTONDOWN:
        {
            int xPos = GET_X_LPARAM(lParam);
            int yPos = GET_Y_LPARAM(lParam);
            HandleMouseClick(hwnd, xPos, yPos);
        }
        return 0;

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &ps);
            Graphics graphics(hdc);

            // Получаем клиентскую область окна
            RECT clientRect;
            GetClientRect(hwnd, &clientRect);

            // Рисуем вкладки
            DrawTabs(graphics, clientRect);

            // Рисуем навигационную панель
            DrawNavBar(graphics, clientRect);

            // Рисуем HTML-контент
            DrawHTMLContent(graphics, clientRect);

            EndPaint(hwnd, &ps);
        }
        return 0;

    case WM_SIZE:
        {
            InvalidateRect(hwnd, NULL, TRUE);
        }
        return 0;

    case WM_KEYDOWN:
        {
            if (wParam == VK_CONTROL) {
                // Пример: Ctrl + T для открытия новой вкладки
                AddNewTab();
            }
            else if (wParam == VK_TAB) {
                std::lock_guard<std::mutex> lock(tabsMutex);
                if (!tabs.empty()) {
                    currentTab = (currentTab + 1) % tabs.size();
                    InvalidateRect(hwnd, NULL, TRUE);
                }
            }
            else if (wParam == VK_F5) {
                // Обновление текущей вкладки
                std::lock_guard<std::mutex> lock(tabsMutex);
                if (currentTab < tabs.size()) {
                    UpdateTabContent(currentTab, tabs[currentTab].url);
                }
            }
            // Добавьте обработку других клавиш по необходимости
        }
        return 0;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}

// Точка входа в приложение
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
    // Инициализация GDI+
    if (!InitGDIPlus()) {
        MessageBox(NULL, L"Не удалось инициализировать GDI+", L"Ошибка", MB_OK | MB_ICONERROR);
        return 0;
    }

    // Регистрация оконного класса
    WNDCLASSEX wc = {};
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = CLASS_NAME;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);

    if (!RegisterClassEx(&wc)) {
        MessageBox(NULL, L"Не удалось зарегистрировать оконный класс", L"Ошибка", MB_OK | MB_ICONERROR);
        ShutdownGDIPlus();
        return 0;
    }

    // Создание окна
    HWND hwnd = CreateWindowEx(
        0,
        CLASS_NAME,
        L"Simple C++ Browser",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, WINDOW_WIDTH, WINDOW_HEIGHT,
        NULL,
        NULL,
        hInstance,
        NULL
    );

    if (hwnd == NULL) {
        MessageBox(NULL, L"Не удалось создать окно", L"Ошибка", MB_OK | MB_ICONERROR);
        ShutdownGDIPlus();
        return 0;
    }

    // Отображение окна
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    // Добавление начальной вкладки
    AddNewTab();

    // Цикл обработки сообщений
    MSG msg = {};
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Завершение работы GDI+
    ShutdownGDIPlus();
    return 0;
}
