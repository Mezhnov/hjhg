#include <windows.h>
#include <richedit.h>
#include <string>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <regex>

// Глобальные переменные
HINSTANCE hInst;
HWND hMarkyEdit;
HWND hStylinEdit;
HWND hOutputWindow;

// Декларация функций
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK OutputWndProc(HWND, UINT, WPARAM, LPARAM);

std::string ParseMarky(const std::string& markyCode);
std::string ParseStylin(const std::string& stylinCode);

// Функции конвертации строк
std::wstring utf8_to_wstring(const std::string& str)
{
    if (str.empty()) return std::wstring();
    int size_needed = MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), nullptr, 0);
    std::wstring wstrTo(size_needed, 0);
    MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), &wstrTo[0], size_needed);
    return wstrTo;
}

std::string wstring_to_utf8(const std::wstring& wstr)
{
    if (wstr.empty()) return std::string();
    int size_needed = WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), nullptr, 0, nullptr, nullptr);
    std::string strTo(size_needed, 0);
    WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), &strTo[0], size_needed, nullptr, nullptr);
    return strTo;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow)
{
    LoadLibrary(TEXT("Riched20.dll")); // Загрузка библиотеки RichEdit
    hInst = hInstance;

    WNDCLASS wc = {};
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = TEXT("MarkyStylinIDE");

    RegisterClass(&wc);

    HWND hwnd = CreateWindowEx(
        0,
        wc.lpszClassName,
        TEXT("Marky & Stylin IDE"),
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 800, 600,
        nullptr,
        nullptr,
        hInstance,
        nullptr
    );

    ShowWindow(hwnd, nCmdShow);

    // Цикл сообщений
    MSG msg = {};
    while (GetMessage(&msg, nullptr, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return 0;
}

void CreateControls(HWND hwnd)
{
    CreateWindow(TEXT("STATIC"), TEXT("Marky Code:"),
        WS_VISIBLE | WS_CHILD,
        10, 10, 100, 20,
        hwnd, nullptr, hInst, nullptr);

    hMarkyEdit = CreateWindowEx(WS_EX_CLIENTEDGE, RICHEDIT_CLASS, TEXT(""),
        WS_VISIBLE | WS_CHILD | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
        10, 30, 360, 500,
        hwnd, nullptr, hInst, nullptr);

    CreateWindow(TEXT("STATIC"), TEXT("Stylin Code:"),
        WS_VISIBLE | WS_CHILD,
        380, 10, 100, 20,
        hwnd, nullptr, hInst, nullptr);

    hStylinEdit = CreateWindowEx(WS_EX_CLIENTEDGE, RICHEDIT_CLASS, TEXT(""),
        WS_VISIBLE | WS_CHILD | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
        380, 30, 360, 500,
        hwnd, nullptr, hInst, nullptr);

    CreateWindow(TEXT("BUTTON"), TEXT("Запустить"),
        WS_VISIBLE | WS_CHILD,
        10, 540, 100, 30,
        hwnd, (HMENU)1, hInst, nullptr);
}

void OpenOutputWindow(const std::string& htmlContent)
{
    WNDCLASS wc = {};
    wc.lpfnWndProc = OutputWndProc;
    wc.hInstance = hInst;
    wc.lpszClassName = TEXT("OutputWindowClass");

    RegisterClass(&wc);

    hOutputWindow = CreateWindowEx(
        0,
        wc.lpszClassName,
        TEXT("Результат"),
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 800, 600,
        nullptr,
        nullptr,
        hInst,
        nullptr
    );

    ShowWindow(hOutputWindow, SW_SHOW);

    // Используем WebBrowser Control для отображения HTML
    // Инициализация COM
    CoInitialize(nullptr);

    // Создаем контрол WebBrowser
    IWebBrowser2* pWebBrowser2 = nullptr;
    HWND hBrowserWnd = CreateWindow(TEXT("AtlAxWin140"), TEXT(""),
        WS_CHILD | WS_VISIBLE,
        0, 0, 800, 600,
        hOutputWindow, nullptr, hInst, nullptr);

    HRESULT hr = AtlAxGetControl(hBrowserWnd, (IUnknown**)&pWebBrowser2);
    if (SUCCEEDED(hr))
    {
        // Загружаем HTML из строки
        std::wstring wHtmlContent = utf8_to_wstring(htmlContent);
        VARIANT myVar;
        VariantInit(&myVar);
        BSTR bstr = SysAllocString(wHtmlContent.c_str());
        myVar.vt = VT_BSTR;
        myVar.bstrVal = bstr;

        pWebBrowser2->Navigate(L"about:blank", nullptr, nullptr, nullptr, nullptr);

        IDispatch* pDocDispatch = nullptr;
        pWebBrowser2->get_Document(&pDocDispatch);
        if (pDocDispatch)
        {
            IHTMLDocument2* pDoc;
            pDocDispatch->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc);
            if (pDoc)
            {
                SAFEARRAY* psaStrings = SafeArrayCreateVector(VT_VARIANT, 0, 1);
                if (psaStrings)
                {
                    VARIANT* param;
                    SafeArrayAccessData(psaStrings, (LPVOID*)&param);
                    param->vt = VT_BSTR;
                    param->bstrVal = bstr;
                    SafeArrayUnaccessData(psaStrings);

                    pDoc->write(psaStrings);
                    pDoc->close();
                    SafeArrayDestroy(psaStrings);
                }
                pDoc->Release();
            }
            pDocDispatch->Release();
        }
        SysFreeString(bstr);
        pWebBrowser2->Release();
    }

    // Освобождаем COM
    CoUninitialize();
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_CREATE:
        CreateControls(hwnd);
        break;
    case WM_COMMAND:
        if (LOWORD(wParam) == 1) // Нажата кнопка "Запустить"
        {
            // Получаем код из контролов
            TCHAR markyBuffer[10000];
            GetWindowText(hMarkyEdit, markyBuffer, 10000);
            std::wstring wMarkyCode = markyBuffer;
            std::string markyCode = wstring_to_utf8(wMarkyCode);

            TCHAR stylinBuffer[10000];
            GetWindowText(hStylinEdit, stylinBuffer, 10000);
            std::wstring wStylinCode = stylinBuffer;
            std::string stylinCode = wstring_to_utf8(wStylinCode);

            // Парсим код
            std::string htmlContent = ParseMarky(markyCode);
            std::string cssContent = ParseStylin(stylinCode);

            // Объединяем HTML и CSS
            std::string fullContent = "<html><head><style>" + cssContent + "</style></head><body>" + htmlContent + "</body></html>";

            // Открываем окно вывода
            OpenOutputWindow(fullContent);
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

LRESULT CALLBACK OutputWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_SIZE:
        {
            HWND hChild = FindWindowEx(hwnd, nullptr, nullptr, nullptr);
            if (hChild)
            {
                MoveWindow(hChild, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
            }
        }
        break;
    case WM_DESTROY:
        hOutputWindow = nullptr;
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// ------------ Реализация парсера Marky ------------ //

struct MarkyElement {
    std::string tag;
    std::map<std::string, std::string> attributes;
    std::string content;
    std::vector<MarkyElement> children;
};

int GetIndentLevel(const std::string& line) {
    int level = 0;
    for (char ch : line) {
        if (ch == ' ' || ch == '\t')
            level++;
        else
            break;
    }
    return level;
}

MarkyElement ParseMarkyLines(const std::vector<std::string>& lines, size_t& index, int currentIndent)
{
    MarkyElement element;

    while (index < lines.size())
    {
        std::string line = lines[index];
        int indent = GetIndentLevel(line);

        if (indent < currentIndent)
            break;

        line = line.substr(indent); // Убираем отступы

        if (line.empty())
        {
            index++;
            continue;
        }

        if (line.find(':') != std::string::npos)
        {
            std::string tagPart = line.substr(0, line.find(':'));
            std::string contentPart = line.substr(line.find(':') + 1);

            // Разбираем тег и атрибуты
            std::regex tagRegex(R"(^(\w+)\s*(.*))");
            std::smatch tagMatch;
            if (std::regex_match(tagPart, tagMatch, tagRegex))
            {
                MarkyElement childElement;
                childElement.tag = tagMatch[1].str();

                // Разбираем атрибуты
                std::string attrs = tagMatch[2].str();
                std::regex attrRegex(R"((\w+)\s*=\s*"(.*?)"|(\w+)\s*=\s*(\S+)|(\w+)\s*:\s*(\S+))");
                auto attrBegin = std::sregex_iterator(attrs.begin(), attrs.end(), attrRegex);
                auto attrEnd = std::sregex_iterator();
                for (auto it = attrBegin; it != attrEnd; ++it)
                {
                    std::smatch attrMatch = *it;
                    if (attrMatch[1].matched)
                        childElement.attributes[attrMatch[1].str()] = attrMatch[2].str();
                    else if (attrMatch[3].matched)
                        childElement.attributes[attrMatch[3].str()] = attrMatch[4].str();
                    else if (attrMatch[5].matched)
                        childElement.attributes[attrMatch[5].str()] = attrMatch[6].str();
                }

                // Если есть контент после двоеточия, добавляем его
                if (!contentPart.empty())
                {
                    childElement.content = contentPart;
                    index++;
                }
                else
                {
                    index++;
                    // Парсим дочерние элементы
                    childElement.children.push_back(ParseMarkyLines(lines, index, indent + 2));
                }

                element.children.push_back(childElement);
            }
            else
            {
                index++;
            }
        }
        else
        {
            index++;
        }
    }

    return element;
}

std::string GenerateHTML(const MarkyElement& element)
{
    std::string html;

    for (const auto& child : element.children)
    {
        html += "<" + child.tag;

        // Добавляем атрибуты
        for (const auto& attr : child.attributes)
        {
            html += " " + attr.first + "=\"" + attr.second + "\"";
        }
        html += ">";

        // Добавляем контент
        if (!child.content.empty())
        {
            html += child.content;
        }

        // Рекурсивно добавляем дочерние элементы
        html += GenerateHTML(child);

        html += "</" + child.tag + ">";
    }

    return html;
}

std::string ParseMarky(const std::string& markyCode)
{
    std::vector<std::string> lines;
    std::istringstream iss(markyCode);
    std::string line;
    while (std::getline(iss, line))
    {
        lines.push_back(line);
    }

    size_t index = 0;
    MarkyElement root = ParseMarkyLines(lines, index, 0);
    return GenerateHTML(root);
}

// ------------ Реализация парсера Stylin ------------ //

struct StylinElement {
    std::string selector;
    std::map<std::string, std::string> properties;
    std::vector<StylinElement> children;
};

std::map<std::string, std::string> variables;

void ParseStylinLines(const std::vector<std::string>& lines, size_t& index, int currentIndent, std::vector<StylinElement>& elements)
{
    while (index < lines.size())
    {
        std::string line = lines[index];
        int indent = GetIndentLevel(line);

        if (line.empty() || line.find_first_not_of(' ') == std::string::npos)
        {
            index++;
            continue;
        }

        if (indent < currentIndent)
        {
            break;
        }
        else if (indent > currentIndent)
        {
            index++;
            continue;
        }
        else
        {
            line = line.substr(indent); // Убираем отступы

            // Проверяем, является ли это переменной
            if (line[0] == '$')
            {
                size_t colonPos = line.find(':');
                if (colonPos != std::string::npos)
                {
                    std::string varName = line.substr(0, colonPos);
                    std::string varValue = line.substr(colonPos + 1);
                    variables[varName] = varValue;
                }
                index++;
            }
            else if (line.back() == ':')
            {
                StylinElement element;
                element.selector = line.substr(0, line.length() - 1);
                index++;
                ParseStylinLines(lines, index, indent + 2, element.children);
                elements.push_back(element);
            }
            else
            {
                size_t colonPos = line.find(':');
                if (colonPos != std::string::npos)
                {
                    std::string propName = line.substr(0, colonPos);
                    std::string propValue = line.substr(colonPos + 1);

                    // Замена переменных
                    for (const auto& var : variables)
                    {
                        size_t pos = propValue.find(var.first);
                        if (pos != std::string::npos)
                        {
                            propValue.replace(pos, var.first.length(), var.second);
                        }
                    }

                    if (!elements.empty())
                    {
                        elements.back().properties[propName] = propValue;
                    }
                }
                index++;
            }
        }
    }
}

void GenerateCSS(const StylinElement& element, std::string& css, const std::string& parent = "")
{
    std::string selector = parent.empty() ? element.selector : parent + " " + element.selector;
    css += selector + " {\n";
    for (const auto& prop : element.properties)
    {
        css += "  " + prop.first + ": " + prop.second + ";\n";
    }
    css += "}\n";
    for (const auto& child : element.children)
    {
        GenerateCSS(child, css, selector);
    }
}

std::string ParseStylin(const std::string& stylinCode)
{
    variables.clear();
    std::vector<std::string> lines;
    std::istringstream iss(stylinCode);
    std::string line;
    while (std::getline(iss, line))
    {
        lines.push_back(line);
    }

    size_t index = 0;
    std::vector<StylinElement> elements;
    ParseStylinLines(lines, index, 0, elements);

    std::string css;
    for (const auto& element : elements)
    {
        GenerateCSS(element, css);
    }
    return css;
}
