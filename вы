# app.py

import os
import logging
import json
from urllib.parse import urlparse
from flask import Flask, request, send_file, jsonify, abort
from whoosh.index import create_in, open_dir
from whoosh.fields import Schema, TEXT, ID, STORED
from whoosh.qparser import MultifieldParser
import nltk
from nltk.stem.snowball import RussianStemmer
from nltk.corpus import stopwords
import re

# Инициализация Flask приложения
app = Flask(__name__)

# Настройки логирования
logging.basicConfig(
    filename='smp_server.log',
    level=logging.INFO,
    format='%(asctime)s:%(levelname)s:%(message)s'
)

# Разрешенные домены и их корневые директории
allowed_domains = {
    'example.com': 'example',
    'test.com': 'test',
    'search.com': 'search'   # Домен для поисковой системы
}

# Инициализация NLTK ресурсов
nltk.download('punkt')
nltk.download('stopwords')

# Настройка поискового индекса
index_dir = 'indexdir'

if not os.path.exists(index_dir):
    os.mkdir(index_dir)
    # Определяем схему для индекса
    schema = Schema(
        path=ID(stored=True, unique=True),
        title=TEXT(stored=True),
        content=TEXT,
        description=STORED,
        logo=STORED
    )
    ix = create_in(index_dir, schema)
    logging.info(f"Создан новый индекс в директории: {index_dir}")
else:
    ix = open_dir(index_dir)
    logging.info(f"Открыт существующий индекс из директории: {index_dir}")

# Настройка стеммера и стоп-слов
stemmer = RussianStemmer()
stop_words = set(stopwords.words('russian'))

def clean_query(query):
    """
    Очищает и обрабатывает поисковый запрос.
    """
    tokens = nltk.word_tokenize(query.lower(), language='russian')
    tokens = [re.sub(r'\W+', '', token) for token in tokens]
    tokens = [token for token in tokens if token and token not in stop_words]
    tokens = [stemmer.stem(token) for token in tokens]
    return ' '.join(tokens)

def handle_search(query):
    """
    Выполняет поиск по индексу и возвращает результаты.
    """
    clean_q = clean_query(query)
    parser = MultifieldParser(["title", "content"], schema=ix.schema)
    with ix.searcher() as searcher:
        query_obj = parser.parse(clean_q)
        results = searcher.search(query_obj, limit=10)
        hits = [
            {
                'title': r['title'],
                'url': r['path'],
                'description': r.get('description', ''),
                'logo': r.get('logo', '')  # Путь к логотипу, если есть
            }
            for r in results
        ]
    return hits

@app.route('/resource', methods=['GET'])
def get_resource():
    """
    Эндпоинт для обработки GET-запросов к ресурсам.
    Ожидает параметры:
    - domain: домен (например, example.com)
    - path: путь к ресурсу внутри домена
    """
    domain = request.args.get('domain', '')
    path = request.args.get('path', '')

    if not domain:
        logging.warning("Запрос без указанного домена.")
        return jsonify({
            'status': 'ERROR',
            'message': 'Missing domain parameter.'
        }), 400

    if domain not in allowed_domains:
        logging.warning(f"Запрошен запрещённый домен: {domain}")
        return jsonify({
            'status': 'ERROR',
            'message': 'Domain not allowed.'
        }), 403

    domain_root = allowed_domains[domain]
    file_path = os.path.join(domain_root, path) if path else os.path.join(domain_root, 'index.html')

    if os.path.isdir(file_path):
        file_path = os.path.join(file_path, 'index.html')

    real_file_path = os.path.realpath(file_path)
    real_domain_root = os.path.realpath(domain_root)

    if not real_file_path.startswith(real_domain_root):
        logging.warning(f"Некорректный путь ресурса: {file_path}")
        return jsonify({
            'status': 'ERROR',
            'message': 'Invalid resource path.'
        }), 400

    if not os.path.exists(file_path):
        logging.warning(f"Ресурс не найден: {file_path}")
        return jsonify({
            'status': 'ERROR',
            'message': 'Resource not found.'
        }), 404

    try:
        logging.info(f"Отправка файла: {file_path}")
        return send_file(file_path)
    except Exception as e:
        logging.error(f"Ошибка при отправке файла {file_path}: {e}")
        return jsonify({
            'status': 'ERROR',
            'message': f"Error sending file: {e}"
        }), 500

@app.route('/search', methods=['GET'])
def search():
    """
    Эндпоинт для обработки поисковых запросов.
    Ожидает параметр:
    - query: строка поискового запроса
    """
    query = request.args.get('query', '')
    if not query:
        logging.warning("Поисковый запрос без параметра QUERY.")
        return jsonify({
            'status': 'ERROR',
            'message': 'Missing QUERY parameter.'
        }), 400

    try:
        logging.info(f"Выполняется поиск для запроса: '{query}'")
        search_results = handle_search(query)
        return jsonify({
            'status': 'OK',
            'results': search_results
        }), 200
    except Exception as e:
        logging.error(f"Ошибка при выполнении поиска: {e}")
        return jsonify({
            'status': 'ERROR',
            'message': f"Search error: {e}"
        }), 500

@app.route('/')
def index():
    """
    Корневой эндпоинт, можно использовать для проверки статуса сервера.
    """
    return jsonify({
        'status': 'OK',
        'message': 'SMP Flask Server is running.'
    }), 200

if __name__ == '__main__':
    # Запуск Flask сервера
    app.run(host='0.0.0.0', port=8080)
