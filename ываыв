#include <windows.h>
#include <gdiplus.h>
#include <urlmon.h>
#include <shlwapi.h> // For path manipulation functions
#include <string>
#include <ctime>
#include <vector>
#include <windowsx.h>
#include <cstdlib> // For rand()
#include <sstream>
#include <map>

#pragma comment (lib,"Gdiplus.lib")
#pragma comment (lib,"Urlmon.lib")
#pragma comment (lib,"Shlwapi.lib")

// Глобальные переменные
HINSTANCE hInst;
HWND hMarkyEdit;
HWND hStylinEdit;
HWND hRunButton;
HWND hMainWnd;

struct UIElement {
    std::string type;
    std::string id;
    std::string text;
    std::string src; // Для изображений
    std::string action; // Для событий
    POINT position;
    SIZE size;
};

struct Style {
    int fontSize = 0;
    COLORREF textColor = RGB(0, 0, 0);
    COLORREF backgroundColor = RGB(255, 255, 255);
    std::string fontFamily = "Arial";
};

struct EventHandler {
    std::string id;
    std::string action;
};

// Словари для хранения элементов и стилей
std::vector<UIElement> uiElements;
std::map<std::string, Style> styles;
std::map<std::string, EventHandler> eventHandlers;

// Функции для парсинга
void ParseMarky(const std::string& markyCode);
void ParseStylin(const std::string& stylinCode);

// Функции для создания интерфейса
void CreateUI(HWND parent);

// Вспомогательные функции
COLORREF ParseColor(const std::string& colorStr);
void ApplyStyle(HWND hControl, const Style& style);
void DownloadImage(const std::string& url, const std::string& filename);
LRESULT CALLBACK ButtonProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

// Прототипы оконных процедур
LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK UIWndProc(HWND, UINT, WPARAM, LPARAM);

HHOOK hButtonHook;
std::map<HWND, std::string> buttonActions;

// Главная функция
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow) {
    hInst = hInstance;

    // Регистрация класса окна
    WNDCLASS wc = {};
    wc.lpfnWndProc = MainWndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = TEXT("MarkyStylinIDE");

    RegisterClass(&wc);

    // Создание главного окна
    hMainWnd = CreateWindowEx(
        0,
        wc.lpszClassName,
        TEXT("Marky & Stylin IDE"),
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 800, 600,
        nullptr,
        nullptr,
        hInstance,
        nullptr
    );

    ShowWindow(hMainWnd, nCmdShow);

    // Цикл сообщений
    MSG msg = {};
    while (GetMessage(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return 0;
}

// Создание элементов управления в главном окне
void CreateControls(HWND hwnd) {
    CreateWindow(TEXT("STATIC"), TEXT("Marky Code:"),
        WS_VISIBLE | WS_CHILD,
        10, 10, 100, 20,
        hwnd, nullptr, hInst, nullptr);

    hMarkyEdit = CreateWindowEx(WS_EX_CLIENTEDGE, TEXT("EDIT"), TEXT(""),
        WS_VISIBLE | WS_CHILD | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
        10, 30, 360, 500,
        hwnd, (HMENU)101, hInst, nullptr);

    CreateWindow(TEXT("STATIC"), TEXT("Stylin Code:"),
        WS_VISIBLE | WS_CHILD,
        380, 10, 100, 20,
        hwnd, nullptr, hInst, nullptr);

    hStylinEdit = CreateWindowEx(WS_EX_CLIENTEDGE, TEXT("EDIT"), TEXT(""),
        WS_VISIBLE | WS_CHILD | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
        380, 30, 360, 500,
        hwnd, (HMENU)102, hInst, nullptr);

    hRunButton = CreateWindow(TEXT("BUTTON"), TEXT("Запустить"),
        WS_VISIBLE | WS_CHILD,
        10, 540, 100, 30,
        hwnd, (HMENU)1, hInst, nullptr);
}

// Оконная процедура главного окна
LRESULT CALLBACK MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg)
    {
    case WM_CREATE:
        CreateControls(hwnd);
        break;
    case WM_COMMAND:
        if (LOWORD(wParam) == 1) // Нажата кнопка "Запустить"
        {
            // Получаем код из контролов
            TCHAR markyBuffer[10000];
            GetWindowText(hMarkyEdit, markyBuffer, 10000);
            std::wstring wMarkyCode = markyBuffer;
            std::string markyCode(wMarkyCode.begin(), wMarkyCode.end());

            TCHAR stylinBuffer[10000];
            GetWindowText(hStylinEdit, stylinBuffer, 10000);
            std::wstring wStylinCode = stylinBuffer;
            std::string stylinCode(wStylinCode.begin(), wStylinCode.end());

            // Парсим код
            ParseMarky(markyCode);
            ParseStylin(stylinCode);

            // Создаем новое окно для отображения интерфейса
            WNDCLASS wc = {};
            wc.lpfnWndProc = UIWndProc;
            wc.hInstance = hInst;
            wc.lpszClassName = TEXT("UIWindowClass");

            RegisterClass(&wc);

            HWND hUIWindow = CreateWindowEx(
                0,
                wc.lpszClassName,
                TEXT("Результат"),
                WS_OVERLAPPEDWINDOW,
                CW_USEDEFAULT, CW_USEDEFAULT, 500, 400,
                hwnd,
                nullptr,
                hInst,
                nullptr
            );

            ShowWindow(hUIWindow, SW_SHOW);
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// Оконная процедура окна интерфейса
LRESULT CALLBACK UIWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg)
    {
    case WM_CREATE:
        CreateUI(hwnd);
        break;
    case WM_COMMAND:
        {
            HWND hControl = (HWND)lParam;
            if (buttonActions.find(hControl) != buttonActions.end()) {
                std::string action = buttonActions[hControl];
                if (action == "close") {
                    DestroyWindow(hwnd);
                }
                else if (action == "message") {
                    MessageBox(hwnd, L"Кнопка нажата!", L"Информация", MB_OK);
                }
                // Добавьте дополнительные действия здесь
            }
        }
        break;
    case WM_DESTROY:
        // Очищаем элементы и стили после закрытия окна
        uiElements.clear();
        styles.clear();
        eventHandlers.clear();
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// Функция парсинга Marky
void ParseMarky(const std::string& markyCode) {
    uiElements.clear();

    std::istringstream iss(markyCode);
    std::string line;
    UIElement currentWindow;
    bool inElements = false;
    UIElement element;

    while (std::getline(iss, line)) {
        // Убираем начальные и конечные пробелы
        line.erase(0, line.find_first_not_of(" \t"));
        line.erase(line.find_last_not_of(" \t\r\n") + 1);

        if (line.empty() || line[0] == '#')
            continue; // Пропускаем пустые строки и комментарии

        if (line.find("window:") == 0) {
            // Начало описания окна
            inElements = false;
        }
        else if (line.find("title:") == 0) {
            currentWindow.text = line.substr(6);
            currentWindow.text.erase(0, currentWindow.text.find_first_not_of(" \""));
            currentWindow.text.erase(currentWindow.text.find_last_not_of(" \"") + 1);
        }
        else if (line.find("size:") == 0) {
            std::string sizeStr = line.substr(5);
            sizeStr.erase(0, sizeStr.find_first_not_of(" \t"));
            int xPos = sizeStr.find('x');
            if (xPos != std::string::npos) {
                currentWindow.size.cx = std::atoi(sizeStr.substr(0, xPos).c_str());
                currentWindow.size.cy = std::atoi(sizeStr.substr(xPos + 1).c_str());
            }
        }
        else if (line.find("elements:") == 0) {
            inElements = true;
        }
        else if (inElements && line[0] == '-') {
            // Начало описания элемента
            element = UIElement();
            size_t pos = line.find(':');
            if (pos != std::string::npos) {
                element.type = line.substr(1, pos - 1);
                element.type.erase(0, element.type.find_first_not_of(" \t"));
                element.type.erase(element.type.find_last_not_of(" \t") + 1);
            }
        }
        else if (inElements) {
            size_t colonPos = line.find(':');
            if (colonPos != std::string::npos) {
                std::string key = line.substr(0, colonPos);
                std::string value = line.substr(colonPos + 1);
                key.erase(0, key.find_first_not_of(" \t"));
                key.erase(key.find_last_not_of(" \t") + 1);
                value.erase(0, value.find_first_not_of(" \t\""));
                value.erase(value.find_last_not_of(" \t\"") + 1);

                if (key == "id") {
                    element.id = value;
                }
                else if (key == "text") {
                    element.text = value;
                }
                else if (key == "src") {
                    element.src = value;
                }
                else if (key == "position") {
                    int xPos = value.find('x');
                    if (xPos != std::string::npos) {
                        element.position.x = std::atoi(value.substr(0, xPos).c_str());
                        element.position.y = std::atoi(value.substr(xPos + 1).c_str());
                    }
                }
                else if (key == "size") {
                    int xPos = value.find('x');
                    if (xPos != std::string::npos) {
                        element.size.cx = std::atoi(value.substr(0, xPos).c_str());
                        element.size.cy = std::atoi(value.substr(xPos + 1).c_str());
                    }
                }
                else if (key == "action") {
                    element.action = value;
                    // Сохраняем обработчик события
                    eventHandlers[element.id] = { element.id, element.action };
                }
            }
            else if (line.empty()) {
                // Конец описания элемента
                uiElements.push_back(element);
            }
        }
    }

    // Устанавливаем параметры окна на основе парсинга
    if (!currentWindow.text.empty()) {
        // Здесь можно сохранить параметры окна, если потребуется
    }
}

// Функция парсинга Stylin
void ParseStylin(const std::string& stylinCode) {
    styles.clear();

    std::istringstream iss(stylinCode);
    std::string line;
    std::string currentSelector;

    while (std::getline(iss, line)) {
        // Убираем начальные и конечные пробелы
        line.erase(0, line.find_first_not_of(" \t"));
        line.erase(line.find_last_not_of(" \t\r\n") + 1);

        if (line.empty() || line[0] == '#')
            continue; // Пропускаем пустые строки и комментарии

        if (line.back() == ':') {
            currentSelector = line.substr(0, line.length() - 1);
            currentSelector.erase(0, currentSelector.find_first_not_of(" \t"));
            currentSelector.erase(currentSelector.find_last_not_of(" \t") + 1);
        }
        else {
            size_t colonPos = line.find(':');
            if (colonPos != std::string::npos) {
                std::string property = line.substr(0, colonPos);
                std::string value = line.substr(colonPos + 1);

                property.erase(0, property.find_first_not_of(" \t"));
                property.erase(property.find_last_not_of(" \t") + 1);
                value.erase(0, value.find_first_not_of(" \t"));
                value.erase(value.find_last_not_of(" \t") + 1);

                Style& style = styles[currentSelector];

                if (property == "font-size") {
                    style.fontSize = std::atoi(value.c_str());
                }
                else if (property == "color" || property == "text-color") {
                    style.textColor = ParseColor(value);
                }
                else if (property == "background-color") {
                    style.backgroundColor = ParseColor(value);
                }
                else if (property == "font-family") {
                    style.fontFamily = value;
                }
            }
        }
    }
}

// Функция создания интерфейса на основе парсинга
void CreateUI(HWND parent) {
    for (const auto& element : uiElements) {
        HWND hControl = nullptr;
        if (element.type == "label") {
            hControl = CreateWindow(TEXT("STATIC"), std::wstring(element.text.begin(), element.text.end()).c_str(),
                WS_VISIBLE | WS_CHILD,
                element.position.x, element.position.y, element.size.cx, element.size.cy,
                parent, nullptr, hInst, nullptr);

            // Применяем стили
            auto it = styles.find("label");
            if (it != styles.end()) {
                ApplyStyle(hControl, it->second);
            }
        }
        else if (element.type == "button") {
            hControl = CreateWindow(TEXT("BUTTON"), std::wstring(element.text.begin(), element.text.end()).c_str(),
                WS_VISIBLE | WS_CHILD,
                element.position.x, element.position.y, element.size.cx, element.size.cy,
                parent, (HMENU)element.id.c_str(), hInst, nullptr);

            // Применяем стили
            auto it = styles.find("button");
            if (it != styles.end()) {
                ApplyStyle(hControl, it->second);
            }

            // Обрабатываем события
            if (!element.action.empty()) {
                buttonActions[hControl] = element.action;
            }
        }
        else if (element.type == "image") {
            // Загружаем изображение
            std::string filename = "downloaded_image.png";
            DownloadImage(element.src, filename);

            Gdiplus::Image* image = new Gdiplus::Image(std::wstring(filename.begin(), filename.end()).c_str());
            HWND hImageControl = CreateWindow(TEXT("STATIC"), nullptr,
                WS_VISIBLE | WS_CHILD | SS_BITMAP,
                element.position.x, element.position.y, element.size.cx, element.size.cy,
                parent, nullptr, hInst, nullptr);

            // Устанавливаем изображение в контрол
            HBITMAP hBitmap;
            image->GetHBITMAP(NULL, &hBitmap);
            SendMessage(hImageControl, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
        }

        // Применяем стили с использованием идентификатора
        if (!element.id.empty()) {
            auto it = styles.find("#" + element.id);
            if (it != styles.end()) {
                ApplyStyle(hControl, it->second);
            }
        }
    }
}

// Функция парсинга цвета из строки
COLORREF ParseColor(const std::string& colorStr) {
    if (colorStr.find("RGB(") == 0 && colorStr.back() == ')') {
        std::string values = colorStr.substr(4, colorStr.length() - 5);
        int r = 0, g = 0, b = 0;
        sscanf_s(values.c_str(), "%d, %d, %d", &r, &g, &b);
        return RGB(r, g, b);
    }
    return 0;
}

// Применение стилей к контролу
void ApplyStyle(HWND hControl, const Style& style) {
    if (style.fontSize > 0 || !style.fontFamily.empty()) {
        // Изменяем шрифт
        HFONT hFont = CreateFont(style.fontSize, 0, 0, 0, FW_NORMAL,
            FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_OUTLINE_PRECIS,
            CLIP_DEFAULT_PRECIS, CLEARTYPE_QUALITY, VARIABLE_PITCH, std::wstring(style.fontFamily.begin(), style.fontFamily.end()).c_str());
        SendMessage(hControl, WM_SETFONT, (WPARAM)hFont, TRUE);
    }

    if (style.textColor != RGB(0, 0, 0)) {
        // Устанавливаем цвет текста
        HDC hdc = GetDC(hControl);
        SetTextColor(hdc, style.textColor);
        ReleaseDC(hControl, hdc);
    }

    if (style.backgroundColor != RGB(255, 255, 255)) {
        // Устанавливаем цвет фона
        HBRUSH hBrush = CreateSolidBrush(style.backgroundColor);
        SetClassLongPtr(hControl, GCLP_HBRBACKGROUND, (LONG_PTR)hBrush);
        InvalidateRect(hControl, NULL, TRUE);
    }
}

// Функция загрузки изображения по URL
void DownloadImage(const std::string& url, const std::string& filename) {
    URLDownloadToFileA(NULL, url.c_str(), filename.c_str(), 0, NULL);
}

window:
title: "Пример интерфейса"
size: 500x400
elements:
- label:
    id: "label1"
    text: "Привет, Мир!"
    position: 50x50
    size: 200x30

- button:
    id: "button1"
    text: "Нажми меня"
    position: 50x100
    size: 150x40
    action: "message"

- image:
    id: "image1"
    src: "https://example.com/image.png"
    position: 50x160
    size: 100x100

label:
    font-size: 18
    color: RGB(0, 0, 255) # Синий цвет текста
    font-family: "Calibri"

button:
    font-size: 16
    color: RGB(255, 255, 255) # Белый цвет текста
    background-color: RGB(0, 128, 0) # Зеленый фон
    font-family: "Arial"

#label1:
    font-size: 20
    color: RGB(255, 0, 0) # Красный текст для конкретного элемента

#button1:
    background-color: RGB(0, 0, 128) # Синий фон для конкретной кнопки

