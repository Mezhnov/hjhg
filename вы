import socket
import threading
import logging
import os
import json
import re
from urllib.parse import urlparse

from whoosh.index import open_dir, create_in
from whoosh.qparser import MultifieldParser
from whoosh.fields import Schema, TEXT, ID, STORED
import nltk
from nltk.stem.snowball import RussianStemmer
from nltk.corpus import stopwords

# Initialize NLTK resources
nltk.download('punkt')
nltk.download('stopwords')

# Server settings
HOST = '0.0.0.0'  # Listen on all interfaces
PORT = 8080
BUFFER_SIZE = 4096  # Buffer size for data transmission

# Logging configuration
logging.basicConfig(
    filename='smp_server.log',
    level=logging.INFO,
    format='%(asctime)s:%(levelname)s:%(message)s'
)

# Allowed domains and their root directories
allowed_domains = {
    'example.com': 'example',
    'test.com': 'test',
    'search.com': 'search'   # Domain for the search system
}

# Initialize search index
index_dir = 'indexdir'

if not os.path.exists(index_dir):
    os.mkdir(index_dir)
    # Define schema for the index
    schema = Schema(
        path=ID(stored=True, unique=True),
        title=TEXT(stored=True),
        content=TEXT,
        description=STORED,
        logo=STORED
    )
    ix = create_in(index_dir, schema)
    logging.info(f"Created new index in directory: {index_dir}")
else:
    ix = open_dir(index_dir)
    logging.info(f"Opened existing index from directory: {index_dir}")

# Setup stemmer and stop words
stemmer = RussianStemmer()
stop_words = set(stopwords.words('russian'))

def send_response(conn, status, content_type, body):
    """
    Sends a response to the client in SMP format.
    """
    content_length = len(body)
    response_headers = (
        f"SMP 1.0\n"
        f"STATUS: {status}\n"
        f"CONTENT-TYPE: {content_type}\n"
        f"CONTENT-LENGTH: {content_length}\n\n"
    )
    try:
        conn.sendall(response_headers.encode() + body)
        logging.info(f"Sent response: STATUS={status}, CONTENT-TYPE={content_type}, CONTENT-LENGTH={content_length}")
    except Exception as e:
        logging.error(f"Error sending response: {e}")

def clean_query(query):
    """
    Cleans and processes the search query.
    """
    tokens = nltk.word_tokenize(query.lower(), language='russian')
    tokens = [re.sub(r'\W+', '', token) for token in tokens]
    tokens = [token for token in tokens if token and token not in stop_words]
    tokens = [stemmer.stem(token) for token in tokens]
    return ' '.join(tokens)

def handle_search(query):
    """
    Performs a search on the index and returns the results.
    """
    clean_q = clean_query(query)
    parser = MultifieldParser(["title", "content"], schema=ix.schema)
    with ix.searcher() as searcher:
        query_obj = parser.parse(clean_q)
        results = searcher.search(query_obj, limit=10)
        hits = [
            {
                'title': r['title'],
                'url': r['path'],
                'description': r.get('description', ''),
                'logo': r.get('logo', '')  # Path to logo if available
            }
            for r in results
        ]
    return hits

def handle_search_action(headers):
    """
    Handles the SEARCH ACTION in SMP.
    """
    query = headers.get('QUERY', '')
    if not query:
        return {
            'status': 'ERROR',
            'message': 'Missing QUERY parameter.'
        }
    try:
        results = handle_search(query)
        return {
            'status': 'OK',
            'results': results
        }
    except Exception as e:
        logging.error(f"Search error: {e}")
        return {
            'status': 'ERROR',
            'message': f"Search error: {e}"
        }

def render_template(template_path, context):
    """
    Simple template renderer replacing {{ key }} with context values.
    """
    try:
        with open(template_path, 'r', encoding='utf-8') as f:
            content = f.read()
        for key, value in context.items():
            placeholder = f"{{{{ {key} }}}}"
            content = content.replace(placeholder, str(value))
        return content.encode('utf-8')
    except Exception as e:
        logging.error(f"Template rendering error: {e}")
        return f"Error rendering template: {e}".encode('utf-8')

def send_large_file(conn, filepath):
    """
    Sends a file to the client in chunks with appropriate headers.
    """
    if not os.path.exists(filepath):
        logging.error(f"File not found: {filepath}")
        message = "File not found"
        response = (
            f"SMP 1.0\n"
            f"STATUS: ERROR\n"
            f"MESSAGE: {message}\n"
            f"CONTENT-TYPE: text/plain\n"
            f"CONTENT-LENGTH: {len(message)}\n\n"
            f"{message}"
        )
        conn.sendall(response.encode())
        return

    try:
        file_size = os.path.getsize(filepath)
        _, ext = os.path.splitext(filepath)
        ext = ext.lower()
        if ext in ['.html', '.htm']:
            content_type = 'text/html'
        elif ext == '.css':
            content_type = 'text/css'
        elif ext == '.png':
            content_type = 'image/png'
        elif ext in ['.jpg', '.jpeg']:
            content_type = 'image/jpeg'
        elif ext == '.gif':
            content_type = 'image/gif'
        elif ext == '.js':
            content_type = 'application/javascript'
        else:
            content_type = 'application/octet-stream'

        # Send headers
        response_headers = (
            f"SMP 1.0\n"
            f"STATUS: OK\n"
            f"CONTENT-TYPE: {content_type}\n"
            f"CONTENT-LENGTH: {file_size}\n\n"
        )
        conn.send(response_headers.encode())
        logging.info(f"Sending file: {filepath}")

        # Send file in chunks
        with open(filepath, 'rb') as f:
            while True:
                chunk = f.read(BUFFER_SIZE)
                if not chunk:
                    break
                conn.sendall(chunk)
        logging.info(f"File sent successfully: {filepath}")

    except Exception as e:
        logging.error(f"Error sending file {filepath}: {e}")
        message = f"Error sending file: {e}"
        response = (
            f"SMP 1.0\n"
            f"STATUS: ERROR\n"
            f"MESSAGE: {message}\n"
            f"CONTENT-TYPE: text/plain\n"
            f"CONTENT-LENGTH: {len(message)}\n\n"
            f"{message}"
        )
        conn.sendall(response.encode())

def handle_client(conn, addr):
    """
    Handles client connections in separate threads.
    """
    logging.info(f"Client connected: {addr}")

    while True:
        try:
            data = b""
            while b"\n\n" not in data:
                part = conn.recv(BUFFER_SIZE)
                if not part:
                    raise ConnectionResetError("Client closed the connection")
                data += part

            header_data, _, body = data.partition(b"\n\n")
            headers = {}
            for line in header_data.decode().split('\n'):
                if ': ' in line:
                    key, value = line.split(': ', 1)
                    headers[key.strip().upper()] = value.strip()

            action = headers.get('ACTION')
            resource = headers.get('RESOURCE')

            if action == 'GET' and resource:
                # Parse the resource to extract domain and path
                parsed = urlparse('smp://' + resource)  # For using urlparse
                domain = parsed.hostname
                path = parsed.path.lstrip('/')  # Remove leading '/'

                if domain not in allowed_domains:
                    message = "Domain not allowed"
                    response = (
                        f"SMP 1.0\n"
                        f"STATUS: ERROR\n"
                        f"MESSAGE: {message}\n"
                        f"CONTENT-TYPE: text/plain\n"
                        f"CONTENT-LENGTH: {len(message)}\n\n"
                        f"{message}"
                    )
                    conn.sendall(response.encode())
                    logging.warning(f"Disallowed domain requested: {domain}")
                    continue

                # Determine the file path
                domain_root = allowed_domains[domain]
                file_path = os.path.join(domain_root, path) if path else os.path.join(domain_root, 'index.html')

                # Prevent directory traversal
                real_file_path = os.path.realpath(file_path)
                real_domain_root = os.path.realpath(domain_root)
                if not real_file_path.startswith(real_domain_root):
                    message = "Invalid resource path"
                    response = (
                        f"SMP 1.0\n"
                        f"STATUS: ERROR\n"
                        f"MESSAGE: {message}\n"
                        f"CONTENT-TYPE: text/plain\n"
                        f"CONTENT-LENGTH: {len(message)}\n\n"
                        f"{message}"
                    )
                    conn.sendall(response.encode())
                    logging.warning(f"Invalid resource path: {file_path}")
                    continue

                # If path points to a directory, serve index.html
                if os.path.isdir(file_path):
                    file_path = os.path.join(file_path, 'index.html')
                    if os.path.exists(file_path):
                        send_large_file(conn, file_path)
                        continue
                    else:
                        message = "Resource not found"
                        response = (
                            f"SMP 1.0\n"
                            f"STATUS: ERROR\n"
                            f"MESSAGE: {message}\n"
                            f"CONTENT-TYPE: text/plain\n"
                            f"CONTENT-LENGTH: {len(message)}\n\n"
                            f"{message}"
                        )
                        conn.sendall(response.encode())
                        logging.warning(f"Resource not found: {file_path}")
                        continue

                _, ext = os.path.splitext(file_path)
                if domain == 'search.com':
                    if path == '' or path == 'index.html':
                        # Serve the search form
                        send_large_file(conn, file_path)
                        continue
                    elif path == 'search':
                        # Handle the search action
                        if not body:
                            message = "Missing body for search action."
                            response = (
                                f"SMP 1.0\n"
                                f"STATUS: ERROR\n"
                                f"MESSAGE: {message}\n"
                                f"CONTENT-TYPE: text/plain\n"
                                f"CONTENT-LENGTH: {len(message)}\n\n"
                                f"{message}"
                            )
                            conn.sendall(response.encode())
                            logging.warning(f"Search action without body from {addr}")
                            continue

                        # Parse form data
                        form_data = {}
                        for line in body.decode().split('&'):
                            if '=' in line:
                                key, value = line.split('=', 1)
                                form_data[key] = value

                        query = form_data.get('query', '')
                        if not query:
                            message = "Missing QUERY parameter."
                            response = (
                                f"SMP 1.0\n"
                                f"STATUS: ERROR\n"
                                f"MESSAGE: {message}\n"
                                f"CONTENT-TYPE: text/plain\n"
                                f"CONTENT-LENGTH: {len(message)}\n\n"
                                f"{message}"
                            )
                            conn.sendall(response.encode())
                            logging.warning(f"Search action with missing QUERY from {addr}")
                            continue

                        logging.info(f"Performing search for query: '{query}' from {addr}")
                        search_results = handle_search(query)

                        # Render results.html with search results
                        context = {
                            'query': query,
                            'hits': search_results
                        }
                        results_content = render_template(os.path.join(domain_root, 'results.html'), context)
                        send_response(conn, 'OK', 'text/html', results_content)
                        logging.info(f"Sent search results to {addr}")
                        continue

                # Serve static or other files
                send_large_file(conn, file_path)

            elif action == 'SEARCH':
                # Handle SEARCH action
                search_response = handle_search_action(headers)
                if search_response['status'] == 'OK':
                    response_body = json.dumps(search_response['results']).encode('utf-8')
                    response_headers = (
                        f"SMP 1.0\n"
                        f"STATUS: OK\n"
                        f"CONTENT-TYPE: application/json\n"
                        f"CONTENT-LENGTH: {len(response_body)}\n\n"
                    )
                    conn.sendall(response_headers.encode() + response_body)
                    logging.info(f"Sent JSON search results to {addr}")
                else:
                    message = search_response.get('message', 'Unknown error.')
                    response = (
                        f"SMP 1.0\n"
                        f"STATUS: ERROR\n"
                        f"MESSAGE: {message}\n"
                        f"CONTENT-TYPE: text/plain\n"
                        f"CONTENT-LENGTH: {len(message)}\n\n"
                        f"{message}"
                    )
                    conn.sendall(response.encode())
                    logging.warning(f"Search error for {addr}: {message}")

            else:
                message = "Invalid ACTION or missing RESOURCE"
                response = (
                    f"SMP 1.0\n"
                    f"STATUS: ERROR\n"
                    f"MESSAGE: {message}\n"
                    f"CONTENT-TYPE: text/plain\n"
                    f"CONTENT-LENGTH: {len(message)}\n\n"
                    f"{message}"
                )
                conn.sendall(response.encode())
                logging.warning(f"Invalid request: ACTION={action}, RESOURCE={resource}")

        except ConnectionResetError as e:
            logging.info(f"Client {addr} disconnected: {e}")
            break
        except Exception as e:
            logging.error(f"Error handling client {addr}: {e}")
            break

    conn.close()
    logging.info(f"Connection with {addr} closed")

def start_server():
    """
    Starts the SMP server to listen for incoming connections.
    """
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        server_socket.bind((HOST, PORT))
        server_socket.listen()
        logging.info(f"SMP Server started on {HOST}:{PORT}")

        while True:
            conn, addr = server_socket.accept()
            client_thread = threading.Thread(target=handle_client, args=(conn, addr), daemon=True)
            client_thread.start()

if __name__ == "__main__":
    start_server()
