import socket
import threading
import logging
import os
from urllib.parse import urlparse, parse_qs
import shutil

# Server Settings
HOST = '0.0.0.0'  # Listen on all interfaces
PORT = 8080
BUFFER_SIZE = 4096  # Buffer size for data transmission

# Logging Configuration
logging.basicConfig(
    filename='smp_server.log',
    level=logging.INFO,
    format='%(asctime)s:%(levelname)s:%(message)s'
)

# Allowed Domains and Their Root Directories
ALLOWED_DOMAINS = {
    'example.com': 'sites/example.com',
    'test.com': 'sites/test.com',
    'search.com': 'sites/search.com'  # Search Engine Domain
}

# Search Index (Inverted Index)
search_index = {}

def build_search_index():
    """
    Builds a simple inverted index from the content of the hosted sites.
    """
    global search_index
    search_index = {}
    for domain, root in ALLOWED_DOMAINS.items():
        if not os.path.exists(root):
            logging.warning(f"Root directory for {domain} does not exist.")
            continue
        for root_dir, _, files in os.walk(root):
            for file in files:
                if file.endswith('.html') or file.endswith('.htm'):
                    file_path = os.path.join(root_dir, file)
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read().lower()
                            words = set(content.split())
                            for word in words:
                                if word not in search_index:
                                    search_index[word] = []
                                # Store the URL path relative to the domain
                                relative_path = os.path.relpath(file_path, root)
                                url = f"smp://{domain}/{relative_path.replace(os.sep, '/')}"
                                if url not in search_index[word]:
                                    search_index[word].append(url)
                        logging.info(f"Indexed file: {file_path}")
                    except Exception as e:
                        logging.error(f"Error indexing file {file_path}: {e}")

def send_large_file(conn, filepath):
    """
    Sends a file to the client in chunks with appropriate headers.
    """
    if not os.path.exists(filepath):
        logging.error(f"File not found: {filepath}")
        message = "File not found"
        response = (
            f"SMP 1.0\n"
            f"STATUS: ERROR\n"
            f"MESSAGE: {message}\n"
            f"CONTENT-TYPE: text/plain\n"
            f"CONTENT-LENGTH: {len(message)}\n\n"
            f"{message}"
        )
        conn.sendall(response.encode())
        return

    try:
        file_size = os.path.getsize(filepath)
        _, ext = os.path.splitext(filepath)
        ext = ext.lower()
        if ext in ['.html', '.htm']:
            content_type = 'text/html'
        elif ext == '.css':
            content_type = 'text/css'
        elif ext == '.png':
            content_type = 'image/png'
        elif ext in ['.jpg', '.jpeg']:
            content_type = 'image/jpeg'
        elif ext == '.gif':
            content_type = 'image/gif'
        elif ext == '.js':
            content_type = 'application/javascript'
        else:
            content_type = 'application/octet-stream'

        # Send Headers
        response_headers = (
            f"SMP 1.0\n"
            f"STATUS: OK\n"
            f"CONTENT-TYPE: {content_type}\n"
            f"CONTENT-LENGTH: {file_size}\n\n"
        )
        conn.send(response_headers.encode())
        logging.info(f"Sending file: {filepath}")

        # Send File in Chunks
        with open(filepath, 'rb') as f:
            while True:
                chunk = f.read(BUFFER_SIZE)
                if not chunk:
                    break
                conn.sendall(chunk)
        logging.info(f"File sent: {filepath}")
    except Exception as e:
        logging.error(f"Error sending file {filepath}: {e}")
        message = f"Error sending file: {e}"
        response = (
            f"SMP 1.0\n"
            f"STATUS: ERROR\n"
            f"MESSAGE: {message}\n"
            f"CONTENT-TYPE: text/plain\n"
            f"CONTENT-LENGTH: {len(message)}\n\n"
            f"{message}"
        )
        conn.sendall(response.encode())

def handle_search(query):
    """
    Performs a simple search on the indexed data.
    """
    results = set()
    for word in query.lower().split():
        if word in search_index:
            results.update(search_index[word])
    return list(results)

def generate_search_results_page(query, results):
    """
    Generates an HTML page with search results.
    """
    html = f"""<!DOCTYPE html>
<html>
<head>
    <title>Search Results for "{query}"</title>
    <style>
        body {{ font-family: Arial, sans-serif; }}
        .result {{ margin-bottom: 20px; }}
        .result h3 {{ margin: 0; }}
        .result p {{ margin: 5px 0; }}
        .result img {{ max-width: 100px; }}
    </style>
</head>
<body>
    <h1>Search Results for "{query}"</h1>
    <form method="GET" action="smp://search.com/search">
        <input type="text" name="q" value="{query}" />
        <button type="submit">Search</button>
    </form>
    <hr />
"""
    if results:
        for url in results:
            parsed = urlparse(url)
            domain = parsed.hostname
            path = parsed.path
            # For simplicity, extract title and assume logo exists at assets/logo.png
            domain_root = ALLOWED_DOMAINS.get(domain, '')
            file_path = os.path.join(domain_root, path.lstrip('/'))
            title = "No Title"
            description = "No Description"
            logo_url = f"smp://{domain}/assets/logo.png"
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    for line in f:
                        if '<title>' in line.lower():
                            start = line.lower().find('<title>') + 7
                            end = line.lower().find('</title>')
                            title = line[start:end].strip()
                            break
                # Description extraction can be enhanced
                description = "Description not available."
            except:
                pass
            html += f"""
    <div class="result">
        <img src="{logo_url}" alt="Logo" />
        <h3><a href="{url}">{title}</a></h3>
        <p>{description}</p>
    </div>
"""
    else:
        html += "<p>No results found.</p>"

    html += """
</body>
</html>
"""
    return html

def handle_client(conn, addr):
    """
    Handles client connections in separate threads.
    """
    logging.info(f"Client connected: {addr}")
    try:
        data = b""
        while b"\n\n" not in data:
            part = conn.recv(BUFFER_SIZE)
            if not part:
                raise ConnectionResetError("Client closed the connection")
            data += part
        header_data, _, body = data.partition(b"\n\n")
        headers = {}
        for line in header_data.decode().split('\n'):
            if ': ' in line:
                key, value = line.split(': ', 1)
                headers[key.strip().upper()] = value.strip()
        action = headers.get('ACTION')
        resource = headers.get('RESOURCE')

        if action == 'GET' and resource:
            # Parse resource
            parsed = urlparse('smp://' + resource)  # For urlparse
            domain = parsed.hostname
            path = parsed.path.lstrip('/')  # Remove leading '/'
            if domain not in ALLOWED_DOMAINS:
                message = "Domain not allowed"
                response = (
                    f"SMP 1.0\n"
                    f"STATUS: ERROR\n"
                    f"MESSAGE: {message}\n"
                    f"CONTENT-TYPE: text/plain\n"
                    f"CONTENT-LENGTH: {len(message)}\n\n"
                    f"{message}"
                )
                conn.send(response.encode())
                logging.warning(f"Disallowed domain requested: {domain}")
                return

            if domain == 'search.com' and path.startswith('search'):
                # Handle search query
                query_params = parse_qs(parsed.query)
                query = query_params.get('q', [''])[0]
                results = handle_search(query)
                search_page = generate_search_results_page(query, results)
                search_file_path = os.path.join(ALLOWED_DOMAINS[domain], 'search_results.html')
                with open(search_file_path, 'w', encoding='utf-8') as f:
                    f.write(search_page)
                send_large_file(conn, search_file_path)
                os.remove(search_file_path)  # Clean up
                return

            # Determine file path
            domain_root = ALLOWED_DOMAINS[domain]
            file_path = os.path.join(domain_root, path) if path else os.path.join(domain_root, 'index.html')

            # Prevent directory traversal
            real_file_path = os.path.realpath(file_path)
            real_domain_root = os.path.realpath(domain_root)
            if not real_file_path.startswith(real_domain_root):
                message = "Invalid resource path"
                response = (
                    f"SMP 1.0\n"
                    f"STATUS: ERROR\n"
                    f"MESSAGE: {message}\n"
                    f"CONTENT-TYPE: text/plain\n"
                    f"CONTENT-LENGTH: {len(message)}\n\n"
                    f"{message}"
                )
                conn.send(response.encode())
                logging.warning(f"Invalid resource path: {file_path}")
                return

            # If directory, send index.html
            if os.path.isdir(file_path):
                file_path = os.path.join(file_path, 'index.html')
                if not os.path.exists(file_path):
                    message = "Resource not found"
                    response = (
                        f"SMP 1.0\n"
                        f"STATUS: ERROR\n"
                        f"MESSAGE: {message}\n"
                        f"CONTENT-TYPE: text/plain\n"
                        f"CONTENT-LENGTH: {len(message)}\n\n"
                        f"{message}"
                    )
                    conn.send(response.encode())
                    logging.warning(f"Resource not found: {file_path}")
                    return

            # Send the requested file
            send_large_file(conn, file_path)
        else:
            message = "Invalid ACTION or missing RESOURCE"
            response = (
                f"SMP 1.0\n"
                f"STATUS: ERROR\n"
                f"MESSAGE: {message}\n"
                f"CONTENT-TYPE: text/plain\n"
                f"CONTENT-LENGTH: {len(message)}\n\n"
                f"{message}"
            )
            conn.send(response.encode())
            logging.warning(f"Invalid request: ACTION={action}, RESOURCE={resource}")
    except ConnectionResetError as e:
        logging.info(f"Client {addr} disconnected: {e}")
    except Exception as e:
        logging.error(f"Error handling client {addr}: {e}")
    finally:
        conn.close()
        logging.info(f"Connection with {addr} closed")

def start_server():
    """
    Starts the SMP server to listen for incoming connections.
    """
    build_search_index()  # Initial indexing
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        server_socket.bind((HOST, PORT))
        server_socket.listen()
        logging.info(f"SMP Server started on {HOST}:{PORT}")
        while True:
            conn, addr = server_socket.accept()
            client_thread = threading.Thread(target=handle_client, args=(conn, addr), daemon=True)
            client_thread.start()

if __name__ == "__main__":
    # Ensure the sites directory exists
    if not os.path.exists('sites'):
        os.makedirs('sites')
        logging.info("Created 'sites' directory.")

    # Create directories for allowed domains if they don't exist
    for domain, path in ALLOWED_DOMAINS.items():
        if not os.path.exists(path):
            os.makedirs(path)
            logging.info(f"Created directory for domain: {domain}")

    start_server()
