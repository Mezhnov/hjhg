// Включаем необходимые заголовочные файлы
#include <windows.h>
#include <gdiplus.h>
#include <urlmon.h>
#include <shlwapi.h> // Для функций работы с путями
#include <string>
#include <ctime>
#include <vector>
#include <windowsx.h>
#include <cstdlib> // Для rand()
#include <sstream>
#include <map>
#include <codecvt>
#include <locale>
#include <algorithm> // Добавлено для std::replace

#pragma comment (lib,"Gdiplus.lib")
#pragma comment (lib,"Urlmon.lib")
#pragma comment (lib,"Shlwapi.lib")

// Глобальные переменные
HINSTANCE hInst;
HWND hMarkyEdit;
HWND hStylinEdit;
HWND hRunButton;
HWND hMainWnd;

// Структуры для хранения элементов UI и стилей
struct UIElement {
    std::wstring type;
    std::wstring id;
    std::wstring text;
    std::wstring src; // Для изображений
    std::wstring action; // Для событий
    POINT position{ 0, 0 };
    SIZE size{ 0, 0 };
};

struct Style {
    int fontSize = 0;
    COLORREF textColor = RGB(0, 0, 0);
    COLORREF backgroundColor = RGB(255, 255, 255);
    std::wstring fontFamily = L"Arial";
};

struct EventHandler {
    std::wstring id;
    std::wstring action;
};

// Словари для хранения элементов и стилей
std::vector<UIElement> uiElements;
std::map<std::wstring, Style> styles;
std::map<std::wstring, EventHandler> eventHandlers;

// Карта для сопоставления HWND контролов с их цветовыми параметрами
std::map<HWND, Style> controlStyles;

// Функции для парсинга
void ParseMarky(const std::wstring& markyCode);
void ParseStylin(const std::wstring& stylinCode);

// Функции для создания интерфейса
void CreateUI(HWND parent);

// Вспомогательные функции
COLORREF ParseColor(const std::wstring& colorStr);
void ApplyStyle(HWND hControl, const Style& style);
Gdiplus::Bitmap* LoadImageFromURL(const std::wstring& url);

// Прототипы оконных процедур
LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK UIWndProc(HWND, UINT, WPARAM, LPARAM);

// Глобальные переменные для GDI+
ULONG_PTR gdiplusToken;

// Карта для сопоставления HWND кнопки с ее действием
std::map<HWND, std::wstring> buttonActions;

// Предустановленный код Marky и Stylin
const wchar_t* defaultMarkyCode = LR"(
window:
title: "Пример интерфейса"
size: 500x400
elements:
- label:
    id: "label1"
    text: "Привет, Мир!"
    position: 50x50
    size: 200x30

- button:
    id: "button1"
    text: "Нажми меня"
    position: 50x100
    size: 150x40
    action: "message"

- image:
    id: "image1"
    src: "https://via.placeholder.com/100"
    position: 50x160
    size: 100x100
)";

const wchar_t* defaultStylinCode = LR"(
label:
    font-size: 18
    color: RGB(0, 0, 255) # Синий цвет текста
    font-family: "Calibri"

button:
    font-size: 16
    color: RGB(255, 255, 255) # Белый цвет текста
    background-color: RGB(0, 128, 0) # Зеленый фон
    font-family: "Arial"

#label1:
    font-size: 20
    color: RGB(255, 0, 0) # Красный текст для конкретного элемента

#button1:
    background-color: RGB(0, 0, 128) # Синий фон для конкретной кнопки
)";

// Главная функция
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow) {
    hInst = hInstance;

    // Инициализация GDI+
    Gdiplus::GdiplusStartupInput gdiplusStartupInput;
    if (Gdiplus::Ok != Gdiplus::GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, nullptr)) {
        MessageBox(nullptr, L"Не удалось инициализировать GDI+", L"Ошибка", MB_OK);
        return 1;
    }

    // Регистрация класса окна
    WNDCLASS wc = {};
    wc.lpfnWndProc = MainWndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L"MarkyStylinIDE";

    RegisterClass(&wc);

    // Создание главного окна
    hMainWnd = CreateWindowEx(
        0,
        wc.lpszClassName,
        L"Marky & Stylin IDE",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 800, 600,
        nullptr,
        nullptr,
        hInstance,
        nullptr
    );

    ShowWindow(hMainWnd, nCmdShow);

    // Цикл сообщений
    MSG msg = {};
    while (GetMessage(&msg, nullptr, 0, 0)) {
        if (!IsDialogMessage(hMainWnd, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    // Завершение работы GDI+
    Gdiplus::GdiplusShutdown(gdiplusToken);

    return 0;
}

// Создание элементов управления в главном окне
void CreateControls(HWND hwnd) {
    CreateWindowW(L"STATIC", L"Marky Code:",
        WS_VISIBLE | WS_CHILD,
        10, 10, 100, 20,
        hwnd, nullptr, hInst, nullptr);

    hMarkyEdit = CreateWindowExW(WS_EX_CLIENTEDGE, L"EDIT", L"",
        WS_VISIBLE | WS_CHILD | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
        10, 30, 360, 500,
        hwnd, (HMENU)101, hInst, nullptr);

    // Устанавливаем предустановленный код Marky
    SetWindowTextW(hMarkyEdit, defaultMarkyCode);

    CreateWindowW(L"STATIC", L"Stylin Code:",
        WS_VISIBLE | WS_CHILD,
        380, 10, 100, 20,
        hwnd, nullptr, hInst, nullptr);

    hStylinEdit = CreateWindowExW(WS_EX_CLIENTEDGE, L"EDIT", L"",
        WS_VISIBLE | WS_CHILD | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
        380, 30, 360, 500,
        hwnd, (HMENU)102, hInst, nullptr);

    // Устанавливаем предустановленный код Stylin
    SetWindowTextW(hStylinEdit, defaultStylinCode);

    hRunButton = CreateWindowW(L"BUTTON", L"Запустить",
        WS_VISIBLE | WS_CHILD,
        10, 540, 100, 30,
        hwnd, (HMENU)1, hInst, nullptr);
}

// Оконная процедура главного окна
LRESULT CALLBACK MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg)
    {
    case WM_CREATE:
        CreateControls(hwnd);
        break;
    case WM_COMMAND:
        if (LOWORD(wParam) == 1) // Нажата кнопка "Запустить"
        {
            // Получаем код из контролов
            WCHAR markyBuffer[10000];
            GetWindowTextW(hMarkyEdit, markyBuffer, 10000);
            std::wstring markyCode = markyBuffer;

            WCHAR stylinBuffer[10000];
            GetWindowTextW(hStylinEdit, stylinBuffer, 10000);
            std::wstring stylinCode = stylinBuffer;

            // Парсим код
            ParseMarky(markyCode);
            ParseStylin(stylinCode);

            // Создаем новое окно для отображения интерфейса
            WNDCLASS wc = {};
            wc.lpfnWndProc = UIWndProc;
            wc.hInstance = hInst;
            wc.lpszClassName = L"UIWindowClass";

            RegisterClass(&wc);

            HWND hUIWindow = CreateWindowEx(
                0,
                wc.lpszClassName,
                L"Результат",
                WS_OVERLAPPEDWINDOW,
                CW_USEDEFAULT, CW_USEDEFAULT, 600, 500,
                hwnd,
                nullptr,
                hInst,
                nullptr
            );

            ShowWindow(hUIWindow, SW_SHOW);
        }
        break;
    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLORBTN:
    {
        HDC hdcStatic = (HDC)wParam;
        HWND hControl = (HWND)lParam;
        auto it = controlStyles.find(hControl);
        if (it != controlStyles.end()) {
            SetTextColor(hdcStatic, it->second.textColor);
            SetBkMode(hdcStatic, TRANSPARENT);
            return (INT_PTR)GetStockObject(NULL_BRUSH);
        }
        break;
    }
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// Оконная процедура окна интерфейса
LRESULT CALLBACK UIWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg)
    {
    case WM_CREATE:
        CreateUI(hwnd);
        break;
    case WM_COMMAND:
    {
        HWND hControl = (HWND)lParam;
        if (buttonActions.find(hControl) != buttonActions.end()) {
            std::wstring action = buttonActions[hControl];
            if (action == L"close") {
                DestroyWindow(hwnd);
            }
            else if (action == L"message") {
                MessageBox(hwnd, L"Кнопка нажата!", L"Информация", MB_OK);
            }
            // Добавьте дополнительные действия здесь
        }
        break;
    }
    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLORBTN:
    {
        HDC hdcStatic = (HDC)wParam;
        HWND hControl = (HWND)lParam;
        auto it = controlStyles.find(hControl);
        if (it != controlStyles.end()) {
            SetTextColor(hdcStatic, it->second.textColor);
            SetBkMode(hdcStatic, TRANSPARENT);
            return (INT_PTR)GetStockObject(NULL_BRUSH);
        }
        break;
    }
    case WM_DESTROY:
        // Очищаем элементы и стили после закрытия окна
        uiElements.clear();
        styles.clear();
        eventHandlers.clear();
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// Функция парсинга Marky
void ParseMarky(const std::wstring& markyCode) {
    uiElements.clear();

    std::wistringstream iss(markyCode);
    std::wstring line;
    UIElement currentWindow;
    bool inElements = false;
    UIElement element;

    while (std::getline(iss, line)) {
        // Убираем начальные и конечные пробелы
        line.erase(0, line.find_first_not_of(L" \t"));
        line.erase(line.find_last_not_of(L" \t\r\n") + 1);

        if (line.empty() || line[0] == L'#')
            continue; // Пропускаем пустые строки и комментарии

        if (line.find(L"window:") == 0) {
            // Начало описания окна
            inElements = false;
        }
        else if (line.find(L"title:") == 0) {
            currentWindow.text = line.substr(6);
            currentWindow.text.erase(0, currentWindow.text.find_first_not_of(L" \""));
            currentWindow.text.erase(currentWindow.text.find_last_not_of(L" \"") + 1);
        }
        else if (line.find(L"size:") == 0) {
            std::wstring sizeStr = line.substr(5);
            sizeStr.erase(0, sizeStr.find_first_not_of(L" \t"));
            size_t xPos = sizeStr.find(L'x');
            if (xPos != std::wstring::npos) {
                currentWindow.size.cx = std::stoi(sizeStr.substr(0, xPos));
                currentWindow.size.cy = std::stoi(sizeStr.substr(xPos + 1));
            }
        }
        else if (line.find(L"elements:") == 0) {
            inElements = true;
        }
        else if (inElements && line[0] == L'-') {
            if (!element.type.empty()) {
                uiElements.push_back(element);
            }
            // Начало описания элемента
            element = UIElement();
            size_t pos = line.find(L':');
            if (pos != std::wstring::npos) {
                element.type = line.substr(1, pos - 1);
                element.type.erase(0, element.type.find_first_not_of(L" \t"));
                element.type.erase(element.type.find_last_not_of(L" \t") + 1);
            }
        }
        else if (inElements) {
            size_t colonPos = line.find(L':');
            if (colonPos != std::wstring::npos) {
                std::wstring key = line.substr(0, colonPos);
                std::wstring value = line.substr(colonPos + 1);
                key.erase(0, key.find_first_not_of(L" \t"));
                key.erase(key.find_last_not_of(L" \t") + 1);
                value.erase(0, value.find_first_not_of(L" \t\""));
                value.erase(value.find_last_not_of(L" \t\"") + 1);

                if (key == L"id") {
                    element.id = value;
                }
                else if (key == L"text") {
                    element.text = value;
                }
                else if (key == L"src") {
                    element.src = value;
                }
                else if (key == L"position") {
                    size_t xPos = value.find(L'x');
                    if (xPos != std::wstring::npos) {
                        element.position.x = std::stoi(value.substr(0, xPos));
                        element.position.y = std::stoi(value.substr(xPos + 1));
                    }
                }
                else if (key == L"size") {
                    size_t xPos = value.find(L'x');
                    if (xPos != std::wstring::npos) {
                        element.size.cx = std::stoi(value.substr(0, xPos));
                        element.size.cy = std::stoi(value.substr(xPos + 1));
                    }
                }
                else if (key == L"action") {
                    element.action = value;
                    // Сохраняем обработчик события
                    eventHandlers[element.id] = { element.id, element.action };
                }
            }
            else if (line.empty()) {
                // Конец описания элемента
                uiElements.push_back(element);
            }
        }
    }

    // Добавляем последний элемент, если не был добавлен
    if (!element.type.empty()) {
        uiElements.push_back(element);
    }

    // Устанавливаем параметры окна на основе парсинга
    // Здесь можно сохранить параметры окна, если потребуется
}

// Функция парсинга Stylin
void ParseStylin(const std::wstring& stylinCode) {
    styles.clear();

    std::wistringstream iss(stylinCode);
    std::wstring line;
    std::wstring currentSelector;

    while (std::getline(iss, line)) {
        // Убираем начальные и конечные пробелы
        line.erase(0, line.find_first_not_of(L" \t"));
        line.erase(line.find_last_not_of(L" \t\r\n") + 1);

        if (line.empty() || line[0] == L'#')
            continue; // Пропускаем пустые строки и комментарии

        if (line.back() == L':') {
            currentSelector = line.substr(0, line.length() - 1);
            currentSelector.erase(0, currentSelector.find_first_not_of(L" \t"));
            currentSelector.erase(currentSelector.find_last_not_of(L" \t") + 1);
        }
        else {
            size_t colonPos = line.find(L':');
            if (colonPos != std::wstring::npos) {
                std::wstring property = line.substr(0, colonPos);
                std::wstring value = line.substr(colonPos + 1);

                property.erase(0, property.find_first_not_of(L" \t"));
                property.erase(property.find_last_not_of(L" \t") + 1);
                value.erase(0, value.find_first_not_of(L" \t"));
                value.erase(value.find_last_not_of(L" \t") + 1);

                Style& style = styles[currentSelector];

                if (property == L"font-size") {
                    style.fontSize = std::stoi(value);
                }
                else if (property == L"color" || property == L"text-color") {
                    style.textColor = ParseColor(value);
                }
                else if (property == L"background-color") {
                    style.backgroundColor = ParseColor(value);
                }
                else if (property == L"font-family") {
                    style.fontFamily = value;
                    // Убираем кавычки, если есть
                    if (!style.fontFamily.empty() && style.fontFamily.front() == L'"') {
                        style.fontFamily.erase(0, 1);
                    }
                    if (!style.fontFamily.empty() && style.fontFamily.back() == L'"') {
                        style.fontFamily.erase(style.fontFamily.size() - 1, 1);
                    }
                }
            }
        }
    }
}

// Функция создания интерфейса на основе парсинга
void CreateUI(HWND parent) {
    for (const auto& element : uiElements) {
        HWND hControl = nullptr;
        if (element.type == L"label") {
            hControl = CreateWindowW(L"STATIC", element.text.c_str(),
                WS_VISIBLE | WS_CHILD,
                element.position.x, element.position.y, element.size.cx, element.size.cy,
                parent, nullptr, hInst, nullptr);

            // Применяем стили
            auto it = styles.find(L"label");
            if (it != styles.end()) {
                ApplyStyle(hControl, it->second);
            }
        }
        else if (element.type == L"button") {
            hControl = CreateWindowW(L"BUTTON", element.text.c_str(),
                WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
                element.position.x, element.position.y, element.size.cx, element.size.cy,
                parent, nullptr, hInst, nullptr);

            // Применяем стили
            auto it = styles.find(L"button");
            if (it != styles.end()) {
                ApplyStyle(hControl, it->second);
            }

            // Обрабатываем события
            if (!element.action.empty()) {
                buttonActions[hControl] = element.action;
                SetWindowLongPtr(hControl, GWLP_ID, (LONG_PTR)hControl);
            }
        }
        else if (element.type == L"image") {
            // Загружаем изображение
            Gdiplus::Bitmap* image = LoadImageFromURL(element.src);
            if (image) {
                HWND hImageControl = CreateWindowW(L"STATIC", nullptr,
                    WS_VISIBLE | WS_CHILD | SS_BITMAP,
                    element.position.x, element.position.y, element.size.cx, element.size.cy,
                    parent, nullptr, hInst, nullptr);

                // Устанавливаем изображение в контрол
                HBITMAP hBitmap;
                image->GetHBITMAP(NULL, &hBitmap);
                SendMessage(hImageControl, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
                delete image;
            }
        }

        // Применяем стили с использованием идентификатора
        if (hControl && !element.id.empty()) {
            auto it = styles.find(L"#" + element.id);
            if (it != styles.end()) {
                ApplyStyle(hControl, it->second);
            }
        }
    }
}

// Функция парсинга цвета из строки
COLORREF ParseColor(const std::wstring& colorStr) {
    if (colorStr.find(L"RGB(") == 0 && colorStr.back() == L')') {
        std::wstring values = colorStr.substr(4, colorStr.length() - 5);
        std::replace(values.begin(), values.end(), L',', L' ');
        int r = 0, g = 0, b = 0;
        std::wistringstream iss(values);
        iss >> r >> g >> b;
        return RGB(r, g, b);
    }
    return RGB(0, 0, 0);
}

// Применение стилей к контролу
void ApplyStyle(HWND hControl, const Style& style) {
    if (style.fontSize > 0 || !style.fontFamily.empty()) {
        // Изменяем шрифт
        HFONT hFont = CreateFontW(
            -MulDiv(style.fontSize, GetDeviceCaps(GetDC(hControl), LOGPIXELSY), 72),
            0, 0, 0, FW_NORMAL,
            FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_OUTLINE_PRECIS,
            CLIP_DEFAULT_PRECIS, CLEARTYPE_QUALITY, VARIABLE_PITCH, style.fontFamily.c_str());
        SendMessage(hControl, WM_SETFONT, (WPARAM)hFont, TRUE);
    }

    // Устанавливаем цвета
    controlStyles[hControl] = style;
    InvalidateRect(hControl, NULL, TRUE);
}

// Функция загрузки изображения по URL
Gdiplus::Bitmap* LoadImageFromURL(const std::wstring& url) {
    IStream* pStream = NULL;
    HRESULT hr = URLOpenBlockingStreamW(NULL, url.c_str(), &pStream, 0, NULL);
    if (SUCCEEDED(hr) && pStream) {
        Gdiplus::Bitmap* bitmap = new Gdiplus::Bitmap(pStream);
        pStream->Release();
        if (bitmap->GetLastStatus() == Gdiplus::Ok) {
            return bitmap;
        }
        delete bitmap;
    }
    return nullptr;
}
